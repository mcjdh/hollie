<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>∞ ⋆∞⋆</title>
    <link rel="stylesheet" href="palette.css">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%); 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            font-family: 'Courier New', monospace;
        }
        #display { 
            font-family: 'Courier New', monospace; 
            color: var(--cosmos-tiffany); 
            white-space: pre; 
            padding: 0; 
            margin: 0;
            width: 100vw; 
            height: 100vh; 
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%);
            position: absolute;
            top: 0;
            left: 0;
            line-height: 1.0;
            overflow: hidden;
            font-size: 8px;
        }
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: var(--cosmos-tiffany);
            z-index: 100;
            background: linear-gradient(135deg, var(--cosmos-dark-dim), var(--cosmos-rose-dim));
            padding: 10px;
            border-radius: 5px;
            border: 2px solid var(--cosmos-tiffany);
            box-shadow: 0 0 20px rgba(173, 235, 218, 0.3);
            text-shadow: 0 0 8px var(--cosmos-tiffany);
        }    </style>
</head>
<body>
    <div class="info">
        ∞ ⋆∞⋆<br>
        ∇×E = -∂B/∂t<br>
        ⌫ ◦ ↩
    </div>
    <div id="display"></div>    <script>
        const display = document.getElementById('display');
        // Dynamic viewport sizing - responsive to window dimensions
        let W, H;
        let charWidth, charHeight;
        let t = 0;
        const MAX_COLS = 160;
        const MAX_ROWS = 80;
        const FPS = 30;
        let lastFrame = 0;
        
        // Calculate optimal grid size based on viewport
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Character measurement at baseline
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '8px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = '⋆'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);

            const rect = testDiv.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(testDiv);

            // Grid size estimate
            W = Math.ceil(viewportWidth / charWidth) + 2;
            H = Math.ceil(viewportHeight / charHeight) + 2;

            W = Math.max(40, W);
            H = Math.max(20, H);
            W = Math.min(MAX_COLS, W);
            H = Math.min(MAX_ROWS, H);

            // Scale font to fill viewport
            const fontSize = Math.min(viewportWidth / W, viewportHeight / H);
            display.style.fontSize = fontSize + 'px';
            display.style.lineHeight = fontSize + 'px';

            charWidth = fontSize;
            charHeight = fontSize;
        }
        
        // Stellar field arrays
        let field, velocity, density, luminosity;
        
        function initializeFields() {
            const size = W * H;
            field = new Float32Array(size);        // Gravitational field
            velocity = new Float32Array(size);     // Stellar motion
            density = new Float32Array(size);      // Star density
            luminosity = new Float32Array(size);   // Brightness field
            
            // Initialize with quantum noise
            for (let i = 0; i < size; i++) {
                field[i] = (Math.random() - 0.5) * 0.1;
                velocity[i] = (Math.random() - 0.5) * 0.05;
                density[i] = Math.random() * 0.3;
                luminosity[i] = Math.random();
            }
        }
        
        // Stellar symbols - mathematical progression
        const starSymbols = [
            '·', '∘', '○', '●', '⋆', '★', '✦', '✧', '✩', '✪', '✫', '⭐',
            '∗', '∙', '⁂', '※', '⊙', '⊚', '⊛', '⊜', '⊝',
            '∞', '∅', '∩', '∪', '⊕', '⊗'
        ];

        const colorClasses = [
            'v','u','s','e','m','t','q','d','w','c',
            'g','y','r','p','b','o','a','f','n','l'
        ];

        const starCount = starSymbols.length;
        const colorCount = colorClasses.length;
        
        // Stellar field equations tuned for smoother distribution
        function stellarField(x, y, time) {
            const xi = (x - W/2) / (W/4);
            const yi = (y - H/2) / (H/4);
            const r = Math.sqrt(xi * xi + yi * yi);
            const angle = Math.atan2(yi, xi);

            // Radial falloff approximates galactic density
            const base = Math.exp(-r * 1.5);

            // Spiral arms
            const arms = Math.sin(angle * 5 + r * 2 - time) * 0.2;

            // Subtle local swirl
            const swirl = Math.sin(angle + time * 0.5) * 0.05;

            // Final stellar density
            const dens = base + arms * 0.3 + swirl;

            // Apparent velocity for color shift
            const vel = arms * 0.5;

            return { density: dens, velocity: vel, phase: angle, r };
        }
        
        function update() {
            t += 0.02;
            
            // Update stellar field
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const stellar = stellarField(x, y, t);
                    
                    // Field evolution with memory
                    field[idx] = field[idx] * 0.95 + stellar.density * 0.05;
                    velocity[idx] = velocity[idx] * 0.98 + stellar.velocity * 0.02;
                    
                    // Non-linear coupling
                    const coupling = Math.sin(stellar.phase) * field[idx];
                    density[idx] = Math.max(0, Math.min(1, 
                        density[idx] * 0.97 + coupling * 0.03
                    ));
                    
                    // Luminosity with distance falloff and twinkling
                    const twinkle = Math.sin(t * 5 + x * 0.1 + y * 0.07) * 0.2 + 0.8;
                    const distanceFactor = Math.exp(-stellar.r * 0.6);
                    const baseLum = Math.pow(density[idx], 1.3);
                    luminosity[idx] = baseLum * twinkle * distanceFactor;
                }
            }
        }
        
        function render() {
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const intensity = luminosity[idx];
                    const motion = velocity[idx];
                    const dist = Math.sqrt(((x - W/2)/(W/2))**2 + ((y - H/2)/(H/2))**2);
                    
                    if (intensity > 0.7) {
                        // Bright stars - complex symbols
                        const symbolIdx = Math.floor(intensity * starCount * 0.8) +
                                        Math.floor(starCount * 0.2);
                        const colorIdx = Math.floor((intensity * 0.6 + (1 - dist) * 0.4 + motion * 0.3) * colorCount);
                        const symbol = starSymbols[Math.min(symbolIdx, starCount - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorCount - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.4) {
                        // Medium stars
                        const symbolIdx = Math.floor(intensity * starCount * 0.5);
                        const colorIdx = Math.floor((intensity * 0.6 + (1 - dist) * 0.4) * colorCount * 0.9);
                        const symbol = starSymbols[Math.min(symbolIdx, starCount - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorCount - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.2) {
                        // Dim stars
                        const symbol = starSymbols[Math.floor(intensity * 5)];
                        output += `<span class="l">${symbol}</span>`;
                    } else {
                        // Empty space with occasional cosmic background
                        if (Math.random() < 0.001) {
                            output += '<span class="l">∘</span>';
                        } else {
                            output += ' ';
                        }
                    }
                }
                output += '\n';
            }
            
            display.innerHTML = output;
        }
        
        function loop(now) {
            if (now - lastFrame < 1000/FPS) { requestAnimationFrame(loop); return; }
            lastFrame = now;
            update();
            render();
            requestAnimationFrame(loop);
        }
        
        // Initialize
        window.addEventListener('resize', () => {
            updateDimensions();
            initializeFields();
        });

        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateDimensions();
                initializeFields();
            }, 100);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && window.parent !== window) {
                window.parent.postMessage('close', '*');
            }
        });

        updateDimensions();
        initializeFields();
        requestAnimationFrame(loop);
    </script>
</body>
</html>
