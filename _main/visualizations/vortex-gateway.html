<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>∾◉∾ ⟲∿⟲ ∾◉∾</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        #vortex {
            font-size: clamp(8px, 2vw, 14px);
            line-height: 1;
            white-space: pre;
            text-align: center;
            filter: drop-shadow(0 0 3px currentColor);
        }

        .glyph {
            display: inline-block;
            width: 0.6em;
            transition: all 0.15s ease;
        }

        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 11px;
            color: #666;
            z-index: 10;
        }

        @media (max-width: 600px) {
            #vortex { font-size: 10px; }
        }
    </style>
</head>
<body>    <div class="controls">
        ⌫: ◊ | ⎵: ◦ | ←→: ⟲ | ↑↓: ∿
    </div>
    
    <pre id="vortex"></pre>    <script>
        let W, H;
        let frame = 0;
        let speed = 0.04;
        let intensity = 1.0;
        let paused = false;
        
        const vortex = document.getElementById('vortex');
        
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate optimal character dimensions
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = getComputedStyle(vortex).fontSize;
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1';
            testDiv.textContent = '○'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            const charWidth = rect.width / 10;
            const charHeight = rect.height / 10;
            document.body.removeChild(testDiv);
            
            // Calculate dynamic grid size for optimal display
            W = Math.floor(viewportWidth / charWidth);
            H = Math.floor(viewportHeight / charHeight);
            
            // Ensure reasonable bounds
            W = Math.max(40, Math.min(120, W));
            H = Math.max(20, Math.min(80, H));
        }
        
        const glyphs = [' ', '·', '•', '◦', '○', '●', '◉', '⊙', '⬢', '✶', '✷', '✹', '✺', '✼', '※', '@'];
        
        function render() {
            if (!paused) {
                let output = '';
                
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const dx = x - W/2;
                        const dy = y - H/2;
                        const r = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx) - frame * speed;
                        
                        // Multi-layered vortex with depth and turbulence
                        const vortex1 = Math.sin(r * 0.3 - angle * 2) * intensity;
                        const vortex2 = Math.cos(r * 0.15 + angle * 3 - frame * 0.02) * 0.7;
                        const turbulence = Math.sin(r * 0.8 - angle * 5 + frame * 0.03) * 0.3;
                        const spiral = Math.sin(angle * 4 + r * 0.2 - frame * 0.01) * 0.4;
                        
                        const combined = vortex1 + vortex2 + turbulence + spiral;
                        const normalizedValue = (combined + 3) / 6; // Normalize to 0-1
                        const clampedValue = Math.max(0, Math.min(1, normalizedValue));
                        
                        const glyphIndex = Math.floor(clampedValue * (glyphs.length - 1));
                        const glyph = glyphs[glyphIndex];
                        
                        // Dynamic color with vortex energy
                        const baseHue = (angle * 180 / Math.PI + frame * 2) % 360;
                        const energyShift = Math.sin(r * 0.1 + frame * 0.05) * 60;
                        const hue = (baseHue + energyShift) % 360;
                        const saturation = 60 + 30 * clampedValue;
                        const lightness = 15 + 70 * clampedValue;
                        
                        // Add pulsing effect for high-energy glyphs
                        const pulse = Math.sin(frame * 0.1 + r * 0.3) * 0.2 + 0.8;
                        const finalLightness = clampedValue > 0.7 ? lightness * pulse : lightness;
                        
                        if (glyph === ' ') {
                            output += '<span class="glyph"> </span>';
                        } else {
                            output += `<span class="glyph" style="color:hsl(${hue},${saturation}%,${finalLightness}%)">${glyph}</span>`;
                        }
                    }
                    output += '\n';
                }
                
                vortex.innerHTML = output;
                frame++;
            }
            
            requestAnimationFrame(render);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'escape':
                    window.parent?.postMessage('close', '*');
                    break;
                case ' ':
                    e.preventDefault();
                    paused = !paused;
                    break;
                case 'arrowleft':
                    speed = Math.max(0.005, speed * 0.8);
                    break;
                case 'arrowright':
                    speed = Math.min(0.2, speed * 1.25);
                    break;
                case 'arrowup':
                    intensity = Math.min(2.0, intensity * 1.1);
                    break;
                case 'arrowdown':
                    intensity = Math.max(0.2, intensity * 0.9);
                    break;
            }
        });
        
        // Click to close
        document.addEventListener('click', () => {
            window.parent?.postMessage('close', '*');
        });        
        // Touch support
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            window.parent?.postMessage('close', '*');
        });
        
        // Initialize dimensions and start animation
        updateDimensions();
        window.addEventListener('resize', updateDimensions);
        render();
    </script>
</body>
</html>
