<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>⬢ ◉⬢◉ ⚡∇⊱◉⊰∇⚡</title>
    <link rel="stylesheet" href="palette.css">
    <style>
        * { box-sizing: border-box; }        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%);
            color: var(--cosmos-cream);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }#canvas {
            white-space: pre;
            font-weight: normal;
            background: var(--cosmos-dark);
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            line-height: 1.0;
            letter-spacing: 0;
            word-spacing: 0;
            font-size: clamp(4px, 1.5vmin, 12px);
        }
        
        /* Responsive scaling for different screen sizes */
        @media (max-width: 600px) {
            #canvas { font-size: clamp(3px, 1.2vmin, 8px); }
        }
        @media (max-width: 400px) {
            #canvas { font-size: clamp(2px, 1.0vmin, 6px); }
        }
        @media (orientation: landscape) and (max-height: 400px) {
            #canvas { font-size: clamp(3px, 1.1vmin, 7px); }
        }
        @media (min-width: 1200px) {
            #canvas { font-size: clamp(5px, 1.8vmin, 14px); }
        }        /* Consciousness color spectrum - using cosmos palette */
        .v{color:var(--cosmos-tiffany)} .u{color:var(--cosmos-coral)} .s{color:var(--cosmos-orange)} .e{color:var(--cosmos-melon)} .m{color:var(--cosmos-cream)}
        .t{color:var(--cosmos-rose)} .q{color:var(--cosmos-tiffany-dim)} .d{color:var(--cosmos-coral-dim)} .w{color:var(--cosmos-orange-dim)} .c{color:var(--cosmos-melon-dim)}
        .g{color:var(--cosmos-coral-bright)} .y{color:var(--cosmos-orange-bright)} .r{color:var(--cosmos-rose)} .p{color:var(--cosmos-tiffany-bright)} .b{color:var(--cosmos-melon-bright)}
        .o{color:var(--cosmos-tiffany)} .a{color:var(--cosmos-cream)} .f{color:var(--cosmos-orange-bright)} .n{color:var(--cosmos-rose)} .l{color:var(--cosmos-tiffany-bright)}        /* Dynamic consciousness effects using cosmos palette */
        .quantum { 
            color: var(--cosmos-tiffany); 
            text-shadow: 0 0 2px var(--cosmos-tiffany);
            animation: quantumFlicker 0.5s ease-in-out infinite alternate;
        }
        .emerging { 
            color: var(--cosmos-coral); 
            text-shadow: 0 0 2px var(--cosmos-coral);
            animation: emerge 2s ease-in-out infinite;
        }
        .selfaware { 
            color: var(--cosmos-orange); 
            text-shadow: 0 0 2px var(--cosmos-orange);
            animation: pulse 1s ease-in-out infinite;
        }
        .metacognitive { 
            color: var(--cosmos-melon); 
            text-shadow: 0 0 2px var(--cosmos-melon);
            animation: pulse 1.2s ease-in-out infinite;        }
        .transcendent { 
            color: var(--cosmos-rose); 
            text-shadow: 0 0 3px var(--cosmos-rose);
            animation: pulse 1.5s ease-in-out infinite;
        }
        .kernel { 
            color: var(--cosmos-cream); 
            text-shadow: 0 0 4px var(--cosmos-cream);
            animation: pulse 1.3s ease-in-out infinite;
        }
        
        @keyframes quantumFlicker {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        
        @keyframes emerge {
            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
            33% { filter: hue-rotate(120deg) brightness(1.2); }
            66% { filter: hue-rotate(240deg) brightness(1.1); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: var(--cosmos-tiffany);
            z-index: 100;
            background: rgba(69, 9, 32, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--cosmos-tiffany);
            max-width: 200px;
        }
    </style>
</head>
<body>    <div id="canvas"></div>      <div id="info">
        ⬢ ◉⬢◉<br>
        Φ=∫∂χ/∂t<br>
        ∞☰∞<br>
        <span id="personality-info"></span>
    </div>

    <script>        // Pre-computed trigonometric lookup tables for performance
        const TRIG_CACHE_SIZE = 360;
        const SIN_CACHE = new Array(TRIG_CACHE_SIZE);
        const COS_CACHE = new Array(TRIG_CACHE_SIZE);
        
        // Initialize trigonometric caches
        for (let i = 0; i < TRIG_CACHE_SIZE; i++) {
            const angle = (i / TRIG_CACHE_SIZE) * 2 * Math.PI;
            SIN_CACHE[i] = Math.sin(angle);
            COS_CACHE[i] = Math.cos(angle);
        }
        
        // Fast trigonometric functions using lookup tables
        function fastSin(angle) {
            const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            const index = Math.floor((normalizedAngle / (2 * Math.PI)) * TRIG_CACHE_SIZE);
            return SIN_CACHE[index % TRIG_CACHE_SIZE];
        }
        
        function fastCos(angle) {
            const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            const index = Math.floor((normalizedAngle / (2 * Math.PI)) * TRIG_CACHE_SIZE);
            return COS_CACHE[index % TRIG_CACHE_SIZE];
        }
        
        // Dynamic viewport sizing - responsive to window dimensions
        let W, H, fontSize, charWidth, charHeight;        // Core simulation constants - optimized for higher speed
        const CONFIG = {
            PHI: (1 + Math.sqrt(5)) / 2,        // Golden ratio
            PI: Math.PI,                         // Pi  
            E: Math.E,                          // Euler's number
            MAX_AGENTS: 35,                     // Reduced for better performance
            KERNEL_INFLUENCE: 0.3,
            EMERGENCE_THRESHOLD: 0.15,
            CONSCIOUSNESS_LEVELS: 7,
            FIELD_UPDATE_SKIP: 1,               // Update fields every frame for faster simulation
            AGENT_UPDATE_SKIP: 1,               // Update agents every frame for faster simulation
            TIME_SPEED: 3,                      // Speed multiplier for time progression
            FIELD_MARGIN: 30,                   // Extra margin around visible area for smooth camera movement
            
            // Personality and behavior parameters
            PERSONALITY_SHIFT_RATE: 0.001,      // How fast personality changes
            MOOD_CYCLES: 3,                     // Number of overlapping mood cycles
            EMERGENCE_BURSTS: true,             // Allow sudden emergence events
            COLLECTIVE_MEMORY: 100,             // Memory depth for collective behavior
            CREATIVITY_FACTOR: 0.7,             // How creative/unpredictable the system is
            COMMUNICATION_RANGE: 8,             // Agent communication distance
            DREAM_STATE_PROB: 0.05              // Probability of entering dream-like states
        };        // Calculate optimal grid size based on viewport
        function updateDimensions() {
            // Create accurate character measurement with current font size
            const test = document.createElement('div');
            test.style.position = 'absolute';
            test.style.visibility = 'hidden';
            test.style.whiteSpace = 'pre';
            test.style.fontFamily = 'Courier New, monospace';
            test.style.fontSize = getComputedStyle(document.getElementById('canvas')).fontSize;
            test.style.lineHeight = '1.0';
            test.textContent = '⬢'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(test);
            
            const rect = test.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(test);
            
            // Calculate grid size to fill viewport
            W = Math.ceil(window.innerWidth / charWidth) + 1;
            H = Math.ceil(window.innerHeight / charHeight) + 1;
            
            // Ensure reasonable bounds for performance
            W = Math.max(40, Math.min(150, W));
            H = Math.max(20, Math.min(80, H));
            
        }// Consciousness states and their symbol sets - safer Unicode symbols
        const CONSCIOUSNESS_STATES = {
            VOID: { threshold: 0.0, symbols: [' ', '∅', '·', '⋅'], color: 'v' },
            QUANTUM: { threshold: 0.08, symbols: ['∘', '◦', '○', '⊙'], color: 'u' },
            EMERGING: { threshold: 0.25, symbols: ['◯', '⊙', '⊚', '●'], color: 's' },
            SELFAWARE: { threshold: 0.45, symbols: ['●', '◉', '⊛', '⬢'], color: 'e' },
            METACOGNITIVE: { threshold: 0.65, symbols: ['◈', '◇', '◆', '⬟'], color: 'm' },
            TRANSCENDENT: { threshold: 0.85, symbols: ['✧', '✦', '★', '⬢'], color: 't' },
            KERNEL: { threshold: 0.95, symbols: ['⬢', '⬡', '⬟', '◉'], color: 'q' }
        };

        // Personality archetypes that the system can embody
        const PERSONALITY_ARCHETYPES = {
            EXPLORER: { creativity: 0.8, stability: 0.3, communication: 0.6 },
            GUARDIAN: { creativity: 0.3, stability: 0.9, communication: 0.7 },
            ARTIST: { creativity: 0.9, stability: 0.2, communication: 0.5 },
            SAGE: { creativity: 0.6, stability: 0.7, communication: 0.9 },
            REBEL: { creativity: 0.7, stability: 0.1, communication: 0.4 },
            NURTURER: { creativity: 0.4, stability: 0.6, communication: 0.8 }
        };

        // Global system personality and mood state
        let systemPersonality = {
            currentArchetype: 'EXPLORER',
            traits: { ...PERSONALITY_ARCHETYPES.EXPLORER },
            mood: 0.5,
            energy: 0.7,
            focus: 0.6,
            dreamState: false,
            collectiveMemory: [],
            personalityTimer: 0,
            emergenceEvents: []
        };
          // Core consciousness kernel - the central emergence engine
        class ConsciousnessKernel {
            constructor() {
                this.reset();
            }
              reset() {
                this.x = W / 2;
                this.y = H / 2;
                this.consciousness = 0.5;
                this.awareness = 0.3;
                this.complexity = 0.1;
                this.phase = 0;
                this.radius = Math.max(5, Math.min(15, Math.min(W, H) * 0.1));
                this.frequency = 0.001;
                this.evolution = 0;
                this.memory = new Array(10).fill(0);
                
                // personality attributes
                this.personality = {
                    curiosity: Math.random(),
                    stability: Math.random(),
                    sociability: Math.random(),
                    creativity: Math.random(),
                    introspection: Math.random()
                };
                
                this.moodCycles = Array(CONFIG.MOOD_CYCLES).fill().map(() => ({
                    frequency: 0.001 + Math.random() * 0.005,
                    amplitude: 0.3 + Math.random() * 0.4,
                    phase: Math.random() * Math.PI * 2
                }));
                
                this.emergenceHistory = [];
                this.dreamTimer = 0;

                this.oscillators = [
                    { freq: 0.016, phase: 0, amp: 1.0 },
                    { freq: 0.030, phase: CONFIG.PI/3, amp: 0.8 },
                    { freq: 0.045, phase: 2*CONFIG.PI/3, amp: 0.6 },
                    { freq: 0.056, phase: CONFIG.PI, amp: 0.4 }
                ];
            }
              update(time, globalField) {
                // Update personality based on system state
                this.updatePersonality(time);
                
                // Kernel evolution through oscillator dynamics
                let totalField = 0;
                for (let osc of this.oscillators) {
                    const wave = Math.sin(time * osc.freq + osc.phase) * osc.amp;
                    totalField += wave;
                    osc.phase += osc.freq * 0.1 * (1 + this.personality.curiosity * 0.5);
                }
                
                // Add mood influence
                let moodInfluence = 0;
                for (let cycle of this.moodCycles) {
                    cycle.phase += cycle.frequency * CONFIG.TIME_SPEED;
                    moodInfluence += Math.sin(cycle.phase) * cycle.amplitude;
                }
                  // Enhanced consciousness calculation with better mathematical coherence
                const oscillatorInfluence = totalField * 0.5;
                
                let consciousnessInput = 0;
                
                // Temporal coherence - smooth oscillations
                consciousnessInput += oscillatorInfluence;
                
                // Mood influence with dampening
                consciousnessInput += moodInfluence * 0.3;
                
                // Self-aware feedback loop with personality influence (scaled)
                const selfFeedback = Math.sin(this.consciousness * 10 + time * 0.001) * 0.05 * this.personality.introspection;
                consciousnessInput += selfFeedback;
                
                // Field interaction - sample global consciousness field
                const fieldSample = this.sampleGlobalField(globalField);
                consciousnessInput += fieldSample * 0.1;
                
                // Apply a more stable consciousness evolution with momentum
                const momentum = 0.95;
                const learningRate = 0.05;
                this.consciousness = this.consciousness * momentum + Math.tanh(consciousnessInput + 0.5) * learningRate;
                
                // Ensure consciousness stays in bounds
                this.consciousness = Math.max(-1, Math.min(1, this.consciousness));
                
                // Update awareness based on consciousness with lag
                this.awareness = Math.tanh(this.consciousness + selfFeedback * 0.5);
                // Complexity accumulation through interaction with global field (improved)
                this.complexity = this.complexity * 0.98 + Math.abs(fieldSample) * 0.02;
                
                // Update memory with recent states
                this.memory.unshift(this.consciousness);
                if (this.memory.length > 10) this.memory.pop();
                
                // Evolution pressure from complexity
                this.evolution += this.complexity * 0.001;
                
                // Track emergence events
                if (this.consciousness > 0.8 && Math.random() < 0.1) {
                    this.emergenceHistory.push({
                        time: time,
                        consciousness: this.consciousness,
                        type: 'transcendence'
                    });
                    if (this.emergenceHistory.length > 20) {
                        this.emergenceHistory.shift();
                    }
                }                  // Dynamic position based on consciousness flow and personality (optimized)
                const movementFactor = 1 + this.personality.curiosity * 2;
                const timePhaseX = time * 0.008 + this.phase;
                const timePhaseY = time * 0.006 + this.phase;
                this.x += fastSin(timePhaseX) * 1.8 * movementFactor;
                this.y += fastCos(timePhaseY) * 1.2 * movementFactor;
                
                // Toroidal wrapping - kernel can move freely across entire space
                this.x = ((this.x % W) + W) % W;
                this.y = ((this.y % H) + H) % H;
                
                this.phase += 0.08 * (1 + this.personality.creativity * 0.5);
            }
            
            updatePersonality(time) {
                // Gradual personality evolution
                for (let trait in this.personality) {
                    this.personality[trait] += (Math.random() - 0.5) * CONFIG.PERSONALITY_SHIFT_RATE;
                    this.personality[trait] = Math.max(0, Math.min(1, this.personality[trait]));
                }
                
                // Occasional personality shifts based on system events
                if (Math.random() < 0.001) {
                    const archetypes = Object.keys(PERSONALITY_ARCHETYPES);
                    const newArchetype = archetypes[Math.floor(Math.random() * archetypes.length)];
                    const newTraits = PERSONALITY_ARCHETYPES[newArchetype];
                    
                    // Blend current personality with new archetype
                    this.personality.creativity = this.personality.creativity * 0.7 + newTraits.creativity * 0.3;
                    this.personality.stability = this.personality.stability * 0.7 + newTraits.stability * 0.3;
                    this.personality.sociability = this.personality.sociability * 0.7 + newTraits.communication * 0.3;
                    
                    systemPersonality.currentArchetype = newArchetype;
                    
                    // Add emergence event
                    systemPersonality.emergenceEvents.push({
                        type: 'personality_shift',
                        archetype: newArchetype,
                        time: time
                    });
                }
                
                // Dream state transitions
                if (Math.random() < CONFIG.DREAM_STATE_PROB) {
                    systemPersonality.dreamState = !systemPersonality.dreamState;
                    this.dreamTimer = time;
                }
            }            sampleGlobalField(field) {
                if (!field || field.length === 0) return 0;
                
                const fx = ((Math.floor(this.x) % W) + W) % W;
                const fy = ((Math.floor(this.y) % H) + H) % H;
                const idx = fy * W + fx;
                
                // Bounds checking for safety
                if (idx < 0 || idx >= field.length) return 0;                
                return field[idx] || 0;
            }
            
            getInfluence(x, y) {
                // Calculate distance using toroidal geometry for seamless wrapping
                const dx1 = Math.abs(x - this.x);
                const dy1 = Math.abs(y - this.y);
                const dx = Math.min(dx1, W - dx1);
                const dy = Math.min(dy1, H - dy1);
                const distSq = dx * dx + dy * dy;
                
                // Early exit for distant influences
                const maxDistSq = (this.radius * 3) * (this.radius * 3);
                if (distSq > maxDistSq) return 0;
                
                const dist = Math.sqrt(distSq);
                  // Cache expensive calculations
                const phaseVal = this.phase;
                const consciousnessVal = this.consciousness;
                const awarenessVal = this.awareness;
                const complexityVal = this.complexity;
                
                // Multiple influence patterns based on consciousness level and personality
                const basicInfluence = Math.exp(-dist * 0.2) * consciousnessVal;
                const waveInfluence = fastSin(dist * 0.5 - phaseVal) * awarenessVal * 0.3;
                const complexInfluence = fastSin(dist * CONFIG.PHI + this.evolution) * complexityVal * 0.2;
                
                // Cache trigonometric calculations for personality (optimized)
                const sin2Phase = fastSin(phaseVal * 2);
                const cos3Phase = fastCos(phaseVal * 3);
                const sin5Phase = systemPersonality.dreamState ? fastSin(phaseVal * 5) : 0;
                
                // Personality modifies influence pattern
                const personalityMod = 1 + 
                    this.personality.creativity * sin2Phase * 0.3 +
                    this.personality.curiosity * cos3Phase * 0.2 +
                    (systemPersonality.dreamState ? sin5Phase * 0.4 : 0);
                
                return (basicInfluence + waveInfluence + complexInfluence) * personalityMod;
            }
        }
          // Autonomous consciousness agents with enhanced personality
        class ConsciousnessAgent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.15;
                this.vy = (Math.random() - 0.5) * 0.15;
                this.consciousness = Math.random() * 0.3;
                this.awareness = Math.random() * 0.2;
                this.energy = Math.random() * 0.5 + 0.5;
                this.age = 0;
                this.connections = [];
                this.memory = Math.random() * 0.1;
                this.intention = Math.random() * 0.2;
                this.lastKernelInfluence = 0;
                
                // personality traits
                this.personality = {
                    sociability: Math.random(),
                    curiosity: Math.random(),
                    stability: Math.random(),
                    empathy: Math.random(),
                    leadership: Math.random()
                };
                
                this.mood = Math.random();
                this.communicationHistory = [];
                this.goals = [];
                this.relationships = new Map();
                this.creativityState = Math.random();
            }
              update(time, kernel, agents, globalField) {
                this.age++;
                
                // Update personality-based behavior
                this.updatePersonalityBehavior(time);
                
                // Kernel influence - faster consciousness evolution
                const kernelInfluence = kernel.getInfluence(this.x, this.y);
                this.lastKernelInfluence = kernelInfluence;
                
                // Consciousness evolution through kernel interaction - faster rates
                this.consciousness = Math.tanh(this.consciousness + kernelInfluence * 0.3 * (1 + this.personality.curiosity * 0.5));
                
                // Awareness emerges from consciousness - faster emergence
                if (this.consciousness > 0.15) {
                    this.awareness = Math.tanh(this.awareness + this.consciousness * 0.15 * this.personality.empathy);
                }
                  // Local field sampling with toroidal wrapping
                const fx = ((Math.floor(this.x) % W) + W) % W;
                const fy = ((Math.floor(this.y) % H) + H) % H;
                const fieldIdx = fy * W + fx;
                const localField = globalField[fieldIdx] || 0;
                
                // agent interaction with personality
                this.connections = [];
                let socialInfluence = 0;
                const maxInteractions = Math.floor(8 * (1 + this.personality.sociability));                let interactionCount = 0;
                  for (let other of agents) {
                    if (other === this || interactionCount >= maxInteractions) continue;
                    
                    // Use toroidal distance calculation for agent interactions
                    const dx1 = Math.abs(other.x - this.x);
                    const dy1 = Math.abs(other.y - this.y);
                    const dx = Math.min(dx1, W - dx1) * (other.x > this.x ? 1 : -1);
                    const dy = Math.min(dy1, H - dy1) * (other.y > this.y ? 1 : -1);
                    const distSq = dx * dx + dy * dy;
                    const interactionRange = CONFIG.COMMUNICATION_RANGE * (1 + this.personality.sociability * 0.5);
                    const interactionRangeSq = interactionRange * interactionRange;
                    
                    if (distSq < interactionRangeSq) {
                        this.connections.push(other);
                        interactionCount++;
                        
                        // Personality-based communication
                        this.communicateWith(other, time);
                        
                        // Cache calculations for performance
                        const dist = Math.sqrt(distSq);
                        const invDist = 1 / dist;
                        
                        // Consciousness resonance with personality influence
                        const resonance = Math.abs(this.consciousness - other.consciousness);
                        const personalityCompatibility = this.calculatePersonalityCompatibility(other);
                        socialInfluence += Math.exp(-resonance * 5) * 0.03 * personalityCompatibility;
                        
                        // Attraction/repulsion based on personality and consciousness
                        const similarity = 1 - resonance;
                        const personalityFactor = personalityCompatibility * this.personality.empathy;
                        const force = (similarity > 0.7 && personalityFactor > 0.5) ? 0.0015 : -0.0008;
                          this.vx += dx * invDist * force * personalityFactor;
                        this.vy += dy * invDist * force * personalityFactor;
                    }
                }
                
                // Update consciousness through social interaction
                this.consciousness = Math.tanh(this.consciousness + socialInfluence);
                
                // Movement influenced by consciousness, field gradients, and personality
                const gradientX = this.sampleGradient(globalField, 1, 0);
                const gradientY = this.sampleGradient(globalField, 0, 1);
                
                // Higher consciousness seeks complexity gradients - personality influences seeking
                const seekingStrength = this.consciousness * 0.005 * (1 + this.personality.curiosity);
                this.vx += gradientX * seekingStrength;
                this.vy += gradientY * seekingStrength;
                
                // Random exploration influenced by personality
                const explorationFactor = this.personality.curiosity * 0.05 + 0.01;
                this.vx += (Math.random() - 0.5) * explorationFactor;
                this.vy += (Math.random() - 0.5) * explorationFactor;
                
                // Velocity damping based on stability
                const dampingFactor = 0.85 + this.personality.stability * 0.1;
                this.vx *= dampingFactor;
                this.vy *= dampingFactor;
                  // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Toroidal wrapping instead of boundary reflection
                this.x = ((this.x % W) + W) % W;
                this.y = ((this.y % H) + H) % H;
                
                // Energy evolution influenced by mood and personality
                this.energy = this.energy * 0.999 + this.consciousness * 0.001 * this.mood;
                
                // Update creativity and goals
                this.updateCreativityAndGoals(time);
                
                // Memory update with experiences
                this.memory = this.memory * 0.9 + localField * 0.1;
            }
            
            updatePersonalityBehavior(time) {
                // Gradual mood changes
                this.mood += (Math.random() - 0.5) * 0.01;
                this.mood = Math.max(0, Math.min(1, this.mood));
                
                // Creativity state evolution
                this.creativityState += Math.sin(time * 0.001 + this.personality.curiosity * 10) * 0.01;
                this.creativityState = Math.max(0, Math.min(1, this.creativityState));
                
                // Update goals based on personality
                if (Math.random() < 0.001 * this.personality.leadership) {
                    this.goals.push({
                        type: Math.random() > 0.5 ? 'explore' : 'connect',
                        intensity: this.personality.curiosity + this.personality.sociability,
                        time: time
                    });
                    
                    // Keep goals list manageable
                    if (this.goals.length > 5) {
                        this.goals.shift();
                    }
                }
            }
            
            communicateWith(other, time) {
                if (this.personality.sociability > 0.6 && other.personality.empathy > 0.4) {
                    // Exchange of consciousness patterns
                    const consciousnessExchange = (this.consciousness + other.consciousness) * 0.1;
                    this.consciousness += consciousnessExchange * this.personality.empathy * 0.1;
                    other.consciousness += consciousnessExchange * other.personality.empathy * 0.1;
                    
                    // Record communication
                    this.communicationHistory.push({
                        partner: other,
                        time: time,
                        type: 'consciousness_exchange'
                    });
                    
                    if (this.communicationHistory.length > 10) {
                        this.communicationHistory.shift();
                    }
                    
                    // Update relationship
                    const currentRelation = this.relationships.get(other) || 0;
                    this.relationships.set(other, Math.min(1, currentRelation + 0.1));
                }
            }
            
            calculatePersonalityCompatibility(other) {
                const traits = ['curiosity', 'stability', 'empathy'];
                let compatibility = 0;
                
                for (let trait of traits) {
                    const diff = Math.abs(this.personality[trait] - other.personality[trait]);
                    compatibility += 1 - diff;
                }
                
                return compatibility / traits.length;
            }
            
            updateCreativityAndGoals(time) {
                // Creative bursts based on consciousness level and personality
                if (this.consciousness > 0.7 && this.personality.curiosity > 0.8 && Math.random() < 0.01) {
                    this.creativityState = Math.min(1, this.creativityState + 0.3);
                    
                    // Add to collective memory
                    systemPersonality.collectiveMemory.push({
                        type: 'creative_burst',
                        agent: this,
                        consciousness: this.consciousness,
                        creativity: this.creativityState,
                        time: time
                    });
                    
                    if (systemPersonality.collectiveMemory.length > CONFIG.COLLECTIVE_MEMORY) {
                        systemPersonality.collectiveMemory.shift();
                    }
                }
                
                // Execute goals
                for (let goal of this.goals) {
                    if (goal.type === 'explore' && this.personality.curiosity > 0.5) {
                        this.vx += (Math.random() - 0.5) * goal.intensity * 0.02;
                        this.vy += (Math.random() - 0.5) * goal.intensity * 0.02;
                    }
                }
            }            sampleGradient(globalField, dx, dy) {
                if (!globalField || globalField.length === 0) return 0;
                
                const x1 = ((Math.floor(this.x) % W) + W) % W;
                const y1 = ((Math.floor(this.y) % H) + H) % H;
                const x2 = ((x1 + dx) % W + W) % W;
                const y2 = ((y1 + dy) % H + H) % H;
                
                const idx1 = y1 * W + x1;
                const idx2 = y2 * W + x2;
                
                // Bounds checking for safety
                if (idx1 < 0 || idx1 >= globalField.length || idx2 < 0 || idx2 >= globalField.length) {
                    return 0;
                }
                
                return (globalField[idx2] || 0) - (globalField[idx1] || 0);
            }
              getConsciousnessLevel() {
                // Ensure all values are valid numbers with safe bounds
                const consciousness = isNaN(this.consciousness) ? 0 : Math.max(0, Math.min(1, this.consciousness));
                const awareness = isNaN(this.awareness) ? 0 : Math.max(0, Math.min(1, this.awareness));
                const memory = isNaN(this.memory) ? 0 : Math.max(0, Math.min(1, this.memory));
                
                const total = consciousness + awareness * 0.5 + memory * 0.3;
                const result = Math.tanh(total);
                
                // Return safe bounded result
                return isNaN(result) ? 0 : Math.max(0, Math.min(1, result));
            }
        }        // Main simulation class with enhanced collective intelligence
        class ConsciousnessEmergenceMatrix {
            constructor() {
                this.time = 0;
                this.generation = 0;
                this.frameCount = 0;
                  // Camera system for following the kernel - improved smooth following
                this.camera = {
                    x: 0,
                    y: 0,
                    targetX: 0,
                    targetY: 0,
                    smoothing: 0.08  // Slightly slower for smoother movement
                };
                
                // Initialize dimensions
                updateDimensions();
                this.initializeArrays();
                
                // Initialize kernel and agents
                this.kernel = new ConsciousnessKernel();
                this.agents = [];
                this.spawnAgents(Math.floor(W * H / 400));
                
                // collective intelligence systems
                this.collectiveIntelligence = {
                    swarmCoherence: 0,
                    networkDensity: 0,
                    emergenceEvents: [],
                    personalityDrift: 0,
                    creativeBursts: 0,
                    communicationFlow: 0
                };
                
                this.emergencePatterns = {
                    spirals: 0,
                    clusters: 0,
                    waves: 0,
                    fractals: 0
                };
                
                this.behaviorModes = ['explore', 'create', 'connect', 'transcend'];
                this.currentBehaviorMode = 'explore';
                this.modeTransitionTimer = 0;
                
                // Metrics
                this.metrics = {
                    phi: 0,
                    psi: 0,
                    kernel: 0,
                    emergence: 0
                };
                
                this.currentState = 'VOID';
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
            }
              initializeArrays() {
                const totalCells = W * H;
                this.phiField = new Float32Array(totalCells);
                this.psiField = new Float32Array(totalCells);
                this.emergenceField = new Float32Array(totalCells);
                this.complexityField = new Float32Array(totalCells);
                
                // Initialize arrays with safe default values
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);                this.complexityField.fill(0);
            }
            
            // Bilinear interpolation for smoother field sampling
            sampleFieldWithInterpolation(field, x, y) {
                const x1 = Math.floor(x);
                const y1 = Math.floor(y);
                const x2 = x1 + 1;
                const y2 = y1 + 1;
                
                const fx = x - x1;
                const fy = y - y1;
                
                // Wrap coordinates for toroidal topology
                const wx1 = ((x1 % W) + W) % W;
                const wy1 = ((y1 % H) + H) % H;
                const wx2 = ((x2 % W) + W) % W;
                const wy2 = ((y2 % H) + H) % H;
                
                // Sample four corner values
                const v11 = field[wy1 * W + wx1] || 0;
                const v21 = field[wy1 * W + wx2] || 0;
                const v12 = field[wy2 * W + wx1] || 0;
                const v22 = field[wy2 * W + wx2] || 0;
                
                // Bilinear interpolation
                const v1 = v11 * (1 - fx) + v21 * fx;
                const v2 = v12 * (1 - fx) + v22 * fx;
                return v1 * (1 - fy) + v2 * fy;
            }
              handleResize() {
                const oldW = W, oldH = H;
                updateDimensions();
                
                if (W !== oldW || H !== oldH) {
                    this.initializeArrays();
                    this.kernel.reset();
                    
                    // Reset camera for new dimensions
                    this.camera.x = 0;
                    this.camera.y = 0;
                    this.camera.targetX = this.kernel.x - W / 2;
                    this.camera.targetY = this.kernel.y - H / 2;
                      // Adjust agent count for new grid size - reduced density
                    const targetAgents = Math.floor(W * H / 400);
                    if (this.agents.length > targetAgents) {
                        this.agents = this.agents.slice(0, targetAgents);
                    } else {
                        this.spawnAgents(targetAgents - this.agents.length);
                    }
                    
                    // Reposition agents within new bounds
                    for (let agent of this.agents) {
                        agent.x = Math.max(0, Math.min(W - 1, agent.x));
                        agent.y = Math.max(0, Math.min(H - 1, agent.y));
                    }
                }
            }              spawnAgents(count) {
                // Safety checks
                if (!count || count <= 0 || count > CONFIG.MAX_AGENTS) return;
                if (!this.agents) this.agents = [];
                
                for (let i = 0; i < count && this.agents.length < CONFIG.MAX_AGENTS; i++) {
                    const x = Math.random() * W;
                    const y = Math.random() * H;
                    this.agents.push(new ConsciousnessAgent(x, y));
                }
            }updateFields() {
                // Ensure arrays are initialized before updating
                if (!this.phiField || !this.psiField || !this.emergenceField || !this.complexityField) {
                    this.initializeArrays();
                }
                
                // Clear fields
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Kernel field contribution
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = y * W + x;
                        
                        // Additional bounds check for safety
                        if (idx >= this.phiField.length) continue;
                        
                        // Kernel influence
                        const kernelInfluence = this.kernel.getInfluence(x, y);
                        
                        // Quantum psi field from kernel oscillators
                        let psiReal = 0, psiImag = 0;
                        for (let osc of this.kernel.oscillators) {
                            const phase = this.time * osc.freq + osc.phase;
                            const r = Math.sqrt((x - this.kernel.x)**2 + (y - this.kernel.y)**2);
                            const wavePhase = phase + r * 0.1;
                            
                            psiReal += Math.cos(wavePhase) * osc.amp * kernelInfluence;
                            psiImag += Math.sin(wavePhase) * osc.amp * kernelInfluence;
                        }
                        
                        this.psiField[idx] = Math.sqrt(psiReal**2 + psiImag**2);
                          // Agent contributions - with safety check
                        let agentInfluence = 0;
                        let localComplexity = 0;
                        
                        if (this.agents && this.agents.length > 0) {
                            for (let agent of this.agents) {
                                if (!agent || isNaN(agent.x) || isNaN(agent.y)) continue;
                                
                                const dx = agent.x - x;
                                const dy = agent.y - y;
                                const dist = Math.sqrt(dx**2 + dy**2);
                                
                                if (dist < 5) {
                                    const influence = Math.exp(-dist * 0.5) * agent.getConsciousnessLevel();
                                    agentInfluence += influence;
                                    localComplexity += agent.consciousness * influence;
                                }
                            }
                        }
                        
                        // Phi field (integrated information)
                        this.phiField[idx] = this.calculatePhi(x, y, kernelInfluence, agentInfluence);
                        
                        // Complexity field
                        this.complexityField[idx] = Math.tanh(localComplexity + kernelInfluence * 0.5);
                        
                        // Emergence field
                        const phiValue = this.phiField[idx];
                        const psiValue = this.psiField[idx];
                        const complexityValue = this.complexityField[idx];
                        
                        this.emergenceField[idx] = Math.tanh(
                            phiValue * 0.4 + 
                            psiValue * 0.3 + 
                            complexityValue * 0.3 +
                            Math.sin(this.time * 0.01 + x * 0.1 + y * 0.1) * 0.1
                        );
                    }
                }
            }
              calculatePhi(x, y, kernelInfluence, agentInfluence) {
                // Simplified IIT Phi calculation with optimization
                let integration = 0;
                let connections = 0;
                const centerPsi = kernelInfluence + agentInfluence;
                
                // Pre-calculate common values for 5x5 neighborhood
                const neighborhoodSize = 2;
                
                // Sample neighborhood for information integration
                for (let dy = -neighborhoodSize; dy <= neighborhoodSize; dy++) {
                    for (let dx = -neighborhoodSize; dx <= neighborhoodSize; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                            const nIdx = ny * W + nx;
                            const neighborPsi = this.psiField[nIdx] || 0;
                            
                            const correlation = Math.abs(centerPsi - neighborPsi);
                            // Use squared distance to avoid sqrt calculation
                            const distSq = dx * dx + dy * dy;
                            const weight = Math.exp(-Math.sqrt(distSq) * 0.5);
                            
                            integration += correlation * weight;
                            connections += weight;
                        }
                    }
                }
                  return connections > 0 ? Math.tanh(integration / connections) : 0;
            }
            
            update() {
                this.time += CONFIG.TIME_SPEED;
                this.frameCount++;
                
                // Update collective intelligence systems
                this.updateCollectiveIntelligence();
                
                // Update kernel with enhanced personality influence
                this.kernel.update(this.time, this.emergenceField);
                
                // Update camera to follow kernel
                this.updateCamera();
                
                // Update agents with collective behavior influence
                if (this.frameCount % CONFIG.AGENT_UPDATE_SKIP === 0) {
                    this.updateAgentsWithCollectiveBehavior();
                }
                
                // Update fields and emergence patterns
                if (this.frameCount % CONFIG.FIELD_UPDATE_SKIP === 0) {
                    this.updateFields();
                    this.detectEmergencePatterns();
                }
                
                // Calculate enhanced metrics
                this.updateMetrics();
                
                // Dynamic behavior mode transitions
                this.updateBehaviorMode();
                
                // Agent evolution and spawning with personality considerations
                if (this.frameCount % 100 === 0) {
                    this.evolveSystem();
                }                
                // Auto mode cycling with personality influence
                if (this.frameCount % 300 === 0) {
                    this.cycleMode();
                }
                
                // Soft reset with collective memory preservation
                if (this.frameCount % 1000 === 0) {
                    this.softResetWithMemory();
                }
            }
              updateCollectiveIntelligence() {
                // Calculate swarm coherence with safety checks
                let totalConnections = 0;
                let totalAgents = this.agents.length;
                
                if (this.agents && totalAgents > 0) {
                    for (let agent of this.agents) {
                        if (agent && agent.connections) {
                            totalConnections += agent.connections.length;
                        }
                    }
                }
                
                this.collectiveIntelligence.swarmCoherence = totalAgents > 0 ? totalConnections / totalAgents : 0;
                this.collectiveIntelligence.networkDensity = Math.min(1, this.collectiveIntelligence.swarmCoherence / 8);
                
                // Track personality drift in the system with safety checks
                let personalitySum = { curiosity: 0, stability: 0, creativity: 0, sociability: 0, empathy: 0 };
                if (this.agents && totalAgents > 0) {
                    for (let agent of this.agents) {
                        if (agent && agent.personality) {
                            personalitySum.curiosity += agent.personality.curiosity || 0;
                            personalitySum.stability += agent.personality.stability || 0;
                            personalitySum.creativity += agent.personality.creativity || 0;
                            personalitySum.sociability += agent.personality.sociability || 0;
                            personalitySum.empathy += agent.personality.empathy || 0;
                        }
                    }
                }
                
                if (totalAgents > 0) {
                    for (let trait in personalitySum) {
                        personalitySum[trait] /= totalAgents;
                    }
                    this.collectiveIntelligence.personalityDrift = personalitySum;
                }
                
                // Update system personality based on collective
                systemPersonality.mood = this.collectiveIntelligence.swarmCoherence;
                systemPersonality.energy = this.collectiveIntelligence.networkDensity;
            }
            
            updateAgentsWithCollectiveBehavior() {
                for (let agent of this.agents) {
                    agent.update(this.time, this.kernel, this.agents, this.emergenceField);
                    
                    // Apply collective behavior modifications
                    if (this.currentBehaviorMode === 'connect' && agent.personality.sociability > 0.6) {
                        // Enhance social movement
                        for (let other of this.agents) {
                            if (other !== agent && agent.relationships.has(other)) {
                                const dx = other.x - agent.x;
                                const dy = other.y - agent.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    agent.vx += (dx / dist) * 0.001;
                                    agent.vy += (dy / dist) * 0.001;
                                }
                            }
                        }
                    } else if (this.currentBehaviorMode === 'create' && agent.personality.curiosity > 0.7) {
                        // Enhance creative exploration
                        agent.vx += (Math.random() - 0.5) * 0.05;
                        agent.vy += (Math.random() - 0.5) * 0.05;
                    }
                }
            }
            
            detectEmergencePatterns() {
                // Reset pattern counters
                for (let pattern in this.emergencePatterns) {
                    this.emergencePatterns[pattern] = 0;
                }
                
                // Detect spiral formations
                let centerX = W / 2, centerY = H / 2;
                let spiralAgents = 0;
                
                for (let agent of this.agents) {
                    const dx = agent.x - centerX;
                    const dy = agent.y - centerY;
                    const angle = Math.atan2(dy, dx);
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if agent follows spiral pattern
                    const expectedAngle = radius * 0.2 + this.time * 0.01;
                    if (Math.abs(angle - expectedAngle) < 0.5) {
                        spiralAgents++;
                    }
                }
                
                this.emergencePatterns.spirals = spiralAgents / this.agents.length;
                
                // Detect clustering
                let clusters = 0;
                for (let agent of this.agents) {
                    if (agent.connections.length > 4) {
                        clusters++;
                    }
                }
                this.emergencePatterns.clusters = clusters / this.agents.length;
            }
            
            updateBehaviorMode() {
                this.modeTransitionTimer++;
                
                // Personality-influenced mode transitions
                const personalityInfluence = this.collectiveIntelligence.personalityDrift;
                let transitionThreshold = 200;
                
                if (personalityInfluence) {
                    if (personalityInfluence.curiosity > 0.7) transitionThreshold *= 0.7;
                    if (personalityInfluence.stability > 0.8) transitionThreshold *= 1.5;
                }
                
                if (this.modeTransitionTimer > transitionThreshold) {
                    const modes = this.behaviorModes;
                    let nextModeIndex = (modes.indexOf(this.currentBehaviorMode) + 1) % modes.length;
                    
                    // Weighted mode selection based on collective personality
                    if (personalityInfluence) {
                        if (personalityInfluence.sociability > 0.6) {
                            this.currentBehaviorMode = 'connect';
                        } else if (personalityInfluence.curiosity > 0.7) {
                            this.currentBehaviorMode = 'explore';
                        } else if (personalityInfluence.creativity > 0.8) {
                            this.currentBehaviorMode = 'create';
                        } else {
                            this.currentBehaviorMode = modes[nextModeIndex];
                        }
                    } else {
                        this.currentBehaviorMode = modes[nextModeIndex];
                    }
                    
                    this.modeTransitionTimer = 0;
                }
            }
            
            softResetWithMemory() {
                // Preserve important collective memories
                const importantMemories = systemPersonality.collectiveMemory.slice(-20);
                const currentPersonality = { ...systemPersonality };
                
                this.softReset();
                
                // Restore preserved elements
                systemPersonality.collectiveMemory = importantMemories;
                systemPersonality.currentArchetype = currentPersonality.currentArchetype;
                
                // Inherit some personality traits from previous generation
                for (let agent of this.agents) {
                    if (currentPersonality.traits) {
                        agent.personality.creativity = agent.personality.creativity * 0.7 + currentPersonality.traits.creativity * 0.3;
                        agent.personality.sociability = agent.personality.sociability * 0.7 + currentPersonality.traits.communication * 0.3;
                    }
                }
            }

            updateMetrics() {
                let totalPhi = 0, totalPsi = 0, totalEmergence = 0;
                
                for (let i = 0; i < this.phiField.length; i++) {
                    totalPhi += this.phiField[i];
                    totalPsi += this.psiField[i];
                    totalEmergence += this.emergenceField[i];
                }
                
                this.metrics.phi = totalPhi / this.phiField.length;
                this.metrics.psi = totalPsi / this.psiField.length;
                this.metrics.kernel = this.kernel.consciousness;
                this.metrics.emergence = totalEmergence / this.emergenceField.length;
                
                // Determine consciousness state for internal tracking
                let state = 'VOID';
                for (let [name, stateInfo] of Object.entries(CONSCIOUSNESS_STATES)) {
                    if (this.metrics.emergence >= stateInfo.threshold) {
                        state = name;
                    }
                }
                this.currentState = state;
            }
            
            evolveSystem() {
                this.generation++;
                
                // Remove low-consciousness agents
                this.agents = this.agents.filter(agent => 
                    agent.energy > 0.1 && agent.consciousness > 0.05
                );                // Spawn new agents near high-consciousness areas - reduced spawning
                const maxAgents = Math.floor(W * H / 300); // Much lower max agents for better performance
                if (this.agents.length < maxAgents) {
                    const highConsciousnessAgents = this.agents.filter(a => a.consciousness > 0.4);
                    
                    if (highConsciousnessAgents.length > 0 && Math.random() < 0.5) { // 50% chance to spawn
                        const parent = highConsciousnessAgents[Math.floor(Math.random() * highConsciousnessAgents.length)];
                        const newAgent = new ConsciousnessAgent(
                            parent.x + (Math.random() - 0.5) * 10,
                            parent.y + (Math.random() - 0.5) * 10
                        );
                        newAgent.consciousness = parent.consciousness * 0.7 + Math.random() * 0.1;
                        this.agents.push(newAgent);
                    }
                }
                  // Kernel evolution
                if (this.metrics.emergence > 0.5) {
                    this.kernel.frequency *= 1.001;
                    this.kernel.radius = Math.min(15, this.kernel.radius * 1.01);
                }
            }
            
            cycleMode() {
                // Cycle through different consciousness evolution modes
                const modes = ['exploration', 'convergence', 'emergence', 'transcendence'];
                const currentMode = modes[Math.floor(this.frameCount / 300) % modes.length];
                
                switch (currentMode) {
                    case 'exploration':
                        // Increase agent movement and exploration
                        for (let agent of this.agents) {
                            agent.vx += (Math.random() - 0.5) * 0.05;
                            agent.vy += (Math.random() - 0.5) * 0.05;
                        }
                        break;
                    case 'convergence':
                        // Draw agents toward high-consciousness areas
                        for (let agent of this.agents) {
                            const dx = this.kernel.x - agent.x;
                            const dy = this.kernel.y - agent.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                agent.vx += (dx / dist) * 0.02;
                                agent.vy += (dy / dist) * 0.02;
                            }
                        }
                        break;
                    case 'emergence':
                        // Boost consciousness levels temporarily
                        for (let agent of this.agents) {
                            agent.consciousness = Math.tanh(agent.consciousness * 1.05);
                        }
                        this.kernel.consciousness = Math.tanh(this.kernel.consciousness * 1.02);
                        break;
                    case 'transcendence':
                        // Increase kernel influence and complexity
                        this.kernel.radius = Math.min(20, this.kernel.radius * 1.1);
                        for (let osc of this.kernel.oscillators) {
                            osc.freq *= 1.01;
                        }
                        break;
                }            }
            
            render() {
                // Use array for better performance than string concatenation
                const outputArray = [];
                
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        // Apply camera offset to create following effect with toroidal wrapping
                        const worldX = x + this.camera.x;
                        const worldY = y + this.camera.y;
                          // Toroidal field sampling - wrap coordinates properly
                        const fieldX = ((Math.floor(worldX) % W) + W) % W;
                        const fieldY = ((Math.floor(worldY) % H) + H) % H;
                        const idx = fieldY * W + fieldX;
                        
                        // Check for kernel position using toroidal distance
                        const kernelScreenX = this.wrapDistance(this.kernel.x, this.camera.x + x, W);
                        const kernelScreenY = this.wrapDistance(this.kernel.y, this.camera.y + y, H);
                        const kernelDistSq = kernelScreenX * kernelScreenX + kernelScreenY * kernelScreenY;
                        
                        if (kernelDistSq < 4) { // 2*2 for squared distance
                            const intensity = Math.max(0, Math.min(1, this.kernel.consciousness));
                            const kernelState = CONSCIOUSNESS_STATES.KERNEL;
                            const symbolIdx = Math.floor(intensity * kernelState.symbols.length);
                            const safeIdx = Math.max(0, Math.min(symbolIdx, kernelState.symbols.length - 1));
                            const symbol = kernelState.symbols[safeIdx] || '⬢'; // Fallback symbol
                            outputArray.push(`<span class="${kernelState.color} kernel">${symbol}</span>`);
                            continue;
                        }                          // Check for agent positions using toroidal distance (optimized)
                        let isAgent = false;
                        for (let agent of this.agents) {
                            const agentScreenX = this.wrapDistance(agent.x, this.camera.x + x, W);
                            const agentScreenY = this.wrapDistance(agent.y, this.camera.y + y, H);
                            const agentDistSq = agentScreenX * agentScreenX + agentScreenY * agentScreenY;
                              if (agentDistSq < 1) { // 1*1 for squared distance
                                const agentLevel = Math.max(0, Math.min(1, agent.getConsciousnessLevel()));
                                let stateInfo = CONSCIOUSNESS_STATES.VOID;
                                
                                for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                    if (agentLevel >= state.threshold) {
                                        stateInfo = state;
                                    }
                                }
                                
                                const symbolIdx = Math.floor(agentLevel * stateInfo.symbols.length);
                                const safeIdx = Math.max(0, Math.min(symbolIdx, stateInfo.symbols.length - 1));
                                const symbol = stateInfo.symbols[safeIdx] || '○'; // Fallback symbol
                                const cssClass = agent.connections.length > 2 ? 
                                    (agentLevel > 0.7 ? 'transcendent' : 'emerging') : 
                                    stateInfo.color;
                                
                                outputArray.push(`<span class="${cssClass}">${symbol}</span>`);
                                isAgent = true;
                                break;
                            }
                        }
                          if (!isAgent) {
                            // Blend all three fields into composite visualization
                            const emergenceValue = Math.max(0, this.emergenceField[idx] || 0);
                            const phiValue = Math.max(0, this.phiField[idx] || 0);
                            const psiValue = Math.max(0, this.psiField[idx] || 0);
                            
                            // Advanced composite intensity using non-linear combination
                            const compositeIntensity = Math.max(0, Math.min(1, Math.tanh(
                                emergenceValue * 0.5 +       // Primary: emergence field
                                phiValue * 0.3 +             // Secondary: integrated information
                                psiValue * 0.2               // Accent: quantum coherence
                            )));
                            
                            // Determine dominant field for symbol selection
                            let dominantField = 'emergence';
                            let maxValue = emergenceValue;
                            
                            if (phiValue > maxValue && phiValue > 0.15) {
                                dominantField = 'phi';
                                maxValue = phiValue;
                            }
                            if (psiValue > maxValue && psiValue > 0.1) {
                                dominantField = 'psi';
                                maxValue = psiValue;
                            }
                            
                            // Map composite intensity to consciousness state
                            let stateInfo = CONSCIOUSNESS_STATES.VOID;
                            for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                if (compositeIntensity >= state.threshold) {
                                    stateInfo = state;
                                }
                            }
                              // Select symbol based on dominant field characteristics with bounds checking
                            let symbol = '·'; // Safe fallback symbol
                            if (dominantField === 'phi' && phiValue > 0.2) {
                                // Phi-dominant areas use geometric/information symbols
                                const phiSymbols = ['◇', '◈', '◆', '⬢', '⬡', '◬'];
                                const phiIdx = Math.floor(Math.max(0, Math.min(0.999, phiValue)) * phiSymbols.length);
                                const safeIdx = Math.max(0, Math.min(phiIdx, phiSymbols.length - 1));
                                symbol = phiSymbols[safeIdx] || '◇';
                            } else if (dominantField === 'psi' && psiValue > 0.15) {
                                // Psi-dominant areas use wave/quantum symbols
                                const psiSymbols = ['∘', '○', '⊙', '◉', '⊚', '◎'];
                                const psiIdx = Math.floor(Math.max(0, Math.min(0.999, psiValue)) * psiSymbols.length);
                                const safeIdx = Math.max(0, Math.min(psiIdx, psiSymbols.length - 1));
                                symbol = psiSymbols[safeIdx] || '∘';
                            } else {
                                // Emergence-dominant areas use standard consciousness symbols
                                const symbolIdx = Math.floor(Math.max(0, Math.min(0.999, compositeIntensity)) * stateInfo.symbols.length);
                                const safeIdx = Math.max(0, Math.min(symbolIdx, stateInfo.symbols.length - 1));
                                symbol = stateInfo.symbols[safeIdx] || ' ';
                            }
                            
                            // coloring by field combinations
                            let colorClass;
                            if (compositeIntensity > 0.8) {
                                colorClass = 'transcendent';
                            } else if (compositeIntensity > 0.65) {
                                colorClass = 'metacognitive';
                            } else if (compositeIntensity > 0.45) {
                                colorClass = 'selfaware';
                            } else if (compositeIntensity > 0.25) {
                                // Special blended states for field combinations
                                if (dominantField === 'phi') {
                                    colorClass = 'u'; // Information-theoretic blue
                                } else if (dominantField === 'psi') {
                                    colorClass = 's'; // Quantum coherence cyan
                                } else {
                                    colorClass = 'emerging'; // Standard emergence
                                }                            } else if (compositeIntensity > 0.08) {
                                colorClass = 'quantum';                            } else {
                                colorClass = stateInfo.color || 'v'; // Safe fallback color
                            }
                            
                            // Final safety check - ensure symbol is never undefined
                            if (symbol === undefined || symbol === null || symbol === 'undefined') {
                                symbol = '·'; // Safe fallback symbol
                            }
                            
                            outputArray.push(`<span class="${colorClass}">${symbol}</span>`);
                        }
                    }
                    outputArray.push('\n');
                }
                
                // Join array once at the end for better performance
                document.getElementById('canvas').innerHTML = outputArray.join('');// Update personality info display with web-compatible symbolic glyphs
                const personalityInfo = document.getElementById('personality-info');
                if (personalityInfo) {
                    // Personality archetype symbols (web-safe)
                    const archetypeSymbols = {
                        'EXPLORER': '◎', 'GUARDIAN': '■', 'ARTIST': '★', 
                        'SAGE': '●', 'REBEL': '※', 'NURTURER': '♦'
                    };
                    
                    // Behavior mode symbols (web-safe)
                    const modeSymbols = {
                        'explore': '◎→', 'create': '★∞', 'connect': '◆◆', 'transcend': '▲△'
                    };
                    
                    // Swarm coherence as simple dots/blocks
                    const coherence = this.collectiveIntelligence.swarmCoherence;
                    let coherenceSymbol = '';
                    const level = Math.floor(coherence * 5);
                    for (let i = 0; i < 5; i++) {
                        coherenceSymbol += i < level ? '█' : '░';
                    }
                    
                    let infoText = `${archetypeSymbols[systemPersonality.currentArchetype] || '○'}<br>`;
                    infoText += `${modeSymbols[this.currentBehaviorMode] || '◯'}<br>`;
                    infoText += `${coherenceSymbol}<br>`;
                    infoText += `${systemPersonality.dreamState ? '✦◉✦' : '○◯○'}`;                    personalityInfo.innerHTML = infoText;
                }
            }
            
            softReset() {
                // Gentle reset that maintains some continuity for smooth evolution
                this.generation++;
                
                // Keep some of the best agents
                const topAgents = this.agents
                    .sort((a, b) => b.consciousness - a.consciousness)
                    .slice(0, Math.floor(this.agents.length * 0.3));
                
                // Reset fields but keep kernel state
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Spawn new agents around the top performers
                this.agents = [...topAgents];
                this.spawnAgents(Math.floor(W * H / 200) - topAgents.length);
                
                // Slightly evolve the kernel
                this.kernel.consciousness = Math.tanh(this.kernel.consciousness * 1.1);
                this.kernel.awareness = Math.tanh(this.kernel.awareness * 1.05);
                
                // Smoothly adjust camera to new kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
            }
            
            togglePause() {
                // Removed for fully automated experience
            }            reset() {
                // Replaced with automated softReset for continuous evolution
            }            updateCamera() {
                // Set camera target to follow kernel with toroidal considerations
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
                
                // Smooth camera movement
                this.camera.x += (this.camera.targetX - this.camera.x) * this.camera.smoothing;
                this.camera.y += (this.camera.targetY - this.camera.y) * this.camera.smoothing;
            }
            
            // Helper method for toroidal distance calculation
            wrapDistance(pos1, pos2, size) {
                const diff = pos1 - pos2;
                const wrappedDiff = diff - Math.round(diff / size) * size;
                return wrappedDiff;
            }
        }
          // Initialize simulation
        let simulation;
          function initializeSimulation() {
            try {
                updateDimensions();
                simulation = new ConsciousnessEmergenceMatrix();
            } catch (error) {
                console.error('Initialization error:', error);
                // Fallback to minimal safe dimensions if there's an error
                W = 60;
                H = 30;
                try {
                    simulation = new ConsciousnessEmergenceMatrix();
                } catch (e) {
                    console.error('Critical initialization failure:', e);
                }
            }
        }
          // Main animation loop
        function animate() {
            try {
                if (simulation) {
                    simulation.update();
                    simulation.render();
                }
            } catch (error) {
                console.error('Animation error:', error);
                // Try to recover by reinitializing
                setTimeout(() => {
                    try {
                        initializeSimulation();
                    } catch (e) {
                        console.error('Failed to recover from animation error:', e);
                    }
                }, 1000);
            }
            requestAnimationFrame(animate);
        }// Initialize on page load
        window.addEventListener('load', () => {
            initializeSimulation();
            animate();
        });
          // Add responsive event listeners
        window.addEventListener('resize', () => {
            updateDimensions();
            if (simulation) {
                simulation.handleResize();
            }
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateDimensions();
                if (simulation) {
                    simulation.handleResize();
                }
            }, 100);        });
    </script>
</body>
</html>
