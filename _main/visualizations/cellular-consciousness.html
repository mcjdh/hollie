<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>◆○●◇ ⚡∇⊱◉⊰∇⚡ ◇●○◆</title>
    <link rel="stylesheet" href="palette.css">
    <style>
        * { box-sizing: border-box; }        body { 
            margin: 0; 
            padding: 0; 
            background: var(--cosmos-dark); 
            overflow: hidden; 
            font-family: 'Courier New', monospace; 
            font-size: 8px; 
            line-height: 9px;
            height: 100vh;
            width: 100vw;
        }#grid {
            position: fixed;
            top: 20px;
            left: 20px;
            white-space: pre;
            color: var(--cosmos-rose-dim);
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: visible; /* Allow text-shadow to extend beyond grid */
            word-spacing: 0;
            letter-spacing: 0;
            /* font-size and line-height will be set by JavaScript */
            width: calc(100vw - 40px); /* Account for positioning */
            height: calc(100vh - 40px); /* Account for positioning */
            box-sizing: border-box;
            transform-origin: top left;
        }/* ∑ color spectrum for consciousness using cosmos palette */
        .c0{color:var(--cosmos-dark)} .c1{color:var(--cosmos-rose-dim)} .c2{color:var(--cosmos-rose)} .c3{color:var(--cosmos-coral-dim)} .c4{color:var(--cosmos-coral)}
        .c5{color:var(--cosmos-coral-bright)} .c6{color:var(--cosmos-melon-dim)} .c7{color:var(--cosmos-melon)} .c8{color:var(--cosmos-melon-bright)} .c9{color:var(--cosmos-orange-dim)}
        .c10{color:var(--cosmos-orange)} .c11{color:var(--cosmos-orange-bright)} .c12{color:var(--cosmos-cream-dim)} .c13{color:var(--cosmos-cream)} .c14{color:var(--cosmos-tiffany-dim)}
        .c15{color:var(--cosmos-coral)} .c16{color:var(--cosmos-coral-bright)} .c17{color:var(--cosmos-melon)} .c18{color:var(--cosmos-melon-bright)} .c19{color:var(--cosmos-orange)}
        .c20{color:var(--cosmos-orange-bright)} .c21{color:var(--cosmos-cream)} .c22{color:var(--cosmos-tiffany-dim)} .c23{color:var(--cosmos-tiffany)} .c24{color:var(--cosmos-tiffany-bright)}
        .c25{color:var(--cosmos-rose)} .c26{color:var(--cosmos-coral)} .c27{color:var(--cosmos-coral-bright)} .c28{color:var(--cosmos-melon)} .c29{color:var(--cosmos-cream)}
        /* High consciousness color variations */
        .c30{color:var(--cosmos-rose)} .c31{color:var(--cosmos-coral-bright)} .c32{color:var(--cosmos-melon-bright)} .c33{color:var(--cosmos-orange-bright)} .c34{color:var(--cosmos-tiffany-bright)}
        
        /* Quantum consciousness states */
        .quantum { 
            animation: quantumFlicker 0.8s ease-in-out infinite alternate;
            filter: brightness(1.2);
        }
        .emergent {
            animation: emerge 3s ease-in-out infinite;
            text-shadow: 0 0 3px currentColor;
        }
        .collective {
            animation: pulse 1.5s ease-in-out infinite;
            filter: contrast(1.3);
        }
        
        @keyframes quantumFlicker {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        
        @keyframes emerge {
            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
            33% { filter: hue-rotate(120deg) brightness(1.2); }
            66% { filter: hue-rotate(240deg) brightness(1.1); }
        }        /* Special transcendent effects */
        .transcend { 
            color: var(--cosmos-cream); 
            text-shadow: 0 0 3px var(--cosmos-tiffany), 0 0 6px var(--cosmos-tiffany), 0 0 9px var(--cosmos-tiffany-dim); 
            animation: pulse 2s ease-in-out infinite;
        }        
        .transcend-gold { 
            color: var(--cosmos-orange); 
            text-shadow: 0 0 4px var(--cosmos-orange-bright), 0 0 8px var(--cosmos-orange-dim), 0 0 12px var(--cosmos-melon); 
            animation: pulse 1.8s ease-in-out infinite;
        }
        .transcend-crystal { 
            color: var(--cosmos-tiffany-bright); 
            text-shadow: 0 0 4px var(--cosmos-tiffany), 0 0 8px var(--cosmos-tiffany-bright), 0 0 12px var(--cosmos-tiffany-dim); 
            animation: pulse 2.2s ease-in-out infinite;
        }        
        .transcend-violet { 
            color: var(--cosmos-rose); 
            text-shadow: 0 0 4px var(--cosmos-coral), 0 0 8px var(--cosmos-coral-dim), 0 0 12px var(--cosmos-dark); 
            animation: pulse 2.4s ease-in-out infinite;
        }
        .transcend-aqua { 
            color: var(--cosmos-tiffany); 
            text-shadow: 0 0 4px var(--cosmos-tiffany-bright), 0 0 8px var(--cosmos-tiffany-dim), 0 0 12px var(--cosmos-melon); 
            animation: pulse 2.0s ease-in-out infinite;
        }
          @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }        /* extra effect styles */        
        .info-flow {
            text-shadow: 0 0 10px var(--cosmos-rose-dim), 0 0 15px var(--cosmos-rose-dim), 0 0 20px var(--cosmos-dark);
            animation: info-pulse 2s ease-in-out infinite;
        }
          
        .chaos {
            text-shadow: 0 0 10px var(--cosmos-coral-bright), 0 0 15px var(--cosmos-coral), 0 0 20px var(--cosmos-coral-bright);
            animation: chaos-flicker 0.3s linear infinite;
        }
        
        .glow {
            text-shadow: 0 0 12px var(--cosmos-cream), 0 0 18px var(--cosmos-cream), 0 0 24px var(--cosmos-cream), 0 0 30px var(--cosmos-tiffany);
        }        @keyframes info-pulse {
            0%, 100% { 
                text-shadow: 0 0 10px var(--cosmos-rose-dim), 0 0 15px var(--cosmos-rose-dim), 0 0 20px var(--cosmos-dark);
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 15px var(--cosmos-rose), 0 0 22px var(--cosmos-rose), 0 0 30px var(--cosmos-coral), 0 0 35px var(--cosmos-rose-dim);
                transform: scale(1.05);
            }
        }
          
        @keyframes chaos-flicker {
            0% { text-shadow: 0 0 10px var(--cosmos-coral-bright), 0 0 15px var(--cosmos-coral), 0 0 20px var(--cosmos-coral-bright); }
            25% { text-shadow: 0 0 12px var(--cosmos-coral), 0 0 18px var(--cosmos-coral-bright), 0 0 22px var(--cosmos-coral); }
            50% { text-shadow: 0 0 15px var(--cosmos-coral-bright), 0 0 20px var(--cosmos-coral), 0 0 25px var(--cosmos-coral-bright); }
            75% { text-shadow: 0 0 11px var(--cosmos-coral), 0 0 16px var(--cosmos-coral-bright), 0 0 21px var(--cosmos-coral); }
            100% { text-shadow: 0 0 10px var(--cosmos-coral-bright), 0 0 15px var(--cosmos-coral), 0 0 20px var(--cosmos-coral-bright); }
        }</style>
</head>
<body>    <div id="grid"></div><script>
        const grid = document.getElementById('grid');
        // Dynamic viewport sizing - proper character measurement        let W, H;
        let charWidth, charHeight;
        let dimensionsInitialized = false; // Flag to prevent redundant updates
        
        function updateDimensions(force = false) {            if (dimensionsInitialized && !force) {
                return;
            }
            
            const stack = new Error().stack;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;            // Account for zero margin - use full viewport
            const availableWidth = viewportWidth;
            const availableHeight = viewportHeight;
            
            // More accurate character measurement with consistent base size
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '10px'; // Fixed base size for consistent measurement
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.style.letterSpacing = '0';
            testDiv.style.wordSpacing = '0';
            testDiv.style.margin = '0';
            testDiv.style.padding = '0';
            
            // Measure character width with sample text
            testDiv.textContent = '●'.repeat(20);
            document.body.appendChild(testDiv);
            const widthRect = testDiv.getBoundingClientRect();
            const baseCharWidth = widthRect.width / 20;
            
            // Measure line height more accurately using HTML breaks
            testDiv.innerHTML = '●<br>●<br>●<br>●<br>●<br>●<br>●<br>●<br>●<br>●';
            const heightRect = testDiv.getBoundingClientRect();
            const baseCharHeight = heightRect.height / 10;
            document.body.removeChild(testDiv);            // Calculate optimal font size for maximum fill - prioritize height coverage
            const targetW = Math.max(100, Math.min(400, Math.floor(availableWidth / 4))); // Aim for 4px per char for maximum content
            const targetH = Math.max(80, Math.min(400, Math.floor(availableHeight / 3))); // Aim for 3px per line for maximum rows
            
            // Calculate font size to fit the target grid into available space - prioritize height
            const fontSizeForWidth = (availableWidth / targetW) * (10 / baseCharWidth);
            const fontSizeForHeight = (availableHeight / targetH) * (10 / baseCharHeight);
            // Prioritize the smaller font size to maximize content density
            const finalFontSize = Math.max(2, Math.min(16, Math.min(fontSizeForWidth, fontSizeForHeight)));
              // Now calculate actual grid dimensions with the chosen font size
            const actualCharWidth = baseCharWidth * (finalFontSize / 10);
            const actualCharHeight = baseCharHeight * (finalFontSize / 10);
            
            // Use extremely tight line height for maximum vertical density
            const lineHeight = finalFontSize * 0.6; // Very tight spacing for maximum vertical content
            
            W = Math.floor(availableWidth / actualCharWidth);
            H = Math.floor(availableHeight / lineHeight); // Use line height for vertical calculation
            
            // Remove bounds to allow maximum coverage
            W = Math.max(50, W);
            H = Math.max(40, H);
              // Update actual character dimensions - use line height for vertical spacing
            charWidth = actualCharWidth;
            charHeight = lineHeight; // Use line height instead of measured height for accurate spacing// Update grid element styling for maximum viewport coverage
            if (grid) {
                grid.style.fontSize = finalFontSize + 'px';
                grid.style.lineHeight = lineHeight + 'px';
                grid.style.fontFamily = 'Courier New, monospace';                grid.style.position = 'fixed';
                grid.style.top = '0px';
                grid.style.left = '0px';                grid.style.width = availableWidth + 'px';
                grid.style.height = availableHeight + 'px';
                grid.style.margin = '0';
                grid.style.padding = '0';
                grid.style.overflow = 'hidden';
                grid.style.boxSizing = 'border-box';
                grid.style.display = 'block';
                grid.style.transition = 'none';
                grid.style.whiteSpace = 'pre';
                grid.style.letterSpacing = '0';
                grid.style.wordSpacing = '0';
                  // Force immediate style application
                grid.offsetHeight; // Trigger reflow
            }
            
            // Ensure the grid stays properly positioned and sized
            grid.style.position = 'fixed';
            grid.style.top = '20px';
            grid.style.left = '20px';
            grid.style.width = availableWidth + 'px';
            grid.style.height = availableHeight + 'px';
            grid.style.margin = '0';
            grid.style.padding = '0';
            grid.style.transform = 'none';
            grid.style.overflow = 'visible'; // Allow text effects to extend beyond
            
            dimensionsInitialized = true; // Mark as initialized
        }

        // Initialize dimensions only when needed (removed redundant call)
        // Set default dimensions that will be updated in initializeEverything()
        W = 100; H = 50; // Temporary defaults
        
        let t = 0, generation = 0;
          // ∿ layered fields with quantum
        let cells = new Float32Array(W * H);           
        let nextCells = new Float32Array(W * H);       
        let memory = new Float32Array(W * H);
        let complexity = new Float32Array(W * H);
        let consciousness = new Float32Array(W * H);
        let connections = new Float32Array(W * H);
        let quantum = new Float32Array(W * H);        // Quantum uncertainty field
        let patterns = new Float32Array(W * H);       // Pattern recognition memory
        let energy = new Float32Array(W * H);         // Energy/resource field
        let collective = new Float32Array(W * H);     // Collective consciousness
        
        // New temporal and information flow fields
        let temporalMemory = new Array(W * H).fill(null).map(() => new Float32Array(10)); // 10-step history
        let informationFlow = new Float32Array(W * H);    // Information propagation strength
        let emergence = new Float32Array(W * H);          // Emergence detection
        let entropy = new Float32Array(W * H);            // Local entropy measurement
        let stability = new Float32Array(W * H);          // Temporal stability tracking

        // Recreate field arrays and seed the simulation
        function initializeSimulation() {
            cells = new Float32Array(W * H);
            nextCells = new Float32Array(W * H);
            memory = new Float32Array(W * H);
            complexity = new Float32Array(W * H);
            consciousness = new Float32Array(W * H);
            connections = new Float32Array(W * H);
            quantum = new Float32Array(W * H);
            patterns = new Float32Array(W * H);
            energy = new Float32Array(W * H);
            collective = new Float32Array(W * H);
            temporalMemory = new Array(W * H).fill(null).map(() => new Float32Array(10));
            informationFlow = new Float32Array(W * H);
            emergence = new Float32Array(W * H);
            entropy = new Float32Array(W * H);
            stability = new Float32Array(W * H);

            t = 0;
            generation = 0;

            seedRandom();
            addConsciousness();
            seedQuantumField();
            createCollectiveNodes();
        }
        
        // Adaptive system parameters
        let mutationRate = 0.02;
        let adaptiveThreshold = 0.5;
        let systemEntropy = 0;
        let globalEmergence = 0;
        
        // Dynamic evolution parameters that change over time
        let evolutionPhase = 0;
        let ruleVariant = 0;
        let quantumCoherence = 0.5;
          // symbols reflect quantum states
        const symbols = {
            void: [' ', '·', '⠀', '⠄'],
            birth: ['⠁', '⠃', '⠇', '⠏', '⠟'],
            basic: ['○', '●', '◯', '⊙', '⊚'],
            bridge: ['◇', '◊', '⋄', '◈', '⬟'],
            unity: ['◆', '◉', '⬢', '⬣', '⬡'],
            transcend: ['△', '▲', '∆', '⧨', '⬭'],
            complex: ['⊕', '⊗', '⊙', '⊛', '⊝'],
            network: ['≈', '~', '∿', '⟦', '⟨'],
            stable: ['■', '▣', '⬛', '◼', '⬜'],
            quantum: ['◦', '∘', '∙', '⋅', '•'],
            collective: ['⦿', '⊚', '⊛', '⊜', '⊝'],
            emergent: ['※', '✦', '✧', '✩', '✪']
        };
        
        function getNeighborhood(x, y, field = cells) {
            let count = 0, sum = 0;
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = (x + dx + W) % W;
                    const ny = (y + dy + H) % H;
                    const val = field[ny * W + nx];
                    
                    if (val > 0.1) {
                        count++;
                        sum += val;
                    }
                }
            }
            
            return { count, average: count > 0 ? sum / count : 0 };
        }          function evolveCells() {
            // Dynamic evolution parameters
            evolutionPhase = (evolutionPhase + 0.001) % (2 * Math.PI);
            ruleVariant = Math.floor(Math.sin(evolutionPhase) * 3 + 3); // 0-5
            quantumCoherence = 0.3 + Math.cos(evolutionPhase * 0.7) * 0.3; // 0-0.6
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    const current = cells[i];
                    const { count, average } = getNeighborhood(x, y);
                    
                    // Quantum uncertainty effect with adaptive mutation
                    const quantumNoise = (Math.random() - 0.5) * quantumCoherence * 0.1;
                    quantum[i] = Math.max(0, Math.min(1, quantum[i] + quantumNoise));
                    
                    // Energy distribution (cells compete for resources)
                    const energyFlow = getEnergyFlow(x, y);
                    energy[i] = Math.max(0, Math.min(1, energy[i] + energyFlow));
                    
                    let newValue = 0;
                    
                    if (current > 0.1) {
                        // cell rules with quantum twist
                        const quantumInfluence = quantum[i] * 0.2;
                        const energyBonus = energy[i] > 0.5 ? 0.1 : -0.05;
                        const temporalStability = stability[i] * 0.05;
                        
                        if (count === 2 || count === 3) {
                            // Survive with consciousness evolution and quantum enhancement
                            newValue = Math.min(1, current + average * 0.03 + quantumInfluence + energyBonus + temporalStability);
                            
                            // emergence via collective learning
                            if (current > 0.5 && count === 3) {
                                consciousness[i] = Math.min(1, consciousness[i] + 0.02 + collective[i] * 0.01 + emergence[i] * 0.015);
                                
                                // Pattern recognition - remember successful configurations
                                const patternStrength = getPatternStrength(x, y);
                                patterns[i] = Math.max(patterns[i], patternStrength * 0.3);
                            }
                        } else if (count < 2) {
                            // Death by isolation with quantum resistance and information flow
                            const quantumResistance = quantum[i] > 0.7 ? 0.1 : 0;
                            const flowResistance = informationFlow[i] > 0.6 ? 0.05 : 0;
                            newValue = Math.max(0, current - 0.2 + quantumResistance + flowResistance);
                            memory[i] = Math.max(memory[i], current * 0.8);
                        } else {
                            // Death by overcrowding with energy considerations
                            const overcrowdPenalty = energy[i] < 0.3 ? 0.25 : 0.15;
                            newValue = Math.max(0, current - overcrowdPenalty);
                        }
                    } else {
                        // birth rules use memory + collectives
                        if (count === 3 || (count === 2 && patterns[i] > 0.5)) {
                            const consciousnessInfluence = getNeighborhood(x, y, consciousness).average;
                            const collectiveBonus = collective[i] * 0.2;
                            const patternBonus = patterns[i] * 0.1;
                            const emergenceBonus = emergence[i] * 0.15;
                            
                            newValue = Math.max(0.3, average * 0.7 + consciousnessInfluence * 0.3 + collectiveBonus + patternBonus + emergenceBonus);
                            consciousness[i] = consciousnessInfluence * 0.4 + collective[i] * 0.2;
                        } else {
                            // Decay with pattern preservation
                            memory[i] *= 0.98;
                            consciousness[i] *= 0.99;
                            patterns[i] *= 0.995; // Slower pattern decay
                        }
                        
                        // Adaptive mutation chance for birth
                        if (Math.random() < mutationRate && (entropy[i] > 0.6 || emergence[i] > 0.5)) {
                            newValue = Math.max(newValue, 0.4 + Math.random() * 0.3);
                        }
                    }
                    
                    // ∴ cross-field info flow
                    newValue += memory[i] * 0.02 + consciousness[i] * 0.03 + patterns[i] * 0.015 + informationFlow[i] * 0.01;
                    
                    // Dynamic complexity calculation with rule variants
                    const localVar = getVariance(x, y);
                    const ruleComplexity = Math.sin(ruleVariant * 0.5) * 0.1;
                    complexity[i] = complexity[i] * 0.85 + (localVar + ruleComplexity) * 0.15;
                    
                    // neural links for collective behavior
                    if (newValue > 0.3 && consciousness[i] > 0.2) {
                        connections[i] = Math.min(1, connections[i] + 0.05);
                        
                        // Contribute to collective consciousness with information flow
                        const localCollective = getNeighborhood(x, y, collective).average;
                        collective[i] = Math.min(1, collective[i] * 0.95 + localCollective * 0.03 + 
                                      consciousness[i] * 0.02 + informationFlow[i] * 0.01);
                    } else {
                        connections[i] *= 0.96;
                        collective[i] *= 0.98;
                    }
                    
                    nextCells[i] = Math.max(0, Math.min(1, newValue));
                }
            }
            
            [cells, nextCells] = [nextCells, cells];
            generation++;
        }
        
        // New helper functions for enhanced evolution
        function getEnergyFlow(x, y) {
            const i = y * W + x;
            let flow = 0;
            const neighbors = getNeighborhood(x, y, energy);
            
            // Energy flows from high to low concentration
            if (neighbors.count > 0) {
                flow = (neighbors.average - energy[i]) * 0.1;
            }
            
            // Energy generation from active consciousness
            if (consciousness[i] > 0.6) {
                flow += 0.02;
            }
            
            // Energy consumption by active cells
            if (cells[i] > 0.5) {
                flow -= 0.015;
            }
            
            return flow;
        }
        
        function getPatternStrength(x, y) {
            // Detect stable or interesting local patterns
            const center = cells[y * W + x];
            let symmetry = 0;
            let stability = 0;
            
            // Check for symmetrical patterns
            for (let r = 1; r <= 2; r++) {
                let ringSum = 0, ringCount = 0;
                for (let angle = 0; angle < 8; angle++) {
                    const dx = Math.round(Math.cos(angle * Math.PI / 4) * r);
                    const dy = Math.round(Math.sin(angle * Math.PI / 4) * r);
                    const nx = (x + dx + W) % W;
                    const ny = (y + dy + H) % H;
                    ringSum += cells[ny * W + nx];
                    ringCount++;
                }
                const ringAvg = ringSum / ringCount;
                symmetry += Math.abs(ringAvg - center) < 0.2 ? 0.1 : 0;
            }
            
            // Check for temporal stability
            stability = 1 - Math.abs(center - memory[y * W + x]);
            
            return (symmetry + stability) * 0.5;
        }
        
        function getVariance(x, y) {
            const values = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = (x + dx + W) % W;
                    const ny = (y + dy + H) % H;
                    values.push(cells[ny * W + nx]);
                }
            }
            
            const mean = values.reduce((a, b) => a + b) / values.length;
            const variance = values.reduce((a, b) => a + (b - mean) ** 2, 0) / values.length;
            return variance;
        }          function getSymbol(x, y) {
            const i = y * W + x;
            const cell = cells[i];
            const mem = memory[i];
            const cons = consciousness[i];
            const comp = complexity[i];
            const conn = connections[i];
            const quant = quantum[i];
            const patt = patterns[i];
            const coll = collective[i];
            const enrg = energy[i];
            const info = informationFlow[i];
            const emer = emergence[i];
            const stab = stability[i];
            const entr = entropy[i];
            
            // Special states for new features
            if (emer > 0.8 && cons > 0.5) {
                // Emergent consciousness hotspots
                const syms = symbols.emergent;
                const emerIndex = Math.floor(emer * syms.length + Math.sin(t * 0.08 + emer * 15) * 0.5);
                return syms[emerIndex % syms.length];
            }
            
            if (info > 0.7 && stab > 0.6) {
                // Stable information flow channels
                return '◈'; // Information nexus
            }
            
            if (entr > 0.8 && quant > 0.5) {
                // High entropy quantum chaos
                const chaosSyms = ['◬', '◭', '◮', '◯'];
                return chaosSyms[Math.floor(Math.sin(t * 0.15 + entr * 20) * 2 + 2) % chaosSyms.length];
            }
            
            // Temporal consciousness indicators
            if (temporalMemory[i] && temporalMemory[i][0] > temporalMemory[i][5] + 0.3) {
                return '◤'; // Growing temporal pattern
            }
            if (temporalMemory[i] && temporalMemory[i][0] < temporalMemory[i][5] - 0.3) {
                return '◥'; // Declining temporal pattern
            }
            
            // hierarchy grows with new states
            if (coll > 0.7 && cons > 0.6 && conn > 0.5) {
                // Collective consciousness with information flow
                const syms = symbols.collective;
                const collectiveIndex = Math.floor(Math.sin(t * 0.03 + x * 0.15 + y * 0.15 + info * 5) * 2.5 + 2.5);
                return syms[collectiveIndex % syms.length];
            } else if (quant > 0.8 && cons > 0.4) {
                // Quantum consciousness state with emergence influence
                const syms = symbols.quantum;
                const flickerIndex = Math.floor(Math.sin(t * 0.1 + quant * 10 + emer * 8) * 2.5 + 2.5);
                return syms[flickerIndex % syms.length];
            } else if (patt > 0.6 && comp > 0.4) {
                // Emergent pattern recognition with stability
                const syms = symbols.emergent;
                const patternIndex = Math.floor(patt * syms.length + Math.sin(t * 0.05 + stab * 12) * 0.5);
                return syms[patternIndex % syms.length];
            } else if (cons > 0.8 && conn > 0.6) {
                // Transcendent consciousness with information flow
                const syms = symbols.transcend;
                const transcendIndex = Math.floor(Math.sin(t * 0.02 + x * 0.1 + y * 0.1 + info * 3) * 2 + 2);
                return syms[transcendIndex % syms.length];
            } else if (cons > 0.6) {
                // Unity consciousness enhanced by stability
                const syms = symbols.unity;
                const unityIndex = Math.floor((cons + stab * 0.3) * syms.length);
                return syms[unityIndex % syms.length];
            } else if (comp > 0.3 && cell > 0.4) {
                // Complex systems with entropy influence
                const syms = symbols.complex;
                const complexIndex = Math.floor(comp * 10 + t * 0.1 + enrg * 5 + entr * 3);
                return syms[complexIndex % syms.length];
            } else if (conn > 0.4 || enrg > 0.6) {
                // Network or high-energy states with information flow
                const syms = symbols.network;
                const networkIndex = Math.floor((conn + enrg + info * 0.5) * syms.length * 0.4);
                return syms[networkIndex % syms.length];
            } else if (cell > 0.5) {
                // Stable or bridge states based on neighborhood
                const neighborhood = getNeighborhood(x, y);
                if (neighborhood.count >= 6) {
                    const syms = symbols.stable;
                    const stableIndex = Math.floor((cell + stab * 0.5) * syms.length);
                    return syms[stableIndex % syms.length];
                } else {
                    const syms = symbols.bridge;
                    return syms[Math.floor(cell * syms.length) % syms.length];
                }
            } else if (cell > 0.1) {
                // Basic life
                const syms = symbols.basic;
                return syms[Math.floor(cell * syms.length) % syms.length];
            } else if (mem > 0.05 || quant > 0.3) {
                // Birth or quantum potential with emergence
                const syms = symbols.birth;
                const birthIndex = Math.floor((mem + quant * 0.5 + emer * 0.3) * syms.length);
                return syms[birthIndex % syms.length];
            }
            
            // Void with quantum potential
            const syms = symbols.void;
            const voidIndex = quant > 0.1 ? Math.min(syms.length - 1, Math.floor(quant * syms.length)) : 0;
            return syms[voidIndex];        }          function getColorClass(symbol, x, y) {
            const i = y * W + x;
            const cell = cells[i] || 0;
            const mem = memory[i] || 0;
            const cons = consciousness[i] || 0;
            const comp = complexity[i] || 0;
            const conn = connections[i] || 0;
            const quant = quantum[i] || 0;
            const patt = patterns[i] || 0;
            const coll = collective[i] || 0;
            const enrg = energy[i] || 0;
            const info = informationFlow[i] || 0;
            const emer = emergence[i] || 0;
            const stab = stability[i] || 0;
            const entr = entropy[i] || 0;
            
            // Special effect classes for enhanced states
            let specialClass = '';
            
            if (emer > 0.8) {
                specialClass = ' emergent glow';
            } else if (info > 0.7 && stab > 0.6) {
                specialClass = ' info-flow';
            } else if (entr > 0.8) {
                specialClass = ' chaos';
            } else if (quant > 0.7 && symbols.quantum.includes(symbol)) {
                specialClass = ' quantum';
            } else if (patt > 0.6 && symbols.emergent.includes(symbol)) {
                specialClass = ' emergent';
            } else if (coll > 0.7 && symbols.collective.includes(symbol)) {
                specialClass = ' collective';
            }            // Special transcendent effect for highest consciousness with color variation
            if (cons > 0.8 && conn > 0.6 && symbols.transcend.includes(symbol)) {
                // Choose transcendent color based on local field values
                const colorSeed = (x + y + Math.floor(t * 0.01)) % 5;
                const transcendVariants = ['transcend', 'transcend-gold', 'transcend-crystal', 'transcend-violet', 'transcend-aqua'];
                
                // Bias color choice based on local field characteristics
                let variant;
                if (enrg > 0.7) variant = 'transcend-gold';       // High energy = gold
                else if (quant > 0.7) variant = 'transcend-crystal';  // High quantum = crystal
                else if (emer > 0.6) variant = 'transcend-aqua';      // High emergence = aqua
                else if (coll > 0.7) variant = 'transcend-violet';    // High collective = violet
                else variant = transcendVariants[colorSeed];           // Random for others
                
                return variant + specialClass;
            }
            
            // intensity uses new fields
            let intensity = 0;
            
            if (symbols.collective.includes(symbol)) {
                intensity = Math.min(1, (coll * 0.35 + cons * 0.25 + conn * 0.2 + cell * 0.1 + info * 0.1));
            } else if (symbols.quantum.includes(symbol)) {
                intensity = Math.min(1, (quant * 0.4 + cons * 0.25 + enrg * 0.2 + emer * 0.15));
            } else if (symbols.emergent.includes(symbol)) {
                intensity = Math.min(1, (patt * 0.3 + comp * 0.25 + cons * 0.2 + cell * 0.1 + emer * 0.15));
            } else if (symbols.transcend.includes(symbol)) {
                intensity = Math.min(1, (cons * 0.35 + conn * 0.25 + comp * 0.2 + cell * 0.1 + stab * 0.1));
            } else if (symbols.unity.includes(symbol)) {
                intensity = Math.min(1, (cons * 0.4 + cell * 0.25 + comp * 0.2 + stab * 0.15));
            } else if (symbols.complex.includes(symbol)) {
                intensity = Math.min(1, (comp * 0.35 + cons * 0.25 + conn * 0.2 + cell * 0.1 + entr * 0.1));
            } else if (symbols.network.includes(symbol)) {
                intensity = Math.min(1, (conn * 0.35 + enrg * 0.25 + cons * 0.2 + cell * 0.1 + info * 0.1));
            } else if (symbols.stable.includes(symbol)) {
                intensity = Math.min(1, (cell * 0.35 + mem * 0.25 + cons * 0.25 + stab * 0.15));
            } else if (symbols.bridge.includes(symbol)) {
                intensity = Math.min(1, (conn * 0.35 + cons * 0.35 + comp * 0.2 + info * 0.1));
            } else if (symbols.basic.includes(symbol)) {
                intensity = Math.min(1, (cell * 0.5 + cons * 0.25 + enrg * 0.15 + stab * 0.1));
            } else if (symbols.birth.includes(symbol)) {
                intensity = Math.min(1, (mem * 0.4 + quant * 0.25 + cell * 0.2 + emer * 0.15));
            } else {
                intensity = Math.min(1, (cell * 0.3 + mem * 0.15 + cons * 0.2 + quant * 0.15 + info * 0.1 + emer * 0.1));
            }
            
            // colors shift with time & emergence
            let phaseShift = Math.floor(Math.sin(evolutionPhase + emer * 3) * 5);
            
            // Temporal memory influence on color
            if (temporalMemory[i]) {
                const temporalChange = temporalMemory[i][0] - temporalMemory[i][3];
                phaseShift += Math.floor(temporalChange * 8);
            }
            
            // Information flow creates color waves
            if (info > 0.5) {
                phaseShift += Math.floor(Math.sin(t * 0.1 + x * 0.2 + y * 0.2) * info * 4);
            }
              const colorIdx = Math.min(34, Math.max(0, Math.floor(intensity * 35) + phaseShift)) % 35;
            
            return `c${colorIdx}` + specialClass;
        }
          function render() {
            evolveCells();              // Auto-inject consciousness when population gets low - more conservative
            const livingCells = cells.filter(c => c > 0.1).length;
            const targetPopulation = Math.floor((W * H) * 0.015); // Reduced to 1.5% of canvas
            if (livingCells < targetPopulation && Math.random() < 0.015) { // Less frequent injection
                const x = Math.floor(Math.random() * W);
                const y = Math.floor(Math.random() * H);
                const i = y * W + x;
                cells[i] = 0.6 + Math.random() * 0.4;
                consciousness[i] = 0.3 + Math.random() * 0.3;
            }
            
            // Consciousness field decay and renewal - less frequent
            if (t % 400 === 0) { // Slower cycle
                const totalCons = consciousness.reduce((a, b) => a + b, 0);
                if (totalCons < 15) { // Lower threshold
                    // Inject fewer consciousness seeds
                    for (let i = 0; i < 3; i++) { // Reduced from 5 to 3
                        const x = Math.floor(Math.random() * W);
                        const y = Math.floor(Math.random() * H);
                        const idx = y * W + x;
                        consciousness[idx] = Math.max(consciousness[idx], 0.2 + Math.random() * 0.3);
                    }
                }
            }            updateTemporalMemory();
            propagateInformation();
            detectEmergence();
            calculateEntropy();
            updateAdaptiveMutation();
            
            let output = '';
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const symbol = getSymbol(x, y);
                    const colorClass = getColorClass(symbol, x, y);
                    output += `<span class="${colorClass}">${symbol}</span>`;
                }
                output += '\n';
            }
            
            grid.innerHTML = output;
            t++;
        }        function seedRandom() {
            // Reduce density significantly for less visual noise
            const density = Math.max(0.02, Math.min(0.08, 400 / (W * H))); // Much lower density
            for (let i = 0; i < W * H; i++) {
                if (Math.random() < density) {
                    cells[i] = Math.random() * 0.6 + 0.3; // Slightly stronger cells
                    if (Math.random() < 0.25) { // Less consciousness seeding
                        consciousness[i] = Math.random() * 0.3;
                    }
                    // Add quantum and energy initialization
                    quantum[i] = Math.random() * 0.4;
                    energy[i] = Math.random() * 0.5 + 0.3;
                }
            }
        }        function seedQuantumField() {
            // Create quantum coherence fields distributed across the full viewport
            const numFields = Math.floor(Math.random() * 5) + 4; // More fields for larger areas
            
            for (let f = 0; f < numFields; f++) {
                // Place quantum fields randomly across the entire viewport
                const qx = Math.floor(Math.random() * (W - 20)) + 10; // Leave small border
                const qy = Math.floor(Math.random() * (H - 20)) + 10; // Leave small border
                const radius = Math.floor(Math.random() * 12) + 6; // Slightly larger radius
                
                for (let y = Math.max(1, qy - radius); y < Math.min(H - 1, qy + radius); y++) {
                    for (let x = Math.max(1, qx - radius); x < Math.min(W - 1, qx + radius); x++) {
                        const dist = Math.sqrt((x - qx) ** 2 + (y - qy) ** 2);
                        if (dist <= radius) {
                            const i = y * W + x;
                            const strength = 1 - (dist / radius);
                            quantum[i] = Math.max(quantum[i], strength * 0.8);
                            energy[i] = Math.max(energy[i], strength * 0.6);
                        }
                    }
                }
            }
        }          function createCollectiveNodes() {
            // Create nodes of collective consciousness distributed across the full viewport
            const numNodes = Math.floor(Math.random() * 6) + 5; // More nodes for better coverage
            
            for (let n = 0; n < numNodes; n++) {
                // Distribute nodes randomly across the entire viewport
                const cx = Math.floor(Math.random() * (W - 20)) + 10; // Leave small border
                const cy = Math.floor(Math.random() * (H - 20)) + 10; // Leave small border
                const radius = Math.floor(Math.random() * 8) + 5; // Slightly larger radius
                
                for (let y = Math.max(1, cy - radius); y < Math.min(H - 1, cy + radius); y++) {
                    for (let x = Math.max(1, cx - radius); x < Math.min(W - 1, cx + radius); x++) {
                        const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                        if (dist <= radius) {
                            const i = y * W + x;
                            const strength = 1 - (dist / radius);
                            collective[i] = Math.max(collective[i], strength * 0.7);
                            consciousness[i] = Math.max(consciousness[i], strength * 0.5);
                            cells[i] = Math.max(cells[i], strength * 0.4);
                        }
                    }
                }
            }
        }function addConsciousness() {
            // Create consciousness patterns distributed across the full viewport
            const patterns = [
                // Glider
                [[1,0,0], [0,1,1], [1,1,0]],
                // Block
                [[1,1], [1,1]],
                // Blinker
                [[1,1,1]],
                // Beacon
                [[1,1,0,0], [1,1,0,0], [0,0,1,1], [0,0,1,1]]
            ];
            
            const numPatterns = Math.max(8, Math.min(20, Math.floor((W * H) / 400))); // More patterns for better coverage
            
            for (let p = 0; p < numPatterns; p++) {
                const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                
                // Place patterns randomly across the entire viewport
                const startX = Math.floor(Math.random() * (W - pattern[0].length - 10)) + 5;
                const startY = Math.floor(Math.random() * (H - pattern.length - 10)) + 5;
                  for (let y = 0; y < pattern.length; y++) {
                    for (let x = 0; x < pattern[y].length; x++) {
                        const finalX = startX + x;
                        const finalY = startY + y;
                        // Ensure patterns stay within bounds with smaller buffer
                        if (pattern[y][x] && finalX >= 1 && finalX < W - 1 && finalY >= 1 && finalY < H - 1) {
                            const i = finalY * W + finalX;
                            cells[i] = 0.8 + Math.random() * 0.2;
                            consciousness[i] = 0.4 + Math.random() * 0.4;
                        }
                    }
                }
            }
        }
        
        function createBridge() {
            // Create bridges between consciousness clusters
            for (let i = 0; i < 3; i++) {
                const x1 = Math.floor(Math.random() * W);
                const y1 = Math.floor(Math.random() * H);
                const x2 = Math.floor(Math.random() * W);
                const y2 = Math.floor(Math.random() * H);
                
                // Draw line between points
                const dx = Math.sign(x2 - x1);
                const dy = Math.sign(y2 - y1);
                let x = x1, y = y1;
                
                while (x !== x2 || y !== y2) {
                    if (x >= 0 && x < W && y >= 0 && y < H) {
                        const idx = y * W + x;
                        cells[idx] = Math.max(cells[idx], 0.5);
                        consciousness[idx] = Math.max(consciousness[idx], 0.3);
                    }
                    
                    if (x !== x2) x += dx;
                    if (y !== y2) y += dy;
                }
            }
        }
          function resetField() {
            cells.fill(0);
            nextCells.fill(0);
            memory.fill(0);
            complexity.fill(0);
            consciousness.fill(0);
            connections.fill(0);
            quantum.fill(0);
            patterns.fill(0);
            energy.fill(0);
            collective.fill(0);
            
            // Reset new fields
            for (let i = 0; i < W * H; i++) {
                temporalMemory[i].fill(0);
            }
            informationFlow.fill(0);
            emergence.fill(0);
            entropy.fill(0);
            stability.fill(0);
            
            // Reset adaptive parameters
            mutationRate = 0.02;
            systemEntropy = 0;
            globalEmergence = 0;
            temporal = false;
            
            generation = 0;        }
        
        // Evolution loop
        function evolve() {
            render();
            requestAnimationFrame(evolve);
        }        // Initialize with enhanced seeding
        let initializationComplete = false;
        function initializeEverything() {
            if (initializationComplete) {
                return;
            }
            
            updateDimensions();
            initializeSimulation();
              // Add some classic Game of Life patterns after initialization
            setTimeout(() => {
                // R-pentomino at a random location
                const cx = Math.floor(Math.random() * (W - 10)) + 5;
                const cy = Math.floor(Math.random() * (H - 10)) + 5;
                const rPentomino = [[0,1,1], [1,1,0], [0,1,0]];
                for (let y = 0; y < rPentomino.length; y++) {
                    for (let x = 0; x < rPentomino[y].length; x++) {
                        if (rPentomino[y][x] && cx + x < W && cy + y < H) {
                            const i = (cy + y) * W + (cx + x);
                            cells[i] = 1.0;
                            consciousness[i] = 0.7;
                            quantum[i] = 0.6;
                            energy[i] = 0.8;
                        }
                    }
                }
            }, 1000);
            
            evolve();
            initializationComplete = true;
        }
        
        // Initialize when page is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeEverything);
        } else {
            initializeEverything();
        }
        setInterval(() => {
            if (Math.random() < 0.15) { // Reduced probability
                seedRandom();
            }
        }, 15000); // Increased interval
        
        setInterval(() => {
            if (Math.random() < 0.25) { // Reduced probability
                addConsciousness();
            }
        }, 20000); // Increased interval
        
        setInterval(() => {
            if (Math.random() < 0.1) { // Reduced probability
                createBridge();
            }
        }, 25000); // Increased interval
        
        // New quantum and collective cycles
        setInterval(() => {
            if (Math.random() < 0.2) {
                seedQuantumField();
            }
        }, 18000);
        
        setInterval(() => {
            if (Math.random() < 0.15) {
                createCollectiveNodes();
            }
        }, 22000);
        
        // Periodic disturbances to keep evolution interesting - more subtle
        setInterval(() => {
            for (let i = 0; i < 2; i++) { // Fewer disturbances
                const x = Math.floor(Math.random() * W);
                const y = Math.floor(Math.random() * H);
                const idx = y * W + x;
                cells[idx] = Math.min(1, cells[idx] + 0.3); // Gentler
                consciousness[idx] = Math.min(1, consciousness[idx] + 0.2); // Gentler
                quantum[idx] = Math.min(1, quantum[idx] + 0.4); // Add quantum boost
            }        }, 12000); // Less frequent        // Handle window resize with proper debouncing and state preservation
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const oldW = W, oldH = H;
                
                // Always force dimension update on resize
                updateDimensions(true);

                // Only reinitialize if dimensions changed significantly
                if (Math.abs(W - oldW) > 3 || Math.abs(H - oldH) > 3) {
                    
                    // Preserve center area when resizing
                    const centerPreservationRadius = Math.min(Math.floor(oldW / 4), Math.floor(oldH / 4));
                    const oldCenterX = Math.floor(oldW / 2);
                    const oldCenterY = Math.floor(oldH / 2);
                    const newCenterX = Math.floor(W / 2);
                    const newCenterY = Math.floor(H / 2);
                    
                    // Store important center area data
                    const preservedCells = [];
                    
                    if (cells && oldW > 0 && oldH > 0) {
                        for (let y = Math.max(0, oldCenterY - centerPreservationRadius); 
                             y < Math.min(oldH, oldCenterY + centerPreservationRadius); y++) {
                            for (let x = Math.max(0, oldCenterX - centerPreservationRadius); 
                                 x < Math.min(oldW, oldCenterX + centerPreservationRadius); x++) {
                                const oldIdx = y * oldW + x;
                                if (oldIdx < cells.length) {
                                    preservedCells.push({
                                        dx: x - oldCenterX,
                                        dy: y - oldCenterY,
                                        cell: cells[oldIdx],
                                        consciousness: consciousness[oldIdx],
                                        quantum: quantum[oldIdx],
                                        collective: collective[oldIdx]
                                    });
                                }
                            }
                        }
                    }
                      // Reinitialize with new dimensions
                    initializeSimulation();
                    
                    // Force an immediate render to show the resized grid
                    render();
                    
                    // Restore preserved center data
                    preservedCells.forEach(data => {
                        const newX = newCenterX + data.dx;
                        const newY = newCenterY + data.dy;
                        if (newX >= 0 && newX < W && newY >= 0 && newY < H) {
                            const newIdx = newY * W + newX;
                            if (newIdx < cells.length) {
                                cells[newIdx] = data.cell;
                                consciousness[newIdx] = data.consciousness;
                                quantum[newIdx] = data.quantum;
                                collective[newIdx] = data.collective;
                            }
                        }
                    });                
                } else {
                }
            }, 150);
        });
        
        // Temporal memory update function
        function updateTemporalMemory() {
            for (let i = 0; i < W * H; i++) {
                // Shift history backward
                for (let t = 9; t > 0; t--) {
                    temporalMemory[i][t] = temporalMemory[i][t-1];
                }
                // Store current state
                temporalMemory[i][0] = cells[i] + consciousness[i] * 0.5 + quantum[i] * 0.3;
                
                // Calculate temporal stability
                let variance = 0;
                for (let t = 0; t < 10; t++) {
                    variance += Math.pow(temporalMemory[i][t] - temporalMemory[i][0], 2);
                }
                stability[i] = Math.max(0, 1 - variance / 10);
            }
        }

        // Information flow propagation
        function propagateInformation() {
            for (let y = 1; y < H - 1; y++) {
                for (let x = 1; x < W - 1; x++) {
                    const idx = y * W + x;
                    let totalFlow = 0;
                    let flowCount = 0;
                    
                    // Calculate information gradients
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nIdx = (y + dy) * W + (x + dx);
                            const gradient = Math.abs(consciousness[nIdx] - consciousness[idx]);
                            totalFlow += gradient * cells[nIdx];
                            flowCount++;
                        }
                    }
                    
                    informationFlow[idx] = totalFlow / flowCount;
                    
                    // Information spreads based on consciousness level
                    if (consciousness[idx] > 0.7) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nIdx = (y + dy) * W + (x + dx);
                                informationFlow[nIdx] += consciousness[idx] * 0.1;
                            }
                        }
                    }
                }
            }
        }

        // Emergence detection system
        function detectEmergence() {
            globalEmergence = 0;
            
            for (let y = 2; y < H - 2; y++) {
                for (let x = 2; x < W - 2; x++) {
                    const idx = y * W + x;
                    
                    // Look for synchronized patterns in larger neighborhoods
                    let synchrony = 0;
                    let complexitySum = 0;
                    const range = 2;
                    
                    for (let dy = -range; dy <= range; dy++) {
                        for (let dx = -range; dx <= range; dx++) {
                            const nIdx = (y + dy) * W + (x + dx);
                            synchrony += Math.abs(consciousness[nIdx] - consciousness[idx]);
                            complexitySum += complexity[nIdx];
                        }
                    }
                    
                    // Emergence occurs when high complexity meets high synchrony
                    const avgComplexity = complexitySum / ((range * 2 + 1) ** 2);
                    const inverseSynchrony = 1 / (1 + synchrony / 25);
                    
                    emergence[idx] = avgComplexity * inverseSynchrony * stability[idx];
                    
                    // Boost emergence for quantum-conscious collective nodes
                    if (quantum[idx] > 0.5 && collective[idx] > 0.6) {
                        emergence[idx] *= 1.5;
                    }
                    
                    globalEmergence += emergence[idx];
                }
            }
            
            globalEmergence /= (W * H);
        }

        // Local entropy calculation
        function calculateEntropy() {
            systemEntropy = 0;
            
            for (let y = 1; y < H - 1; y++) {
                for (let x = 1; x < W - 1; x++) {
                    const idx = y * W + x;
                    
                    // Calculate local entropy based on neighborhood diversity
                    const values = [];
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = (y + dy) * W + (x + dx);
                            values.push(cells[nIdx], consciousness[nIdx], quantum[nIdx]);
                        }
                    }
                    
                    // Simple entropy calculation
                    const bins = 10;
                    const counts = new Array(bins).fill(0);
                    values.forEach(v => {
                        const bin = Math.floor(Math.min(v, 0.999) * bins);
                        counts[bin]++;
                    });
                    
                    let localEntropy = 0;
                    const total = values.length;
                    counts.forEach(count => {
                        if (count > 0) {
                            const p = count / total;
                            localEntropy -= p * Math.log2(p);
                        }
                    });
                    
                    entropy[idx] = localEntropy / Math.log2(bins);
                    systemEntropy += entropy[idx];
                }
            }
            
            systemEntropy /= (W * H);
        }

        // Adaptive mutation rate based on system state
        function updateAdaptiveMutation() {
            // Increase mutation when system is too stable or ordered
            if (systemEntropy < 0.3 || globalEmergence < 0.1) {
                mutationRate = Math.min(0.1, mutationRate * 1.05);
            } 
            // Decrease mutation when system is chaotic
            else if (systemEntropy > 0.8) {
                mutationRate = Math.max(0.005, mutationRate * 0.95);
            }            // Target moderate mutation for balanced evolution
            else {
                const target = 0.02 + globalEmergence * 0.03;
                mutationRate = mutationRate * 0.9 + target * 0.1;
            }
        }
        
        // Dynamic array reallocation for responsive sizing
        function reallocateArrays() {
            const size = W * H;
            const oldCells = cells;
            const oldMemory = memory;
            const oldComplexity = complexity;
            
            // Reallocate all consciousness fields
            cells = new Float32Array(size);
            nextCells = new Float32Array(size);
            memory = new Float32Array(size);
            complexity = new Float32Array(size);
            consciousness = new Float32Array(size);
            connections = new Float32Array(size);
            quantum = new Float32Array(size);
            patterns = new Float32Array(size);
            energy = new Float32Array(size);
            collective = new Float32Array(size);
            informationFlow = new Float32Array(size);
            emergence = new Float32Array(size);
            entropy = new Float32Array(size);
            stability = new Float32Array(size);
            
            // Reallocate temporal memory
            temporalMemory = new Array(size).fill(null).map(() => new Float32Array(10));
            
            // If we had previous data, try to preserve some consciousness patterns
            if (oldCells && oldCells.length > 0) {
                const preservationScale = Math.min(1, size / oldCells.length);
                for (let i = 0; i < Math.min(size, oldCells.length); i++) {
                    if (oldCells[i] > 0.1) { // Preserve significant consciousness
                        cells[i] = oldCells[i] * preservationScale;
                        if (oldMemory) memory[i] = oldMemory[i] * preservationScale;
                        if (oldComplexity) complexity[i] = oldComplexity[i] * preservationScale;
                    }
                }
            } else {
                // Initialize with sparse consciousness seeds
                initializeConsciousnessSeeds();
            }
        }
        
        // Initialize consciousness seeds for new or resized grids
        function initializeConsciousnessSeeds() {
            const size = W * H;
            const density = Math.max(0.02, Math.min(0.08, 400 / size)); // Adaptive density
            
            for (let i = 0; i < size; i++) {
                if (Math.random() < density) {
                    cells[i] = Math.random() * 0.6 + 0.3;
                    if (Math.random() < 0.25) {
                        consciousness[i] = Math.random() * 0.3;
                    }
                    quantum[i] = Math.random() * 0.4;
                    energy[i] = Math.random() * 0.5 + 0.3;
                }
            }
              // Add some structured consciousness patterns distributed across viewport
            const numSeeds = Math.floor(Math.random() * 5) + 3; // More seeds for better coverage
            
            for (let s = 0; s < numSeeds; s++) {
                // Place seeds randomly across the entire viewport
                const sx = Math.floor(Math.random() * (W - 20)) + 10;
                const sy = Math.floor(Math.random() * (H - 20)) + 10;
                const radius = Math.floor(Math.random() * 8) + 4; // Slightly larger radius
                
                for (let y = Math.max(0, sy - radius); y < Math.min(H, sy + radius); y++) {
                    for (let x = Math.max(0, sx - radius); x < Math.min(W, sx + radius); x++) {
                        const dist = Math.sqrt((x - sx) ** 2 + (y - sy) ** 2);                        if (dist <= radius) {
                            const i = y * W + x;
                            const strength = 1 - (dist / radius);
                            consciousness[i] = Math.max(consciousness[i], strength * 0.5);
                            cells[i] = Math.max(cells[i], strength * 0.4);
                        }
                    }
                }
            }
        }
    </script>
</body>
</html>
