<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⊕ ◎⊕◉</title>
    <link rel="stylesheet" href="palette.css">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%); 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            font-family: 'Courier New', monospace;
        }
        #display { 
            font-family: 'Courier New', monospace; 
            color: var(--cosmos-coral); 
            white-space: pre; 
            padding: 0; 
            margin: 0;
            width: 100vw; 
            height: 100vh; 
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%);
            position: fixed;
            top: 0;
            left: 0;
            line-height: 1.0;
            overflow: hidden;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: stretch;
        }        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: var(--cosmos-tiffany);
            z-index: 100;
            background: linear-gradient(135deg, var(--cosmos-dark-dim), var(--cosmos-rose-dim));
            padding: 10px;
            border-radius: 5px;
            border: 2px solid var(--cosmos-tiffany);
            box-shadow: 0 0 20px rgba(173, 235, 218, 0.3);
            text-shadow: 0 0 8px var(--cosmos-tiffany);
        }
    </style>
</head>
<body>    <div class="info">
        ⊕ ◎⊕◉<br>
        ◎+∿+∆<br>
        ⌫ ◦ ↩
    </div>
    <div id="display"></div>
    <script>
        const display = document.getElementById('display');
        // Dynamic viewport sizing - responsive to window dimensions
        let W, H;
        let charWidth, charHeight;
        let t = 0;
        
        // Global character measurement cache
        const charMeasurementCache = new Map();
        
        function getCachedCharacterMeasurement(fontFamily, fontSize, testContent = '●'.repeat(10) + '\n'.repeat(10)) {
            const cacheKey = `${fontFamily}-${fontSize}px`;
            
            if (charMeasurementCache.has(cacheKey)) {
                return charMeasurementCache.get(cacheKey);
            }
            
            // Create measurement element only if not cached
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = fontFamily;
            testDiv.style.fontSize = fontSize + 'px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = testContent;
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            const result = {
                charWidth: Math.max(rect.width / 10, 4),
                charHeight: Math.max(rect.height / 10, 6)
            };
            
            document.body.removeChild(testDiv);
            
            // Cache the result
            charMeasurementCache.set(cacheKey, result);
            return result;
        }
          
        // Calculate optimal grid size based on viewport
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate based on actual character measurements
            const testChar = '●';
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = 'Courier New, monospace';
            tempSpan.style.fontSize = '16px';
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.textContent = testChar;
            document.body.appendChild(tempSpan);
            
            const baseCharWidth = tempSpan.getBoundingClientRect().width;
            const baseCharHeight = tempSpan.getBoundingClientRect().height;
            document.body.removeChild(tempSpan);
            
            // Calculate how many characters fit in viewport
            const targetCharsWidth = Math.floor(viewportWidth / baseCharWidth) + 5;
            const targetCharsHeight = Math.floor(viewportHeight / baseCharHeight) + 5;
            
            // Calculate font size to fill viewport
            const fontSizeForWidth = viewportWidth / targetCharsWidth;
            const fontSizeForHeight = viewportHeight / targetCharsHeight;
            const fontSize = Math.min(fontSizeForWidth, fontSizeForHeight);
            
            // Update character measurements with final font size
            charWidth = (baseCharWidth / 16) * fontSize;
            charHeight = (baseCharHeight / 16) * fontSize;
            
            // Calculate grid dimensions
            W = Math.floor(viewportWidth / charWidth);
            H = Math.floor(viewportHeight / charHeight);
            
            // Ensure minimum viable grid for complex patterns
            W = Math.max(60, Math.min(W, 150));
            H = Math.max(30, Math.min(H, 100));
            
            // Set styles
            if (display) {
                display.style.fontSize = fontSize + 'px';
                display.style.lineHeight = charHeight + 'px';
                display.style.letterSpacing = '0';
                display.style.wordSpacing = '0';
                display.style.position = 'fixed';
                display.style.top = '0';
                display.style.left = '0';
                display.style.margin = '0';
                display.style.padding = '0';
            }
            
            // Reallocate arrays for new dimensions
            reallocateArrays();
        }
          // Synthesis of multiple consciousness systems - dynamically allocated
        let cellular, fluid, fractal, synthesis, memory;        
        // Dynamic array reallocation for responsive sizing
        function reallocateArrays() {
            // Ensure W and H are valid numbers
            if (!W || !H || W <= 0 || H <= 0) {
                W = 80;  // fallback dimensions
                H = 40;
            }
            
            const size = W * H;
            cellular = new Float32Array(size);    // Cellular automata consciousness
            fluid = new Float32Array(size);       // Flowing awareness 
            fractal = new Float32Array(size);     // Recursive self-organization
            synthesis = new Float32Array(size);   // Emergent combination
            memory = new Float32Array(size);      // Memory traces
            
            // Initialize with random cellular seeds scaled to new dimensions
            for (let i = 0; i < size; i++) {
                if (Math.random() < 0.08) {
                    cellular[i] = Math.random();
                }
                // Initialize all arrays with small random values to prevent empty states
                fluid[i] = Math.random() * 0.1;
                fractal[i] = Math.random() * 0.1;
            }
        }
        
        // Synthesis symbols - emergence from complexity interaction
        const symbols = [
            ' ', '·', '⠁', '⠃', '⠇', '⠏', '⠟', '⠿', '⡿', '⣿',  // cellular emergence
            '∴', '∵', '∸', '∹', '∺', '∻', '∼', '∽', '∾', '∿',  // fluid logic
            '⊕', '⊖', '⊗', '⊘', '⊙', '⊚', '⊛', '⊜', '⊝', '⊞'   // fractal synthesis
        ];        
        const colors = ['v','u','s','e','m','t','q','d','w','c','g','y','r','p','b','o','a','f','n','l'];
          // cellular automata scaled by viewport
        function updateCellular() {
            // Safety check for array initialization
            if (!cellular || !fluid || !fractal || !W || !H) return;
            
            const newCellular = new Float32Array(W * H);
            const scaleFactor = Math.sqrt(W * H) / 100; // Viewport scale factor
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    let neighbors = 0;
                    let total = 0;
                    
                    // Conway-like rules with continuous values
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = (x + dx + W) % W;
                            const ny = (y + dy + H) % H;
                            const ni = ny * W + nx;
                            
                            if (cellular[ni] > 0.1) {
                                neighbors++;
                                total += cellular[ni];
                            }
                        }
                    }
                    
                    const current = cellular[i];
                    const avg = neighbors > 0 ? total / neighbors : 0;
                    
                    if (current > 0.1) {
                        // Living cell
                        if (neighbors === 2 || neighbors === 3) {
                            newCellular[i] = Math.min(1, current + avg * 0.05);
                        } else {
                            newCellular[i] = Math.max(0, current - 0.08);
                        }
                    } else {
                        // Dead cell
                        if (neighbors === 3) {
                            newCellular[i] = avg * 0.6;
                        } else {
                            newCellular[i] = current * 0.97;
                        }
                    }
                      // Cross-system influence with viewport scaling
                    newCellular[i] += fluid[i] * 0.03 * scaleFactor + fractal[i] * 0.02 * scaleFactor;
                    newCellular[i] = Math.max(0, Math.min(1, newCellular[i]));
                }
            }
            
            // ∇ periodic seeding prevents stagnation
            if (t % 200 === 0) {
                for (let i = 0; i < W * H; i++) {
                    if (Math.random() < 0.001) {
                        newCellular[i] += Math.random() * 0.3;
                    }
                }
            }
            
            for (let i = 0; i < W * H; i++) {
                cellular[i] = newCellular[i];
            }
        }          function updateFluid() {
            // Safety check for array initialization
            if (!fluid || !cellular || !fractal || !W || !H) return;
            
            const τ = t * 0.01;
            const scaleFactor = Math.sqrt(W * H) / 100; // Viewport adaptation
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    const nx = x / W, ny = y / H;
                    const cx = nx - 0.5, cy = ny - 0.5;
                    
                    // fluid flow uses viewport scale
                    const angle = Math.atan2(cy, cx) + τ;
                    const r = Math.sqrt(cx * cx + cy * cy);
                    const flow = Math.sin(r * 8 * scaleFactor + τ * 2) * Math.cos(angle * 3);
                    
                    // Advection-like behavior with temporal evolution
                    const prev = fluid[i];
                    const timeWave = Math.sin(τ * 3 + x * 0.1 + y * 0.1) * 0.02;
                    fluid[i] = prev * 0.96 + (flow + timeWave) * 0.04;
                    
                    // Cellular influence on fluid
                    if (cellular[i] > 0.5) {
                        fluid[i] += 0.05;
                    }
                    
                    // Fractal sources
                    if (fractal[i] > 0.3) {
                        fluid[i] += fractal[i] * 0.1;
                    }
                    
                    fluid[i] = Math.max(0, Math.min(1, fluid[i]));
                }
            }
        }          function updateFractal() {
            // Safety check for array initialization
            if (!fractal || !cellular || !fluid || !W || !H) return;
            
            const τ = t * 0.002;
            const scaleFactor = Math.sqrt(W * H) / 100; // Viewport adaptation
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    
                    // Julia set uses viewport scale
                    const zx = (x - W/2) / (W/8 * scaleFactor);
                    const zy = (y - H/2) / (H/8 * scaleFactor);
                    
                    // Evolving fractal parameters with golden ratio harmonics
                    const φ = 1.618033988749895;
                    const cx = 0.7 * Math.cos(τ) - 0.2 + Math.sin(τ * φ) * 0.1;
                    const cy = 0.3 * Math.sin(τ * 1.3) + 0.1 + Math.cos(τ / φ) * 0.05;                    
                    let x0 = zx, y0 = zy;
                    let iter = 0;
                    const maxIter = Math.floor(12 + scaleFactor * 2); // Adaptive iteration depth
                    
                    while (x0*x0 + y0*y0 <= 4 && iter < maxIter) {
                        const temp = x0*x0 - y0*y0 + cx;
                        y0 = 2*x0*y0 + cy;
                        x0 = temp;
                        iter++;
                    }
                    
                    let value = iter / maxIter;
                    
                    // systems interact via time phase
                    if (cellular[i] > 0.3) value *= (1.2 + Math.sin(τ * 10) * 0.1);
                    if (fluid[i] > 0.2) value *= (1 + fluid[i] * 0.3 + Math.cos(τ * 7) * 0.05);
                    
                    fractal[i] = fractal[i] * 0.92 + value * 0.08;
                    fractal[i] = Math.max(0, Math.min(1, fractal[i]));
                }
            }
        }          function calculateSynthesis() {
            // Safety check for array initialization
            if (!synthesis || !memory || !cellular || !fluid || !fractal || !W || !H) return;
            
            const τ = t * 0.001;
            
            for (let i = 0; i < W * H; i++) {
                // synthesis via harmonic resonance
                const interaction = cellular[i] * fluid[i] * fractal[i];
                const combination = (cellular[i] + fluid[i] + fractal[i]) / 3;
                const resonance = Math.sin(τ * 5 + interaction * 10) * 0.1;
                const emergence = Math.sqrt(interaction) + combination * 0.5 + resonance;
                
                synthesis[i] = synthesis[i] * 0.95 + emergence * 0.05;
                
                // memory builds with time waves
                if (synthesis[i] > 0.7) {
                    memory[i] = Math.min(1, memory[i] + 0.01 + Math.sin(τ * 8) * 0.005);
                } else {
                    memory[i] *= 0.999;
                }
            }
        }          function render() {
            // Safety check for initialization
            if (!cellular || !fluid || !fractal || !synthesis || !memory || !W || !H) {
                requestAnimationFrame(render);
                return;
            }
            
            updateCellular();
            updateFluid();
            updateFractal();
            calculateSynthesis();

            // Clear and rebuild display div for precise positioning
            display.innerHTML = '';
            
            // breathing effect using harmonic waves
            const breath1 = Math.sin(t * 0.04) * 0.1 + 0.9;
            const breath2 = Math.cos(t * 0.03) * 0.05 + 0.95;
            const globalBreath = (breath1 + breath2) / 2;
            
            // Create each row as a separate div for precise control
            for (let y = 0; y < H; y++) {
                const rowDiv = document.createElement('div');
                rowDiv.style.height = charHeight + 'px';
                rowDiv.style.lineHeight = charHeight + 'px';
                rowDiv.style.margin = '0';
                rowDiv.style.padding = '0';
                rowDiv.style.whiteSpace = 'pre';
                rowDiv.style.overflow = 'hidden';
                
                let rowContent = '';
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    
                    // Choose dominant system or synthesis with enhanced logic
                    let intensity, system;
                    const s = (synthesis[i] || 0) + (memory[i] || 0) * 0.3;
                    
                    if (s > 0.4) {
                        intensity = s;
                        system = 2; // synthesis symbols
                    } else if ((fractal[i] || 0) > (cellular[i] || 0) && (fractal[i] || 0) > (fluid[i] || 0)) {
                        intensity = fractal[i] || 0;
                        system = 2; // fractal
                    } else if ((fluid[i] || 0) > (cellular[i] || 0)) {
                        intensity = fluid[i] || 0;
                        system = 1; // fluid
                    } else {
                        intensity = cellular[i] || 0;
                        system = 0; // cellular
                    }
                    
                    // Apply breathing synthesis effect
                    intensity *= globalBreath;
                    
                    // Symbol selection by system with bounds checking
                    const baseIdx = system * 10;
                    const symIdx = Math.min(baseIdx + Math.floor(intensity * 9), symbols.length - 1);
                    const colorIdx = Math.min(Math.floor(intensity * colors.length), colors.length - 1);
                    
                    rowContent += `<span class="${colors[colorIdx]}">${symbols[symIdx]}</span>`;
                }
                
                rowDiv.innerHTML = rowContent;
                display.appendChild(rowDiv);
            }
            
            t += 0.5;
            requestAnimationFrame(render);
        }
          // ∇ chaos avoids stagnation
        function addDynamicChaos() {
            if (!cellular || !fluid || !W || !H) return;
            
            if (t % 500 === 0) {
                // Inject controlled chaos to prevent stagnation
                for (let i = 0; i < W * H; i++) {
                    if (Math.random() < 0.0005) {
                        cellular[i] += (Math.random() - 0.5) * 0.2;
                        fluid[i] += (Math.random() - 0.5) * 0.1;
                    }
                }
            }
        }
        
        // resize → updateDimensions
        window.addEventListener('resize', () => {
            setTimeout(updateDimensions, 100); // Slight delay for accurate measurements
        }, { passive: true });          // quick init with dynamic size
        function initialize() {
            updateDimensions();
            addDynamicChaos(); // Initial chaos injection
            
            // Ensure arrays are properly initialized before starting render
            if (cellular && fluid && fractal && synthesis && memory && W && H) {
                render();
            } else {
                setTimeout(initialize, 100);
            }
        }
        
        // start: size then run
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
