<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>∿◦∿ ⟲◉⟲ ∿◦∿</title>
    <link rel="stylesheet" href="palette.css">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }        body {
            background: var(--cosmos-dark);
            color: var(--cosmos-tiffany);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            cursor: pointer;
        }

        #gateway {
            font-size: 10px;
            line-height: 1.0;
            white-space: pre;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            filter: drop-shadow(0 0 2px currentColor);
        }.glyph {
            display: inline-block;
            width: 0.6em;
            transition: all 0.1s ease;
        }

        /* Cosmos palette color classes for spiral effects */
        .cosmos-0 { color: var(--cosmos-dark); text-shadow: 0 0 1px currentColor; }
        .cosmos-1 { color: var(--cosmos-melon-dim); text-shadow: 0 0 1px currentColor; }
        .cosmos-2 { color: var(--cosmos-tiffany-dim); text-shadow: 0 0 2px currentColor; }
        .cosmos-3 { color: var(--cosmos-rose); text-shadow: 0 0 2px currentColor; }
        .cosmos-4 { color: var(--cosmos-coral); text-shadow: 0 0 3px currentColor; }
        .cosmos-5 { color: var(--cosmos-tiffany); text-shadow: 0 0 3px currentColor; }
        .cosmos-6 { color: var(--cosmos-orange); text-shadow: 0 0 4px currentColor; }
        .cosmos-7 { color: var(--cosmos-melon); text-shadow: 0 0 4px currentColor; }
        .cosmos-8 { color: var(--cosmos-coral-bright); text-shadow: 0 0 5px currentColor; }
        .cosmos-9 { color: var(--cosmos-orange-bright); text-shadow: 0 0 5px currentColor; }
        .cosmos-10 { color: var(--cosmos-tiffany-bright); text-shadow: 0 0 6px currentColor; }
        .cosmos-11 { color: var(--cosmos-melon-bright); text-shadow: 0 0 6px currentColor; }
        .cosmos-12 { color: var(--cosmos-cream); text-shadow: 0 0 8px currentColor; }.controls {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 11px;
            color: var(--cosmos-melon-dim);
            z-index: 10;
            background: rgba(69, 9, 32, 0.7);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--cosmos-tiffany-dim);
        }

        @media (max-width: 600px) {
            #gateway { font-size: 10px; }
        }
    </style>
</head>
<body>    <div class="controls">
        ⌫: ◊ | ⎵: ◦ | ←→: ⟲
    </div>
    
    <pre id="gateway"></pre>    <script>
        let W, H;
        let frame = 0;
        let speed = 0.02;
        let paused = false;
        
        const gateway = document.getElementById('gateway');
          function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate optimal character dimensions
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '10px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = '○'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            const charWidth = rect.width / 10;
            const charHeight = rect.height / 10;
            document.body.removeChild(testDiv);
            
            // Calculate dynamic grid size for full coverage
            W = Math.ceil(viewportWidth / charWidth) + 1;
            H = Math.ceil(viewportHeight / charHeight) + 1;
            
            // Ensure reasonable bounds
            W = Math.max(40, Math.min(120, W));
            H = Math.max(20, Math.min(80, H));
            
            // Calculate font size for full viewport coverage
            const optimalFontWidth = viewportWidth / W;
            const optimalFontHeight = viewportHeight / H;
            const fontSize = Math.min(optimalFontWidth * 1.8, optimalFontHeight * 1.2);
            
            gateway.style.fontSize = Math.max(fontSize, 6) + 'px';
            gateway.style.lineHeight = (Math.max(fontSize, 6) * 1.0) + 'px';
        }
        
        const glyphs = [' ', '·', '•', '◦', '○', '◉', '⊙', '⬢', '✦', '✺', '✼', '※'];
        
        // Cosmos color mapping function for spiral effects
        function getCosmosColorClass(intensity, angle, radius, time) {
            // Create dynamic color progression based on spiral properties
            const anglePhase = (angle * 180 / Math.PI + time * 0.5) % 360;
            const radiusPhase = (radius * 10 + time * 0.3) % 100;
            const combined = (intensity * 100 + anglePhase * 0.5 + radiusPhase * 0.3) % 100;
            
            // Map to cosmos palette (0-12 range for 13 color classes)
            const colorIndex = Math.floor((combined / 100) * 13);
            return `cosmos-${colorIndex}`;
        }
        
        function render() {
            if (!paused) {
                let output = '';
                
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const dx = x - W/2;
                        const dy = y - H/2;
                        const r = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx) + frame * speed;
                        
                        // Create spiral pattern with multiple harmonics
                        const spiral1 = Math.sin(r * 0.3 - angle * 2);
                        const spiral2 = Math.cos(r * 0.2 - angle * 3 + frame * 0.01);
                        const spiral3 = Math.sin(r * 0.1 + angle * 1.5 - frame * 0.005);
                        
                        const intensity = (spiral1 + spiral2 * 0.5 + spiral3 * 0.3 + 3) / 4;
                        const normalizedIntensity = Math.max(0, Math.min(1, intensity));
                          const glyphIndex = Math.floor(normalizedIntensity * (glyphs.length - 1));
                        const glyph = glyphs[glyphIndex];
                        
                        // Dynamic cosmos color based on spiral properties
                        const colorClass = getCosmosColorClass(normalizedIntensity, angle, r, frame);
                        
                        if (glyph === ' ') {
                            output += '<span class="glyph"> </span>';
                        } else {
                            output += `<span class="glyph ${colorClass}">${glyph}</span>`;
                        }
                    }
                    output += '\n';
                }
                
                gateway.innerHTML = output;
                frame++;
            }
            
            requestAnimationFrame(render);
        }        
        // Initialize dimensions and start render loop
        updateDimensions();
        
        // Keyboard controls
        window.addEventListener('resize', updateDimensions, { passive: true });
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'escape':
                    window.parent?.postMessage('close', '*');
                    break;
                case ' ':
                    e.preventDefault();
                    paused = !paused;
                    break;
                case 'arrowleft':
                    speed = Math.max(0.001, speed * 0.8);
                    break;
                case 'arrowright':
                    speed = Math.min(0.1, speed * 1.2);
                    break;
            }
        });
        
        // Click to close
        document.addEventListener('click', () => {
            window.parent?.postMessage('close', '*');
        });
        
        // Touch support
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            window.parent?.postMessage('close', '*');
        });
        
        // Start animation
        render();
        
    </script>
</body>
</html>
