<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>∇ ♦∂♦</title>
    <!-- PERFORMANCE OPTIMIZATION: Uses smaller grid with larger characters 
         for smooth 60fps performance while maintaining visual coverage -->
    <link rel="stylesheet" href="palette.css">
    <style>        body { 
            margin: 0; 
            padding: 0; 
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%); 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            font-family: 'Courier New', monospace;
        }        #display { 
            font-family: 'Courier New', monospace; 
            color: var(--cosmos-melon); 
            white-space: pre; 
            padding: 0; 
            margin: 0;
            width: 100vw; 
            height: 100vh; 
            background: linear-gradient(135deg, var(--cosmos-dark) 0%, #000 100%);
            position: fixed;
            top: 0;
            left: 0;
            line-height: 1.0;
            overflow: hidden;
            font-size: 14px;  /* Base font size, will be dynamically adjusted */
            box-sizing: border-box;
        }/* Life evolution states using cohesive palette */
        .v{color: var(--cosmos-tiffany)} .u{color: var(--cosmos-coral)} .s{color: var(--cosmos-orange)} 
        .e{color: var(--cosmos-melon)} .m{color: var(--cosmos-cream)} .t{color: var(--cosmos-rose)} 
        .q{color: var(--cosmos-tiffany-dim)} .d{color: var(--cosmos-coral-dim)} .w{color: var(--cosmos-orange-dim)} 
        .c{color: var(--cosmos-melon-dim)} .g{color: var(--cosmos-coral-bright)} .y{color: var(--cosmos-orange-bright)} 
        .r{color: var(--cosmos-coral)} .p{color: var(--cosmos-melon-bright)} .b{color: var(--cosmos-tiffany-bright)}
        .o{color: var(--cosmos-orange)} .a{color: var(--cosmos-rose-dim)} .f{color: var(--cosmos-coral)} 
        .n{color: var(--cosmos-melon)} .l{color: var(--cosmos-tiffany-dim)}
          .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: var(--cosmos-tiffany);
            z-index: 100;
            background: linear-gradient(135deg, var(--cosmos-dark-dim), var(--cosmos-rose-dim));
            padding: 10px;
            border-radius: 5px;
            border: 2px solid var(--cosmos-tiffany);
            box-shadow: 0 0 20px rgba(173, 235, 218, 0.3);
            text-shadow: 0 0 8px var(--cosmos-tiffany);
        }
    </style>
</head>
<body>
    <div class="info">
        ∇ ♦∂♦<br>
        ∂φ/∂t = D∇²φ + f(φ)<br>
        ⌫ ◦ ↩
    </div>
    <div id="display"></div>    <script>
        const display = document.getElementById('display');
        // Dynamic viewport sizing
        let W, H;        let charWidth, charHeight;
        let t = 0;
        const displayElem = document.getElementById('display');
        let running = true;        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // PERFORMANCE: Use larger characters to reduce total DOM elements
            // But calculate font size dynamically to fill the entire canvas
              // Target grid size for optimal performance - doubled for better wave visibility
            const targetW = 100; // Doubled from 50 to show more dimensional waves
            const targetH = 60;  // Doubled from 30 to show more patterns
            
            // Calculate font size needed to fill the viewport with target grid
            const fontSizeForWidth = viewportWidth / targetW;
            const fontSizeForHeight = viewportHeight / targetH;
            
            // Use the smaller dimension to ensure full coverage
            const baseFontSize = Math.max(8, Math.min(24, Math.min(fontSizeForWidth, fontSizeForHeight)));
            
            // Character measurement with calculated font size
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = baseFontSize + 'px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = '♦'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(testDiv);            
            // Calculate actual grid dimensions that will fill the viewport
            W = Math.floor(viewportWidth / charWidth);
            H = Math.floor(viewportHeight / charHeight);
                // Ensure minimum grid size for interesting patterns
            W = Math.max(60, W);  // Increased minimum for better wave visibility
            H = Math.max(40, H);  // Increased minimum for better patterns
            
            // Cap maximum for performance - increased limits for better visuals
            W = Math.min(120, W); // Doubled from 80
            H = Math.min(80, H);  // Increased from 50            // Set display properties for full coverage without borders
            displayElem.style.fontSize = baseFontSize + 'px';
            displayElem.style.lineHeight = baseFontSize + 'px';
            displayElem.style.width = '100vw';
            displayElem.style.height = '100vh';
            displayElem.style.position = 'fixed';
            displayElem.style.top = '0';
            displayElem.style.left = '0';
            displayElem.style.margin = '0';
            displayElem.style.padding = '0';
            displayElem.style.overflow = 'hidden';
            displayElem.style.display = 'block';
            displayElem.style.textAlign = 'left'; // Left align for edge-to-edge coverage
            displayElem.style.boxSizing = 'border-box';
            
            // No centering padding - fill completely to edges
            // Recalculate font size to maximize coverage if needed
            const actualWidth = W * charWidth;
            const actualHeight = H * charHeight;
            
            // If grid doesn't fill at least 95% of viewport, increase font size
            if (actualWidth < viewportWidth * 0.95 || actualHeight < viewportHeight * 0.95) {
                const scaleX = viewportWidth / actualWidth;
                const scaleY = viewportHeight / actualHeight;
                const adjustedFontSize = Math.min(22, baseFontSize * Math.min(scaleX, scaleY));
                displayElem.style.fontSize = adjustedFontSize + 'px';
                displayElem.style.lineHeight = adjustedFontSize + 'px';
            }
        }
        
        // Mathematical constant
        const pi = 3.141592653589793;
        
        // Reaction-diffusion field arrays
        let concentration, diffusion, reaction, gradient, nextBuffer;
        
        function initializeFields() {
            const size = W * H;
            concentration = new Float32Array(size);   // Primary concentration field
            diffusion = new Float32Array(size);       // Diffusion coefficients
            reaction = new Float32Array(size);        // Reaction rates
            gradient = new Float32Array(size * 2);    // Gradient field
            nextBuffer = new Float32Array(size);      // Temp buffer
            
            // Initialize with organic patterns
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const xi = (x - W/2) / (W/4);
                    const yi = (y - H/2) / (H/4);
                    const r = Math.sqrt(xi*xi + yi*yi);
                    
                    // Seed initial concentrations with organic noise
                    concentration[idx] = Math.random() * Math.exp(-r * 0.5);
                    diffusion[idx] = 0.1 + Math.random() * 0.05;
                    reaction[idx] = Math.random() * 0.3;
                }
            }
        }
        
        // Life-form symbols - progression from simple to complex
        const lifeSymbols = [
            '·', '∘', '○', '●', '◦', '◉', '◎',           // Basic forms
            '♦', '◊', '⬦', '⬧', '⬨', '⬩',               // Diamond forms
            '∆', '▲', '▽', '▼', '◀', '▶',               // Triangle forms  
            '⟡', '⟢', '⟣', '⟤', '⟥', '⟦',               // Complex forms
            '⚬', '⚭', '⚮', '⚯', '⚰', '⚱',               // Organic forms
            '⊙', '⊚', '⊛', '⊜', '⊝', '⊞', '⊟', '⊠',   // Advanced forms
            '∞', '∅', '∩', '∪', '⊕', '⊗'                // Mathematical forms
        ];
        
        const colorClasses = ['v','u','s','e','m','t','q','d','w','c','g','y','r','p','b','o','a','f','n','l'];
        
        function idx(x, y) {
            return ((y + H) % H) * W + ((x + W) % W);
        }
        
        // Reaction-diffusion equations for emergent life
        function reactionDiffusion(x, y, time) {
            const xi = (x - W/2) / (W/4);
            const yi = (y - H/2) / (H/4);
            const r = Math.sqrt(xi*xi + yi*yi);
            
            // Activator-inhibitor dynamics (Turing patterns)
            const activator = Math.sin(r * 5 + time * 2) * Math.exp(-r * 0.3);
            const inhibitor = Math.cos(r * 3 - time * 1.5) * Math.exp(-r * 0.5);
            
            // Non-linear reaction terms
            const logistic = 1 / (1 + Math.exp(-5 * (activator - inhibitor)));
            
            // Metabolic oscillations
            const metabolism = Math.sin(time * 3 + x * 0.1 + y * 0.1) * 0.2;
            
            // Growth-decay balance
            const growth = logistic * (1 - logistic) * 4; // Bell curve for optimal growth
            
            return { 
                growth: growth + metabolism,
                diffusion: 0.1 + Math.abs(Math.sin(r + time)) * 0.05,
                reaction: logistic
            };
        }
        
        function update() {
            t += 0.03;
            nextBuffer.fill(0);
            
            // Reaction-diffusion update
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = idx(x, y);
                    const current = concentration[i];
                    
                    // Calculate Laplacian (diffusion)
                    const neighbors = [
                        concentration[idx(x-1, y)], concentration[idx(x+1, y)],
                        concentration[idx(x, y-1)], concentration[idx(x, y+1)],
                        concentration[idx(x-1, y-1)], concentration[idx(x+1, y-1)],
                        concentration[idx(x-1, y+1)], concentration[idx(x+1, y+1)]
                    ];
                    const laplacian = (neighbors.reduce((a, b) => a + b, 0) - 8 * current);
                    
                    // Get reaction-diffusion dynamics
                    const dynamics = reactionDiffusion(x, y, t);
                    
                    // Update equation: ∂φ/∂t = D∇²φ + f(φ)
                    const diffusionTerm = dynamics.diffusion * laplacian;
                    const reactionTerm = dynamics.growth * current * (1 - current) - 
                                       dynamics.reaction * current * current;
                    
                    // Age and memory effects
                    const age = Math.sin(t * 0.5 + x * 0.05 + y * 0.07) * 0.02;
                    
                    // Self-organization bias
                    const organization = Math.sin(current * pi * 2) * 0.01;
                    
                    nextBuffer[i] = Math.max(0, Math.min(1,
                        current + 0.1 * (diffusionTerm + reactionTerm) + age + organization
                    ));                    // Periodic seeding of new life - adjusted for larger grid
                    if (Math.random() < 0.0004) { // Reduced frequency to account for more cells
                        nextBuffer[i] += Math.random() * 0.2;
                    }
                }
            }
            
            const temp = concentration;
            concentration = nextBuffer;
            nextBuffer = temp;
            
            // Update diffusion and reaction fields
            for (let i = 0; i < W * H; i++) {
                diffusion[i] = diffusion[i] * 0.99 + Math.random() * 0.01;
                reaction[i] = reaction[i] * 0.98 + concentration[i] * 0.02;
            }
        }
        
        function render() {
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = idx(x, y);
                    const intensity = concentration[i];
                    const react = reaction[i];
                    
                    if (intensity > 0.8) {
                        // Complex life forms
                        const symbolIdx = Math.floor(intensity * lifeSymbols.length * 0.9) + 
                                        Math.floor(lifeSymbols.length * 0.1);
                        const colorIdx = Math.floor((intensity + react * 0.3) * colorClasses.length);
                        const symbol = lifeSymbols[Math.min(symbolIdx, lifeSymbols.length - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorClasses.length - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.5) {
                        // Developing life
                        const symbolIdx = Math.floor(intensity * lifeSymbols.length * 0.6);
                        const colorIdx = Math.floor(intensity * colorClasses.length * 0.8);
                        const symbol = lifeSymbols[Math.min(symbolIdx, lifeSymbols.length - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorClasses.length - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.2) {
                        // Emerging life
                        const symbolIdx = Math.floor(intensity * lifeSymbols.length * 0.3);
                        const symbol = lifeSymbols[Math.min(symbolIdx, lifeSymbols.length - 1)];
                        output += `<span class="u">${symbol}</span>`;
                    } else if (intensity > 0.05) {
                        // Traces of life
                        output += '<span class="l">·</span>';
                    } else {                        // Substrate/medium - reduced noise for larger grid performance
                        if (Math.random() < 0.0005) { // Further reduced for larger grid
                            output += '<span class="l">∘</span>';
                        } else {
                            output += ' ';
                        }}
                }                output += '\n';
            }
            
            displayElem.innerHTML = output;
        }
        
        function loop() {
            if (!running) return;
            update();
            render();
            requestAnimationFrame(loop);
        }
          // Initialize - force immediate dimension update and field initialization
        window.addEventListener('resize', () => {
            updateDimensions();
            initializeFields();
        }, { passive: true });
        
        updateDimensions();
        initializeFields();
        
        // Handle visibility changes for performance
        document.addEventListener('visibilitychange', () => {
            running = !document.hidden;
            if (running) requestAnimationFrame(loop);
        });
        
        loop();
    </script>
</body>
</html>
