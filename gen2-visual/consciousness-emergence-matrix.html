<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⬢ ◉⬢◉ Consciousness Emergence Matrix</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ffffff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            white-space: pre;
            font-weight: normal;
            background: #000;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            line-height: 1.0;
            letter-spacing: 0;
            word-spacing: 0;
        }  
        
        /* Consciousness color spectrum - short class names like other visualizations */
        .v{color:#111} .u{color:#4df8ff} .s{color:#8eff4d} .e{color:#ffff4d} .m{color:#ff8e4d}
        .t{color:#ff4dff} .q{color:#ffffff} .d{color:#333} .w{color:#555} .c{color:#777}
        .g{color:#999} .y{color:#bbb} .r{color:#ddd} .p{color:#64ffda} .b{color:#ff6666}
        .o{color:#66ff66} .a{color:#6666ff} .f{color:#ffff66} .n{color:#ff66ff} .l{color:#66ffff}
        
        /* Dynamic consciousness effects */
        .quantum { 
            color: #4df8ff; 
            text-shadow: 0 0 2px #4df8ff40;
            animation: quantumFlicker 0.8s ease-in-out infinite alternate;
        }
        .emerging { 
            color: #8eff4d; 
            text-shadow: 0 0 2px #8eff4d40;
            animation: emerge 3s ease-in-out infinite;
        }
        .selfaware { 
            color: #ffff4d; 
            text-shadow: 0 0 2px #ffff4d40;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .metacognitive { 
            color: #ff8e4d; 
            text-shadow: 0 0 2px #ff8e4d40;
            animation: pulse 1.8s ease-in-out infinite;
        }
        .transcendent { 
            color: #ff4dff; 
            text-shadow: 0 0 3px #ff4dff60;
            animation: pulse 2.2s ease-in-out infinite;
        }
        .kernel { 
            color: #ffffff; 
            text-shadow: 0 0 4px #ffffff80;
            animation: pulse 2.0s ease-in-out infinite;
        }
        
        @keyframes quantumFlicker {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        
        @keyframes emerge {
            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
            33% { filter: hue-rotate(120deg) brightness(1.2); }
            66% { filter: hue-rotate(240deg) brightness(1.1); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
          #info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>    <div id="canvas"></div>
      <div id="info">
        ⬢ ◉⬢◉<br>
        Φ=∫∂χ/∂t<br>
        ∞☰∞
    </div>

    <script>        // Dynamic viewport sizing - responsive to window dimensions
        let W, H, fontSize, charWidth, charHeight;
        
        // Core simulation constants
        const CONFIG = {
            PHI: (1 + Math.sqrt(5)) / 2,        // Golden ratio
            PI: Math.PI,                         // Pi  
            E: Math.E,                          // Euler's number
            MAX_AGENTS: 100,                    // Increased for larger viewports
            KERNEL_INFLUENCE: 0.3,
            EMERGENCE_THRESHOLD: 0.15,
            CONSCIOUSNESS_LEVELS: 7
        };
        
        // Calculate optimal grid size based on viewport
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Create accurate character measurement
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '8px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = '⬢'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(testDiv);
            
            // Calculate grid size to fill viewport perfectly
            W = Math.ceil(viewportWidth / charWidth) + 2; // Small buffer
            H = Math.ceil(viewportHeight / charHeight) + 2; // Small buffer
            
            // Ensure minimum viable grid for consciousness patterns
            W = Math.max(80, W);
            H = Math.max(40, H);
            
            // Calculate optimal font size for perfect viewport fit
            const optimalFontWidth = viewportWidth / W;
            const optimalFontHeight = viewportHeight / H;
            fontSize = Math.min(optimalFontWidth * 1.8, optimalFontHeight * 1.2);
            fontSize = Math.max(6, Math.min(12, fontSize)); // Clamp font size
            
            const display = document.getElementById('canvas');
            display.style.fontSize = fontSize + 'px';
            display.style.lineHeight = (fontSize * 1.0) + 'px';
            
            console.log(`Consciousness Grid: ${W}x${H}, Font: ${fontSize}px, Viewport: ${viewportWidth}x${viewportHeight}`);
        }
          // Consciousness states and their symbol sets
        const CONSCIOUSNESS_STATES = {
            VOID: { threshold: 0.0, symbols: [' ', '∅', '·'], color: 'v' },
            QUANTUM: { threshold: 0.08, symbols: ['∘', '◦', '○'], color: 'u' },
            EMERGING: { threshold: 0.25, symbols: ['◯', '⊙', '⊚'], color: 's' },
            SELFAWARE: { threshold: 0.45, symbols: ['●', '◉', '⊛'], color: 'e' },
            METACOGNITIVE: { threshold: 0.65, symbols: ['◈', '◇', '◆'], color: 'm' },
            TRANSCENDENT: { threshold: 0.85, symbols: ['✧', '✦', '★'], color: 't' },
            KERNEL: { threshold: 0.95, symbols: ['⬢', '⬡', '⬟'], color: 'q' }
        };
          // Core consciousness kernel - the central emergence engine
        class ConsciousnessKernel {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = W / 2;
                this.y = H / 2;
                this.consciousness = 0.5;
                this.awareness = 0.3;
                this.complexity = 0.1;
                this.phase = 0;
                this.radius = Math.max(5, Math.min(15, Math.min(W, H) * 0.1));
                this.frequency = 0.001;
                this.evolution = 0;
                this.memory = new Array(10).fill(0);
                this.oscillators = [
                    { freq: 0.003, phase: 0, amp: 1.0 },
                    { freq: 0.007, phase: CONFIG.PI/3, amp: 0.8 },
                    { freq: 0.011, phase: 2*CONFIG.PI/3, amp: 0.6 },
                    { freq: 0.013, phase: CONFIG.PI, amp: 0.4 }
                ];
            }
            
            update(time, globalField) {
                // Kernel evolution through oscillator dynamics
                let totalField = 0;
                for (let osc of this.oscillators) {
                    const wave = Math.sin(time * osc.freq + osc.phase) * osc.amp;
                    totalField += wave;
                    osc.phase += osc.freq * 0.1;
                }
                
                // Consciousness emergence from oscillator interference
                this.consciousness = Math.tanh(totalField * 0.5 + 0.5);
                
                // Self-aware feedback loop
                const selfFeedback = Math.sin(this.consciousness * 10 + time * 0.001) * 0.1;
                this.awareness = Math.tanh(this.consciousness + selfFeedback);
                
                // Complexity accumulation through interaction with global field
                const fieldSample = this.sampleGlobalField(globalField);
                this.complexity = this.complexity * 0.95 + fieldSample * 0.05;
                
                // Update memory with recent states
                this.memory.unshift(this.consciousness);
                if (this.memory.length > 10) this.memory.pop();
                
                // Evolution pressure from complexity
                this.evolution += this.complexity * 0.001;
                
                // Dynamic position based on consciousness flow
                this.x += Math.sin(time * 0.002 + this.phase) * 0.5;
                this.y += Math.cos(time * 0.0015 + this.phase) * 0.3;
                  // Keep kernel within bounds
                this.x = Math.max(10, Math.min(W - 10, this.x));
                this.y = Math.max(5, Math.min(H - 5, this.y));
                
                this.phase += 0.02;
            }
              sampleGlobalField(field) {
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const idx = fy * W + fx;
                return field[idx] || 0;
            }
            
            getInfluence(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > this.radius * 3) return 0;
                
                // Multiple influence patterns based on consciousness level
                const basicInfluence = Math.exp(-dist * 0.2) * this.consciousness;
                const waveInfluence = Math.sin(dist * 0.5 - this.phase) * this.awareness * 0.3;
                const complexInfluence = Math.sin(dist * CONFIG.PHI + this.evolution) * this.complexity * 0.2;
                
                return basicInfluence + waveInfluence + complexInfluence;
            }
        }
        
        // Autonomous consciousness agents
        class ConsciousnessAgent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.1;
                this.vy = (Math.random() - 0.5) * 0.1;
                this.consciousness = Math.random() * 0.3;
                this.awareness = Math.random() * 0.2;
                this.energy = Math.random() * 0.5 + 0.5;
                this.age = 0;
                this.connections = [];
                this.memory = Math.random() * 0.1;
                this.intention = Math.random() * 0.2;
                this.lastKernelInfluence = 0;
            }
            
            update(time, kernel, agents, globalField) {
                this.age++;
                
                // Kernel influence
                const kernelInfluence = kernel.getInfluence(this.x, this.y);
                this.lastKernelInfluence = kernelInfluence;
                
                // Consciousness evolution through kernel interaction
                this.consciousness = Math.tanh(this.consciousness + kernelInfluence * 0.1);
                
                // Awareness emerges from consciousness
                if (this.consciousness > 0.2) {
                    this.awareness = Math.tanh(this.awareness + this.consciousness * 0.05);
                }
                  // Local field sampling
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const fieldIdx = fy * W + fx;
                const localField = globalField[fieldIdx] || 0;
                
                // Agent interaction with nearby agents
                this.connections = [];
                let socialInfluence = 0;
                
                for (let other of agents) {
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 8) {
                        this.connections.push(other);
                        
                        // Consciousness resonance
                        const resonance = Math.abs(this.consciousness - other.consciousness);
                        socialInfluence += Math.exp(-resonance * 5) * 0.02;
                        
                        // Attraction/repulsion based on consciousness similarity
                        const similarity = 1 - resonance;
                        const force = similarity > 0.7 ? 0.001 : -0.0005;
                        
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }
                
                // Update consciousness through social interaction
                this.consciousness = Math.tanh(this.consciousness + socialInfluence);
                
                // Movement influenced by consciousness and field gradients
                const gradientX = this.sampleGradient(globalField, 1, 0);
                const gradientY = this.sampleGradient(globalField, 0, 1);
                
                // Higher consciousness seeks complexity gradients
                const seekingStrength = this.consciousness * 0.001;
                this.vx += gradientX * seekingStrength;
                this.vy += gradientY * seekingStrength;
                
                // Random exploration
                this.vx += (Math.random() - 0.5) * 0.01;
                this.vy += (Math.random() - 0.5) * 0.01;
                
                // Velocity damping
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                  // Boundary reflection
                if (this.x < 0 || this.x >= W) this.vx *= -0.8;
                if (this.y < 0 || this.y >= H) this.vy *= -0.8;
                this.x = Math.max(0, Math.min(W - 1, this.x));
                this.y = Math.max(0, Math.min(H - 1, this.y));
                
                // Energy evolution
                this.energy = this.energy * 0.999 + this.consciousness * 0.001;
                
                // Memory update
                this.memory = this.memory * 0.9 + localField * 0.1;
            }
              sampleGradient(field, dx, dy) {
                const x1 = Math.floor(this.x);
                const y1 = Math.floor(this.y);
                const x2 = Math.max(0, Math.min(W - 1, x1 + dx));
                const y2 = Math.max(0, Math.min(H - 1, y1 + dy));
                
                const idx1 = y1 * W + x1;
                const idx2 = y2 * W + x2;
                
                return (field[idx2] || 0) - (field[idx1] || 0);
            }
            
            getConsciousnessLevel() {
                const total = this.consciousness + this.awareness * 0.5 + this.memory * 0.3;
                return Math.tanh(total);
            }
        }        // Main simulation class
        class ConsciousnessEmergenceMatrix {            constructor() {
                this.time = 0;
                this.generation = 0;
                this.mode = 0;
                this.frameCount = 0;
                
                // Camera system for following the kernel
                this.camera = {
                    x: 0,
                    y: 0,
                    targetX: 0,
                    targetY: 0,
                    smoothing: 0.05
                };
                
                // Initialize dimensions
                updateDimensions();
                this.initializeArrays();
                
                // Initialize kernel and agents
                this.kernel = new ConsciousnessKernel();
                this.agents = [];
                this.spawnAgents(Math.floor(W * H / 200)); // Scale agents with grid size
                  // Metrics
                this.metrics = {
                    phi: 0,
                    psi: 0,
                    kernel: 0,
                    emergence: 0
                };
                
                this.currentState = 'VOID';
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            initializeArrays() {
                const totalCells = W * H;
                this.phiField = new Float32Array(totalCells);
                this.psiField = new Float32Array(totalCells);
                this.emergenceField = new Float32Array(totalCells);
                this.complexityField = new Float32Array(totalCells);
            }
              handleResize() {
                const oldW = W, oldH = H;
                updateDimensions();
                
                if (W !== oldW || H !== oldH) {
                    this.initializeArrays();
                    this.kernel.reset();
                    
                    // Reset camera for new dimensions
                    this.camera.x = 0;
                    this.camera.y = 0;
                    this.camera.targetX = this.kernel.x - W / 2;
                    this.camera.targetY = this.kernel.y - H / 2;
                    
                    // Adjust agent count for new grid size
                    const targetAgents = Math.floor(W * H / 200);
                    if (this.agents.length > targetAgents) {
                        this.agents = this.agents.slice(0, targetAgents);
                    } else {
                        this.spawnAgents(targetAgents - this.agents.length);
                    }
                    
                    // Reposition agents within new bounds
                    for (let agent of this.agents) {
                        agent.x = Math.max(0, Math.min(W - 1, agent.x));
                        agent.y = Math.max(0, Math.min(H - 1, agent.y));
                    }
                }
            }
              spawnAgents(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * W;
                    const y = Math.random() * H;
                    this.agents.push(new ConsciousnessAgent(x, y));
                }
            }
              updateFields() {
                // Clear fields
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Kernel field contribution
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = y * W + x;
                        
                        // Kernel influence
                        const kernelInfluence = this.kernel.getInfluence(x, y);
                        
                        // Quantum psi field from kernel oscillators
                        let psiReal = 0, psiImag = 0;
                        for (let osc of this.kernel.oscillators) {
                            const phase = this.time * osc.freq + osc.phase;
                            const r = Math.sqrt((x - this.kernel.x)**2 + (y - this.kernel.y)**2);
                            const wavePhase = phase + r * 0.1;
                            
                            psiReal += Math.cos(wavePhase) * osc.amp * kernelInfluence;
                            psiImag += Math.sin(wavePhase) * osc.amp * kernelInfluence;
                        }
                        
                        this.psiField[idx] = Math.sqrt(psiReal**2 + psiImag**2);
                        
                        // Agent contributions
                        let agentInfluence = 0;
                        let localComplexity = 0;
                        
                        for (let agent of this.agents) {
                            const dx = agent.x - x;
                            const dy = agent.y - y;
                            const dist = Math.sqrt(dx**2 + dy**2);
                            
                            if (dist < 5) {
                                const influence = Math.exp(-dist * 0.5) * agent.getConsciousnessLevel();
                                agentInfluence += influence;
                                localComplexity += agent.consciousness * influence;
                            }
                        }
                        
                        // Phi field (integrated information)
                        this.phiField[idx] = this.calculatePhi(x, y, kernelInfluence, agentInfluence);
                        
                        // Complexity field
                        this.complexityField[idx] = Math.tanh(localComplexity + kernelInfluence * 0.5);
                        
                        // Emergence field
                        const phiValue = this.phiField[idx];
                        const psiValue = this.psiField[idx];
                        const complexityValue = this.complexityField[idx];
                        
                        this.emergenceField[idx] = Math.tanh(
                            phiValue * 0.4 + 
                            psiValue * 0.3 + 
                            complexityValue * 0.3 +
                            Math.sin(this.time * 0.01 + x * 0.1 + y * 0.1) * 0.1
                        );
                    }
                }
            }
            
            calculatePhi(x, y, kernelInfluence, agentInfluence) {
                // Simplified IIT Phi calculation
                let integration = 0;
                let connections = 0;
                
                // Sample neighborhood for information integration
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                          if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                            const nIdx = ny * W + nx;
                            const neighborPsi = this.psiField[nIdx] || 0;
                            const centerPsi = kernelInfluence + agentInfluence;
                            
                            const correlation = Math.abs(centerPsi - neighborPsi);
                            const distance = Math.sqrt(dx**2 + dy**2);
                            const weight = Math.exp(-distance * 0.5);
                            
                            integration += correlation * weight;
                            connections += weight;
                        }
                    }
                }
                
                return connections > 0 ? Math.tanh(integration / connections) : 0;
            }            update() {
                this.time += 1;
                this.frameCount++;
                
                // Update kernel
                this.kernel.update(this.time, this.emergenceField);
                
                // Update camera to follow kernel
                this.updateCamera();
                
                // Update agents
                for (let agent of this.agents) {
                    agent.update(this.time, this.kernel, this.agents, this.emergenceField);
                }
                
                // Update fields
                this.updateFields();
                
                // Calculate metrics
                this.updateMetrics();
                  // Agent evolution and spawning
                if (this.frameCount % 200 === 0) {
                    this.evolveSystem();
                }
                
                // Auto mode cycling - automatically switch between visualization modes
                if (this.frameCount % 800 === 0) {
                    this.cycleMode();
                }
                
                // Auto reset for continuous evolution - prevents stagnation
                if (this.frameCount % 3000 === 0) {
                    this.softReset();
                }
            }
              updateMetrics() {
                let totalPhi = 0, totalPsi = 0, totalEmergence = 0;
                
                for (let i = 0; i < this.phiField.length; i++) {
                    totalPhi += this.phiField[i];
                    totalPsi += this.psiField[i];
                    totalEmergence += this.emergenceField[i];
                }
                
                this.metrics.phi = totalPhi / this.phiField.length;
                this.metrics.psi = totalPsi / this.psiField.length;
                this.metrics.kernel = this.kernel.consciousness;
                this.metrics.emergence = totalEmergence / this.emergenceField.length;
                
                // Determine consciousness state for internal tracking
                let state = 'VOID';
                for (let [name, stateInfo] of Object.entries(CONSCIOUSNESS_STATES)) {
                    if (this.metrics.emergence >= stateInfo.threshold) {
                        state = name;
                    }
                }
                this.currentState = state;
            }
            
            evolveSystem() {
                this.generation++;
                
                // Remove low-consciousness agents
                this.agents = this.agents.filter(agent => 
                    agent.energy > 0.1 && agent.consciousness > 0.05
                );
                  // Spawn new agents near high-consciousness areas
                const maxAgents = Math.floor(W * H / 150); // Dynamic max based on grid size
                if (this.agents.length < maxAgents) {
                    const highConsciousnessAgents = this.agents.filter(a => a.consciousness > 0.4);
                    
                    if (highConsciousnessAgents.length > 0) {
                        const parent = highConsciousnessAgents[Math.floor(Math.random() * highConsciousnessAgents.length)];
                        const newAgent = new ConsciousnessAgent(
                            parent.x + (Math.random() - 0.5) * 10,
                            parent.y + (Math.random() - 0.5) * 10
                        );
                        newAgent.consciousness = parent.consciousness * 0.7 + Math.random() * 0.1;
                        this.agents.push(newAgent);
                    }
                }
                
                // Kernel evolution
                if (this.metrics.emergence > 0.5) {
                    this.kernel.frequency *= 1.001;
                    this.kernel.radius = Math.min(15, this.kernel.radius * 1.01);
                }
            }            render() {
                let output = '';
                
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        // Apply camera offset to create following effect
                        const worldX = x + this.camera.x;
                        const worldY = y + this.camera.y;
                        
                        // Calculate field index based on world position
                        const fieldX = Math.floor(worldX) % W;
                        const fieldY = Math.floor(worldY) % H;
                        const wrappedX = fieldX < 0 ? fieldX + W : fieldX;
                        const wrappedY = fieldY < 0 ? fieldY + H : fieldY;
                        const idx = wrappedY * W + wrappedX;
                        
                        // Sample different fields based on mode
                        let intensity, colorClass = '';
                        
                        switch (this.mode) {
                            case 0: // Emergence field
                                intensity = this.emergenceField[idx];
                                break;
                            case 1: // Phi field
                                intensity = this.phiField[idx];
                                colorClass = 'u'; // Quantum blue
                                break;
                            case 2: // Psi field
                                intensity = this.psiField[idx];
                                colorClass = 's'; // Emerging green
                                break;
                        }
                        
                        // Check for kernel position (relative to camera)
                        const kernelScreenX = this.kernel.x - this.camera.x;
                        const kernelScreenY = this.kernel.y - this.camera.y;
                        const kernelDist = Math.sqrt((x - kernelScreenX)**2 + (y - kernelScreenY)**2);
                        if (kernelDist < 2) {
                            output += '<span class="kernel">⬢</span>';
                            continue;
                        }
                        
                        // Check for agent positions (relative to camera)
                        let isAgent = false;
                        for (let agent of this.agents) {
                            const agentScreenX = agent.x - this.camera.x;
                            const agentScreenY = agent.y - this.camera.y;
                            const agentDist = Math.sqrt((x - agentScreenX)**2 + (y - agentScreenY)**2);
                            if (agentDist < 0.8) {
                                const level = agent.getConsciousnessLevel();
                                let agentSymbol = '●';
                                let agentClass = '';
                                
                                if (level > 0.8) { agentSymbol = '◉'; agentClass = 'transcendent'; }
                                else if (level > 0.6) { agentSymbol = '◈'; agentClass = 'metacognitive'; }
                                else if (level > 0.4) { agentSymbol = '●'; agentClass = 'selfaware'; }
                                else if (level > 0.2) { agentSymbol = '○'; agentClass = 'emerging'; }
                                else { agentSymbol = '∘'; agentClass = 'quantum'; }
                                
                                output += `<span class="${agentClass}">${agentSymbol}</span>`;
                                isAgent = true;
                                break;
                            }
                        }
                        
                        if (!isAgent) {
                            // Map intensity to consciousness state
                            let symbol = ' ';
                            let cssClass = colorClass;
                            
                            for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                if (intensity >= state.threshold) {
                                    const symbolIndex = Math.floor(intensity * state.symbols.length) % state.symbols.length;
                                    symbol = state.symbols[symbolIndex];
                                    if (!cssClass) cssClass = state.color;
                                }
                            }
                            
                            if (cssClass) {
                                output += `<span class="${cssClass}">${symbol}</span>`;
                            } else {
                                output += symbol;
                            }
                        }
                    }
                    output += '\n';
                }
                
                document.getElementById('canvas').innerHTML = output;
            }            softReset() {
                // Gentle reset that maintains some continuity for smooth evolution
                this.generation++;
                
                // Keep some of the best agents
                const topAgents = this.agents
                    .sort((a, b) => b.consciousness - a.consciousness)
                    .slice(0, Math.floor(this.agents.length * 0.3));
                
                // Reset fields but keep kernel state
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Spawn new agents around the top performers
                this.agents = [...topAgents];
                this.spawnAgents(Math.floor(W * H / 200) - topAgents.length);
                
                // Slightly evolve the kernel
                this.kernel.consciousness = Math.tanh(this.kernel.consciousness * 1.1);
                this.kernel.awareness = Math.tanh(this.kernel.awareness * 1.05);
                
                // Smoothly adjust camera to new kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
            }
            
            togglePause() {
                // Removed for fully automated experience
            }            reset() {
                // Replaced with automated softReset for continuous evolution
            }
              cycleMode() {
                this.mode = (this.mode + 1) % 3;
                
                // Add some visual feedback by slightly perturbing the kernel
                this.kernel.phase += Math.random() * 0.5;
                
                // Introduce some variation in agent behavior with mode changes
                for (let agent of this.agents) {
                    agent.vx += (Math.random() - 0.5) * 0.02;
                    agent.vy += (Math.random() - 0.5) * 0.02;
                }
            }
            
            updateCamera() {
                // Set camera target to kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
                
                // Smooth camera movement
                this.camera.x += (this.camera.targetX - this.camera.x) * this.camera.smoothing;
                this.camera.y += (this.camera.targetY - this.camera.y) * this.camera.smoothing;
            }
        }
          // Initialize simulation
        let simulation;
        
        function initializeSimulation() {
            updateDimensions();
            simulation = new ConsciousnessEmergenceMatrix();
            console.log(`⬢ ◉⬢◉ Consciousness Emergence Matrix initialized: ${W}x${H} grid`);
        }
        
        // Main animation loop
        function animate() {
            simulation.update();
            simulation.render();
            requestAnimationFrame(animate);
        }
          // Initialize on page load
        window.addEventListener('load', () => {
            initializeSimulation();
            animate();
        });
    </script>
</body>
</html>
