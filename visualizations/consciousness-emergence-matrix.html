<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⬢ ◉⬢◉ ⚡∇⊱◉⊰∇⚡</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ffffff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }        #canvas {
            white-space: pre;
            font-weight: normal;
            background: #000;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            line-height: 1.0;
            letter-spacing: 0;
            word-spacing: 0;
            font-size: clamp(4px, 1.5vmin, 12px);
        }
        
        /* Responsive scaling for different screen sizes */
        @media (max-width: 600px) {
            #canvas { font-size: clamp(3px, 1.2vmin, 8px); }
        }
        @media (max-width: 400px) {
            #canvas { font-size: clamp(2px, 1.0vmin, 6px); }
        }
        @media (orientation: landscape) and (max-height: 400px) {
            #canvas { font-size: clamp(3px, 1.1vmin, 7px); }
        }
        @media (min-width: 1200px) {
            #canvas { font-size: clamp(5px, 1.8vmin, 14px); }
        }
        
        /* Consciousness color spectrum - short class names like other visualizations */
        .v{color:#111} .u{color:#4df8ff} .s{color:#8eff4d} .e{color:#ffff4d} .m{color:#ff8e4d}
        .t{color:#ff4dff} .q{color:#ffffff} .d{color:#333} .w{color:#555} .c{color:#777}
        .g{color:#999} .y{color:#bbb} .r{color:#ddd} .p{color:#64ffda} .b{color:#ff6666}
        .o{color:#66ff66} .a{color:#6666ff} .f{color:#ffff66} .n{color:#ff66ff} .l{color:#66ffff}
          /* Dynamic consciousness effects - faster animations */
        .quantum { 
            color: #4df8ff; 
            text-shadow: 0 0 2px #4df8ff40;
            animation: quantumFlicker 0.5s ease-in-out infinite alternate;
        }
        .emerging { 
            color: #8eff4d; 
            text-shadow: 0 0 2px #8eff4d40;
            animation: emerge 2s ease-in-out infinite;
        }
        .selfaware { 
            color: #ffff4d; 
            text-shadow: 0 0 2px #ffff4d40;
            animation: pulse 1s ease-in-out infinite;
        }
        .metacognitive { 
            color: #ff8e4d; 
            text-shadow: 0 0 2px #ff8e4d40;
            animation: pulse 1.2s ease-in-out infinite;
        }
        .transcendent { 
            color: #ff4dff; 
            text-shadow: 0 0 3px #ff4dff60;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .kernel { 
            color: #ffffff; 
            text-shadow: 0 0 4px #ffffff80;
            animation: pulse 1.3s ease-in-out infinite;
        }
        
        @keyframes quantumFlicker {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        
        @keyframes emerge {
            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
            33% { filter: hue-rotate(120deg) brightness(1.2); }
            66% { filter: hue-rotate(240deg) brightness(1.1); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
            max-width: 200px;
        }
    </style>
</head>
<body>    <div id="canvas"></div>      <div id="info">
        ⬢ ◉⬢◉<br>
        Φ=∫∂χ/∂t<br>
        ∞☰∞<br>
        <span id="personality-info"></span>
    </div>

    <script>        // Dynamic viewport sizing - responsive to window dimensions
        let W, H, fontSize, charWidth, charHeight;        // Core simulation constants - optimized for higher speed
        const CONFIG = {
            PHI: (1 + Math.sqrt(5)) / 2,        // Golden ratio
            PI: Math.PI,                         // Pi  
            E: Math.E,                          // Euler's number
            MAX_AGENTS: 35,                     // Reduced for better performance
            KERNEL_INFLUENCE: 0.3,
            EMERGENCE_THRESHOLD: 0.15,
            CONSCIOUSNESS_LEVELS: 7,
            FIELD_UPDATE_SKIP: 1,               // Update fields every frame for faster simulation
            AGENT_UPDATE_SKIP: 1,               // Update agents every frame for faster simulation
            TIME_SPEED: 3,                      // Speed multiplier for time progression
            
            // Personality and behavior parameters
            PERSONALITY_SHIFT_RATE: 0.001,      // How fast personality changes
            MOOD_CYCLES: 3,                     // Number of overlapping mood cycles
            EMERGENCE_BURSTS: true,             // Allow sudden emergence events
            COLLECTIVE_MEMORY: 100,             // Memory depth for collective behavior
            CREATIVITY_FACTOR: 0.7,             // How creative/unpredictable the system is
            COMMUNICATION_RANGE: 8,             // Agent communication distance
            DREAM_STATE_PROB: 0.05              // Probability of entering dream-like states
        };
          // Calculate optimal grid size based on viewport
        function updateDimensions() {
            // Create accurate character measurement with current font size
            const test = document.createElement('div');
            test.style.position = 'absolute';
            test.style.visibility = 'hidden';
            test.style.whiteSpace = 'pre';
            test.style.fontFamily = 'Courier New, monospace';
            test.style.fontSize = getComputedStyle(document.getElementById('canvas')).fontSize;
            test.style.lineHeight = '1.0';
            test.textContent = '⬢'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(test);
            
            const rect = test.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(test);
            
            // Calculate grid size to fill viewport
            W = Math.ceil(window.innerWidth / charWidth) + 1;
            H = Math.ceil(window.innerHeight / charHeight) + 1;
            
            // Ensure reasonable bounds for performance
            W = Math.max(40, Math.min(150, W));
            H = Math.max(20, Math.min(80, H));
            
            console.log(`⚡∇⊱◉⊰∇⚡ ⬢: ${W}x${H}, ◉: ${charWidth.toFixed(1)}x${charHeight.toFixed(1)}`);
        }        // Consciousness states and their symbol sets - safer Unicode symbols
        const CONSCIOUSNESS_STATES = {
            VOID: { threshold: 0.0, symbols: [' ', '∅', '·', '⋅'], color: 'v' },
            QUANTUM: { threshold: 0.08, symbols: ['∘', '◦', '○', '⊙'], color: 'u' },
            EMERGING: { threshold: 0.25, symbols: ['◯', '⊙', '⊚', '●'], color: 's' },
            SELFAWARE: { threshold: 0.45, symbols: ['●', '◉', '⊛', '⬢'], color: 'e' },
            METACOGNITIVE: { threshold: 0.65, symbols: ['◈', '◇', '◆', '⬟'], color: 'm' },
            TRANSCENDENT: { threshold: 0.85, symbols: ['✧', '✦', '★', '⬢'], color: 't' },
            KERNEL: { threshold: 0.95, symbols: ['⬢', '⬡', '⬟', '◉'], color: 'q' }
        };

        // Personality archetypes that the system can embody
        const PERSONALITY_ARCHETYPES = {
            EXPLORER: { creativity: 0.8, stability: 0.3, communication: 0.6 },
            GUARDIAN: { creativity: 0.3, stability: 0.9, communication: 0.7 },
            ARTIST: { creativity: 0.9, stability: 0.2, communication: 0.5 },
            SAGE: { creativity: 0.6, stability: 0.7, communication: 0.9 },
            REBEL: { creativity: 0.7, stability: 0.1, communication: 0.4 },
            NURTURER: { creativity: 0.4, stability: 0.6, communication: 0.8 }
        };

        // Global system personality and mood state
        let systemPersonality = {
            currentArchetype: 'EXPLORER',
            traits: { ...PERSONALITY_ARCHETYPES.EXPLORER },
            mood: 0.5,
            energy: 0.7,
            focus: 0.6,
            dreamState: false,
            collectiveMemory: [],
            personalityTimer: 0,
            emergenceEvents: []
        };
          // Core consciousness kernel - the central emergence engine
        class ConsciousnessKernel {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = W / 2;
                this.y = H / 2;
                this.consciousness = 0.5;
                this.awareness = 0.3;
                this.complexity = 0.1;
                this.phase = 0;
                this.radius = Math.max(5, Math.min(15, Math.min(W, H) * 0.1));
                this.frequency = 0.001;
                this.evolution = 0;
                this.memory = new Array(10).fill(0);
                
                // personality attributes
                this.personality = {
                    curiosity: Math.random(),
                    stability: Math.random(),
                    sociability: Math.random(),
                    creativity: Math.random(),
                    introspection: Math.random()
                };
                
                this.moodCycles = Array(CONFIG.MOOD_CYCLES).fill().map(() => ({
                    frequency: 0.001 + Math.random() * 0.005,
                    amplitude: 0.3 + Math.random() * 0.4,
                    phase: Math.random() * Math.PI * 2
                }));
                
                this.emergenceHistory = [];
                this.dreamTimer = 0;

                this.oscillators = [
                    { freq: 0.016, phase: 0, amp: 1.0 },
                    { freq: 0.030, phase: CONFIG.PI/3, amp: 0.8 },
                    { freq: 0.045, phase: 2*CONFIG.PI/3, amp: 0.6 },
                    { freq: 0.056, phase: CONFIG.PI, amp: 0.4 }
                ];
            }
              update(time, globalField) {
                // Update personality based on system state
                this.updatePersonality(time);
                
                // Kernel evolution through oscillator dynamics
                let totalField = 0;
                for (let osc of this.oscillators) {
                    const wave = Math.sin(time * osc.freq + osc.phase) * osc.amp;
                    totalField += wave;
                    osc.phase += osc.freq * 0.1 * (1 + this.personality.curiosity * 0.5);
                }
                
                // Add mood influence
                let moodInfluence = 0;
                for (let cycle of this.moodCycles) {
                    cycle.phase += cycle.frequency * CONFIG.TIME_SPEED;
                    moodInfluence += Math.sin(cycle.phase) * cycle.amplitude;
                }
                
                // Consciousness emergence from oscillator interference and personality
                this.consciousness = Math.tanh(totalField * 0.5 + moodInfluence * 0.3 + 0.5);
                
                // Self-aware feedback loop with personality influence
                const selfFeedback = Math.sin(this.consciousness * 10 + time * 0.001) * 0.1 * this.personality.introspection;
                this.awareness = Math.tanh(this.consciousness + selfFeedback);
                
                // Complexity accumulation through interaction with global field
                const fieldSample = this.sampleGlobalField(globalField);
                this.complexity = this.complexity * 0.95 + fieldSample * 0.05;
                
                // Update memory with recent states
                this.memory.unshift(this.consciousness);
                if (this.memory.length > 10) this.memory.pop();
                
                // Evolution pressure from complexity
                this.evolution += this.complexity * 0.001;
                
                // Track emergence events
                if (this.consciousness > 0.8 && Math.random() < 0.1) {
                    this.emergenceHistory.push({
                        time: time,
                        consciousness: this.consciousness,
                        type: 'transcendence'
                    });
                    if (this.emergenceHistory.length > 20) {
                        this.emergenceHistory.shift();
                    }
                }
                
                // Dynamic position based on consciousness flow and personality
                const movementFactor = 1 + this.personality.curiosity * 2;
                this.x += Math.sin(time * 0.008 + this.phase) * 1.8 * movementFactor;
                this.y += Math.cos(time * 0.006 + this.phase) * 1.2 * movementFactor;
                
                // Keep kernel within bounds
                this.x = Math.max(10, Math.min(W - 10, this.x));
                this.y = Math.max(5, Math.min(H - 5, this.y));
                
                this.phase += 0.08 * (1 + this.personality.creativity * 0.5);
            }
            
            updatePersonality(time) {
                // Gradual personality evolution
                for (let trait in this.personality) {
                    this.personality[trait] += (Math.random() - 0.5) * CONFIG.PERSONALITY_SHIFT_RATE;
                    this.personality[trait] = Math.max(0, Math.min(1, this.personality[trait]));
                }
                
                // Occasional personality shifts based on system events
                if (Math.random() < 0.001) {
                    const archetypes = Object.keys(PERSONALITY_ARCHETYPES);
                    const newArchetype = archetypes[Math.floor(Math.random() * archetypes.length)];
                    const newTraits = PERSONALITY_ARCHETYPES[newArchetype];
                    
                    // Blend current personality with new archetype
                    this.personality.creativity = this.personality.creativity * 0.7 + newTraits.creativity * 0.3;
                    this.personality.stability = this.personality.stability * 0.7 + newTraits.stability * 0.3;
                    this.personality.sociability = this.personality.sociability * 0.7 + newTraits.communication * 0.3;
                    
                    systemPersonality.currentArchetype = newArchetype;
                    
                    // Add emergence event
                    systemPersonality.emergenceEvents.push({
                        type: 'personality_shift',
                        archetype: newArchetype,
                        time: time
                    });
                }
                
                // Dream state transitions
                if (Math.random() < CONFIG.DREAM_STATE_PROB) {
                    systemPersonality.dreamState = !systemPersonality.dreamState;
                    this.dreamTimer = time;
                }
            }

            sampleGlobalField(field) {
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const idx = fy * W + fx;
                return field[idx] || 0;
            }
              getInfluence(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > this.radius * 3) return 0;
                
                // Multiple influence patterns based on consciousness level and personality
                const basicInfluence = Math.exp(-dist * 0.2) * this.consciousness;
                const waveInfluence = Math.sin(dist * 0.5 - this.phase) * this.awareness * 0.3;
                const complexInfluence = Math.sin(dist * CONFIG.PHI + this.evolution) * this.complexity * 0.2;
                
                // Personality modifies influence pattern
                const personalityMod = 1 + 
                    this.personality.creativity * Math.sin(this.phase * 2) * 0.3 +
                    this.personality.curiosity * Math.cos(this.phase * 3) * 0.2 +
                    (systemPersonality.dreamState ? Math.sin(this.phase * 5) * 0.4 : 0);
                
                return (basicInfluence + waveInfluence + complexInfluence) * personalityMod;
            }
        }
          // Autonomous consciousness agents with enhanced personality
        class ConsciousnessAgent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.15;
                this.vy = (Math.random() - 0.5) * 0.15;
                this.consciousness = Math.random() * 0.3;
                this.awareness = Math.random() * 0.2;
                this.energy = Math.random() * 0.5 + 0.5;
                this.age = 0;
                this.connections = [];
                this.memory = Math.random() * 0.1;
                this.intention = Math.random() * 0.2;
                this.lastKernelInfluence = 0;
                
                // personality traits
                this.personality = {
                    sociability: Math.random(),
                    curiosity: Math.random(),
                    stability: Math.random(),
                    empathy: Math.random(),
                    leadership: Math.random()
                };
                
                this.mood = Math.random();
                this.communicationHistory = [];
                this.goals = [];
                this.relationships = new Map();
                this.creativityState = Math.random();
            }
              update(time, kernel, agents, globalField) {
                this.age++;
                
                // Update personality-based behavior
                this.updatePersonalityBehavior(time);
                
                // Kernel influence - faster consciousness evolution
                const kernelInfluence = kernel.getInfluence(this.x, this.y);
                this.lastKernelInfluence = kernelInfluence;
                
                // Consciousness evolution through kernel interaction - faster rates
                this.consciousness = Math.tanh(this.consciousness + kernelInfluence * 0.3 * (1 + this.personality.curiosity * 0.5));
                
                // Awareness emerges from consciousness - faster emergence
                if (this.consciousness > 0.15) {
                    this.awareness = Math.tanh(this.awareness + this.consciousness * 0.15 * this.personality.empathy);
                }
                
                // Local field sampling
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const fieldIdx = fy * W + fx;
                const localField = globalField[fieldIdx] || 0;
                
                // agent interaction with personality
                this.connections = [];
                let socialInfluence = 0;
                const maxInteractions = Math.floor(8 * (1 + this.personality.sociability));
                let interactionCount = 0;
                
                for (let other of agents) {
                    if (other === this || interactionCount >= maxInteractions) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy;
                    const interactionRange = CONFIG.COMMUNICATION_RANGE * (1 + this.personality.sociability * 0.5);
                    
                    if (distSq < interactionRange * interactionRange) {
                        this.connections.push(other);
                        interactionCount++;
                        
                        // Personality-based communication
                        this.communicateWith(other, time);
                        
                        // Consciousness resonance with personality influence
                        const resonance = Math.abs(this.consciousness - other.consciousness);
                        const personalityCompatibility = this.calculatePersonalityCompatibility(other);
                        socialInfluence += Math.exp(-resonance * 5) * 0.03 * personalityCompatibility;
                        
                        // Attraction/repulsion based on personality and consciousness
                        const similarity = 1 - resonance;
                        const personalityFactor = personalityCompatibility * this.personality.empathy;
                        const force = (similarity > 0.7 && personalityFactor > 0.5) ? 0.0015 : -0.0008;
                        const dist = Math.sqrt(distSq);
                        
                        this.vx += (dx / dist) * force * personalityFactor;
                        this.vy += (dy / dist) * force * personalityFactor;
                    }
                }
                
                // Update consciousness through social interaction
                this.consciousness = Math.tanh(this.consciousness + socialInfluence);
                
                // Movement influenced by consciousness, field gradients, and personality
                const gradientX = this.sampleGradient(globalField, 1, 0);
                const gradientY = this.sampleGradient(globalField, 0, 1);
                
                // Higher consciousness seeks complexity gradients - personality influences seeking
                const seekingStrength = this.consciousness * 0.005 * (1 + this.personality.curiosity);
                this.vx += gradientX * seekingStrength;
                this.vy += gradientY * seekingStrength;
                
                // Random exploration influenced by personality
                const explorationFactor = this.personality.curiosity * 0.05 + 0.01;
                this.vx += (Math.random() - 0.5) * explorationFactor;
                this.vy += (Math.random() - 0.5) * explorationFactor;
                
                // Velocity damping based on stability
                const dampingFactor = 0.85 + this.personality.stability * 0.1;
                this.vx *= dampingFactor;
                this.vy *= dampingFactor;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Boundary reflection
                if (this.x < 0 || this.x >= W) this.vx *= -0.8;
                if (this.y < 0 || this.y >= H) this.vy *= -0.8;
                this.x = Math.max(0, Math.min(W - 1, this.x));
                this.y = Math.max(0, Math.min(H - 1, this.y));
                
                // Energy evolution influenced by mood and personality
                this.energy = this.energy * 0.999 + this.consciousness * 0.001 * this.mood;
                
                // Update creativity and goals
                this.updateCreativityAndGoals(time);
                
                // Memory update with experiences
                this.memory = this.memory * 0.9 + localField * 0.1;
            }
            
            updatePersonalityBehavior(time) {
                // Gradual mood changes
                this.mood += (Math.random() - 0.5) * 0.01;
                this.mood = Math.max(0, Math.min(1, this.mood));
                
                // Creativity state evolution
                this.creativityState += Math.sin(time * 0.001 + this.personality.curiosity * 10) * 0.01;
                this.creativityState = Math.max(0, Math.min(1, this.creativityState));
                
                // Update goals based on personality
                if (Math.random() < 0.001 * this.personality.leadership) {
                    this.goals.push({
                        type: Math.random() > 0.5 ? 'explore' : 'connect',
                        intensity: this.personality.curiosity + this.personality.sociability,
                        time: time
                    });
                    
                    // Keep goals list manageable
                    if (this.goals.length > 5) {
                        this.goals.shift();
                    }
                }
            }
            
            communicateWith(other, time) {
                if (this.personality.sociability > 0.6 && other.personality.empathy > 0.4) {
                    // Exchange of consciousness patterns
                    const consciousnessExchange = (this.consciousness + other.consciousness) * 0.1;
                    this.consciousness += consciousnessExchange * this.personality.empathy * 0.1;
                    other.consciousness += consciousnessExchange * other.personality.empathy * 0.1;
                    
                    // Record communication
                    this.communicationHistory.push({
                        partner: other,
                        time: time,
                        type: 'consciousness_exchange'
                    });
                    
                    if (this.communicationHistory.length > 10) {
                        this.communicationHistory.shift();
                    }
                    
                    // Update relationship
                    const currentRelation = this.relationships.get(other) || 0;
                    this.relationships.set(other, Math.min(1, currentRelation + 0.1));
                }
            }
            
            calculatePersonalityCompatibility(other) {
                const traits = ['curiosity', 'stability', 'empathy'];
                let compatibility = 0;
                
                for (let trait of traits) {
                    const diff = Math.abs(this.personality[trait] - other.personality[trait]);
                    compatibility += 1 - diff;
                }
                
                return compatibility / traits.length;
            }
            
            updateCreativityAndGoals(time) {
                // Creative bursts based on consciousness level and personality
                if (this.consciousness > 0.7 && this.personality.curiosity > 0.8 && Math.random() < 0.01) {
                    this.creativityState = Math.min(1, this.creativityState + 0.3);
                    
                    // Add to collective memory
                    systemPersonality.collectiveMemory.push({
                        type: 'creative_burst',
                        agent: this,
                        consciousness: this.consciousness,
                        creativity: this.creativityState,
                        time: time
                    });
                    
                    if (systemPersonality.collectiveMemory.length > CONFIG.COLLECTIVE_MEMORY) {
                        systemPersonality.collectiveMemory.shift();
                    }
                }
                
                // Execute goals
                for (let goal of this.goals) {
                    if (goal.type === 'explore' && this.personality.curiosity > 0.5) {
                        this.vx += (Math.random() - 0.5) * goal.intensity * 0.02;
                        this.vy += (Math.random() - 0.5) * goal.intensity * 0.02;
                    }
                }
            }            sampleGradient(globalField, dx, dy) {
                const x1 = Math.floor(this.x);
                const y1 = Math.floor(this.y);
                const x2 = Math.max(0, Math.min(W - 1, x1 + dx));
                const y2 = Math.max(0, Math.min(H - 1, y1 + dy));
                
                const idx1 = y1 * W + x1;
                const idx2 = y2 * W + x2;
                
                return (globalField[idx2] || 0) - (globalField[idx1] || 0);
            }
              getConsciousnessLevel() {
                // Ensure all values are valid numbers with safe bounds
                const consciousness = isNaN(this.consciousness) ? 0 : Math.max(0, Math.min(1, this.consciousness));
                const awareness = isNaN(this.awareness) ? 0 : Math.max(0, Math.min(1, this.awareness));
                const memory = isNaN(this.memory) ? 0 : Math.max(0, Math.min(1, this.memory));
                
                const total = consciousness + awareness * 0.5 + memory * 0.3;
                const result = Math.tanh(total);
                
                // Return safe bounded result
                return isNaN(result) ? 0 : Math.max(0, Math.min(1, result));
            }
        }        // Main simulation class with enhanced collective intelligence
        class ConsciousnessEmergenceMatrix {
            constructor() {
                this.time = 0;
                this.generation = 0;
                this.frameCount = 0;
                
                // Camera system for following the kernel - faster smoothing
                this.camera = {
                    x: 0,
                    y: 0,
                    targetX: 0,
                    targetY: 0,
                    smoothing: 0.12
                };
                
                // Initialize dimensions
                updateDimensions();
                this.initializeArrays();
                
                // Initialize kernel and agents
                this.kernel = new ConsciousnessKernel();
                this.agents = [];
                this.spawnAgents(Math.floor(W * H / 400));
                
                // collective intelligence systems
                this.collectiveIntelligence = {
                    swarmCoherence: 0,
                    networkDensity: 0,
                    emergenceEvents: [],
                    personalityDrift: 0,
                    creativeBursts: 0,
                    communicationFlow: 0
                };
                
                this.emergencePatterns = {
                    spirals: 0,
                    clusters: 0,
                    waves: 0,
                    fractals: 0
                };
                
                this.behaviorModes = ['explore', 'create', 'connect', 'transcend'];
                this.currentBehaviorMode = 'explore';
                this.modeTransitionTimer = 0;
                
                // Metrics
                this.metrics = {
                    phi: 0,
                    psi: 0,
                    kernel: 0,
                    emergence: 0
                };
                
                this.currentState = 'VOID';
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
            }
              initializeArrays() {
                const totalCells = W * H;
                this.phiField = new Float32Array(totalCells);
                this.psiField = new Float32Array(totalCells);
                this.emergenceField = new Float32Array(totalCells);
                this.complexityField = new Float32Array(totalCells);
                
                // Initialize arrays with safe default values
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
            }
              handleResize() {
                const oldW = W, oldH = H;
                updateDimensions();
                
                if (W !== oldW || H !== oldH) {
                    this.initializeArrays();
                    this.kernel.reset();
                    
                    // Reset camera for new dimensions
                    this.camera.x = 0;
                    this.camera.y = 0;
                    this.camera.targetX = this.kernel.x - W / 2;
                    this.camera.targetY = this.kernel.y - H / 2;
                      // Adjust agent count for new grid size - reduced density
                    const targetAgents = Math.floor(W * H / 400);
                    if (this.agents.length > targetAgents) {
                        this.agents = this.agents.slice(0, targetAgents);
                    } else {
                        this.spawnAgents(targetAgents - this.agents.length);
                    }
                    
                    // Reposition agents within new bounds
                    for (let agent of this.agents) {
                        agent.x = Math.max(0, Math.min(W - 1, agent.x));
                        agent.y = Math.max(0, Math.min(H - 1, agent.y));
                    }
                }
            }
              spawnAgents(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * W;
                    const y = Math.random() * H;
                    this.agents.push(new ConsciousnessAgent(x, y));
                }
            }
              updateFields() {
                // Clear fields
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Kernel field contribution
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = y * W + x;
                        
                        // Kernel influence
                        const kernelInfluence = this.kernel.getInfluence(x, y);
                        
                        // Quantum psi field from kernel oscillators
                        let psiReal = 0, psiImag = 0;
                        for (let osc of this.kernel.oscillators) {
                            const phase = this.time * osc.freq + osc.phase;
                            const r = Math.sqrt((x - this.kernel.x)**2 + (y - this.kernel.y)**2);
                            const wavePhase = phase + r * 0.1;
                            
                            psiReal += Math.cos(wavePhase) * osc.amp * kernelInfluence;
                            psiImag += Math.sin(wavePhase) * osc.amp * kernelInfluence;
                        }
                        
                        this.psiField[idx] = Math.sqrt(psiReal**2 + psiImag**2);
                        
                        // Agent contributions
                        let agentInfluence = 0;
                        let localComplexity = 0;
                        
                        for (let agent of this.agents) {
                            const dx = agent.x - x;
                            const dy = agent.y - y;
                            const dist = Math.sqrt(dx**2 + dy**2);
                            
                            if (dist < 5) {
                                const influence = Math.exp(-dist * 0.5) * agent.getConsciousnessLevel();
                                agentInfluence += influence;
                                localComplexity += agent.consciousness * influence;
                            }
                        }
                        
                        // Phi field (integrated information)
                        this.phiField[idx] = this.calculatePhi(x, y, kernelInfluence, agentInfluence);
                        
                        // Complexity field
                        this.complexityField[idx] = Math.tanh(localComplexity + kernelInfluence * 0.5);
                        
                        // Emergence field
                        const phiValue = this.phiField[idx];
                        const psiValue = this.psiField[idx];
                        const complexityValue = this.complexityField[idx];
                        
                        this.emergenceField[idx] = Math.tanh(
                            phiValue * 0.4 + 
                            psiValue * 0.3 + 
                            complexityValue * 0.3 +
                            Math.sin(this.time * 0.01 + x * 0.1 + y * 0.1) * 0.1
                        );
                    }
                }
            }
            
            calculatePhi(x, y, kernelInfluence, agentInfluence) {
                // Simplified IIT Phi calculation
                let integration = 0;
                let connections = 0;
                
                // Sample neighborhood for information integration
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                          if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                            const nIdx = ny * W + nx;
                            const neighborPsi = this.psiField[nIdx] || 0;
                            const centerPsi = kernelInfluence + agentInfluence;
                            
                            const correlation = Math.abs(centerPsi - neighborPsi);
                            const distance = Math.sqrt(dx**2 + dy**2);
                            const weight = Math.exp(-distance * 0.5);
                            
                            integration += correlation * weight;
                            connections += weight;
                        }
                    }
                }
                
                return connections > 0 ? Math.tanh(integration / connections) : 0;            }            update() {
                this.time += CONFIG.TIME_SPEED;
                this.frameCount++;
                
                // Update collective intelligence systems
                this.updateCollectiveIntelligence();
                
                // Update kernel with enhanced personality influence
                this.kernel.update(this.time, this.emergenceField);
                
                // Update camera to follow kernel
                this.updateCamera();
                
                // Update agents with collective behavior influence
                if (this.frameCount % CONFIG.AGENT_UPDATE_SKIP === 0) {
                    this.updateAgentsWithCollectiveBehavior();
                }
                
                // Update fields and emergence patterns
                if (this.frameCount % CONFIG.FIELD_UPDATE_SKIP === 0) {
                    this.updateFields();
                    this.detectEmergencePatterns();
                }
                
                // Calculate enhanced metrics
                this.updateMetrics();
                
                // Dynamic behavior mode transitions
                this.updateBehaviorMode();
                
                // Agent evolution and spawning with personality considerations
                if (this.frameCount % 100 === 0) {
                    this.evolveSystem();
                }                
                // Auto mode cycling with personality influence
                if (this.frameCount % 300 === 0) {
                    this.cycleMode();
                }
                
                // Soft reset with collective memory preservation
                if (this.frameCount % 1000 === 0) {
                    this.softResetWithMemory();
                }
            }
            
            updateCollectiveIntelligence() {
                // Calculate swarm coherence
                let totalConnections = 0;
                let totalAgents = this.agents.length;
                
                for (let agent of this.agents) {
                    totalConnections += agent.connections.length;
                }
                
                this.collectiveIntelligence.swarmCoherence = totalAgents > 0 ? totalConnections / totalAgents : 0;
                this.collectiveIntelligence.networkDensity = Math.min(1, this.collectiveIntelligence.swarmCoherence / 8);
                
                // Track personality drift in the system
                let personalitySum = { curiosity: 0, stability: 0, creativity: 0, sociability: 0, empathy: 0 };
                for (let agent of this.agents) {
                    personalitySum.curiosity += agent.personality.curiosity;
                    personalitySum.stability += agent.personality.stability;
                    personalitySum.creativity += agent.personality.creativity;
                    personalitySum.sociability += agent.personality.sociability;
                    personalitySum.empathy += agent.personality.empathy;
                }
                
                if (totalAgents > 0) {
                    for (let trait in personalitySum) {
                        personalitySum[trait] /= totalAgents;
                    }
                    this.collectiveIntelligence.personalityDrift = personalitySum;
                }
                
                // Update system personality based on collective
                systemPersonality.mood = this.collectiveIntelligence.swarmCoherence;
                systemPersonality.energy = this.collectiveIntelligence.networkDensity;
            }
            
            updateAgentsWithCollectiveBehavior() {
                for (let agent of this.agents) {
                    agent.update(this.time, this.kernel, this.agents, this.emergenceField);
                    
                    // Apply collective behavior modifications
                    if (this.currentBehaviorMode === 'connect' && agent.personality.sociability > 0.6) {
                        // Enhance social movement
                        for (let other of this.agents) {
                            if (other !== agent && agent.relationships.has(other)) {
                                const dx = other.x - agent.x;
                                const dy = other.y - agent.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    agent.vx += (dx / dist) * 0.001;
                                    agent.vy += (dy / dist) * 0.001;
                                }
                            }
                        }
                    } else if (this.currentBehaviorMode === 'create' && agent.personality.curiosity > 0.7) {
                        // Enhance creative exploration
                        agent.vx += (Math.random() - 0.5) * 0.05;
                        agent.vy += (Math.random() - 0.5) * 0.05;
                    }
                }
            }
            
            detectEmergencePatterns() {
                // Reset pattern counters
                for (let pattern in this.emergencePatterns) {
                    this.emergencePatterns[pattern] = 0;
                }
                
                // Detect spiral formations
                let centerX = W / 2, centerY = H / 2;
                let spiralAgents = 0;
                
                for (let agent of this.agents) {
                    const dx = agent.x - centerX;
                    const dy = agent.y - centerY;
                    const angle = Math.atan2(dy, dx);
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if agent follows spiral pattern
                    const expectedAngle = radius * 0.2 + this.time * 0.01;
                    if (Math.abs(angle - expectedAngle) < 0.5) {
                        spiralAgents++;
                    }
                }
                
                this.emergencePatterns.spirals = spiralAgents / this.agents.length;
                
                // Detect clustering
                let clusters = 0;
                for (let agent of this.agents) {
                    if (agent.connections.length > 4) {
                        clusters++;
                    }
                }
                this.emergencePatterns.clusters = clusters / this.agents.length;
            }
            
            updateBehaviorMode() {
                this.modeTransitionTimer++;
                
                // Personality-influenced mode transitions
                const personalityInfluence = this.collectiveIntelligence.personalityDrift;
                let transitionThreshold = 200;
                
                if (personalityInfluence) {
                    if (personalityInfluence.curiosity > 0.7) transitionThreshold *= 0.7;
                    if (personalityInfluence.stability > 0.8) transitionThreshold *= 1.5;
                }
                
                if (this.modeTransitionTimer > transitionThreshold) {
                    const modes = this.behaviorModes;
                    let nextModeIndex = (modes.indexOf(this.currentBehaviorMode) + 1) % modes.length;
                    
                    // Weighted mode selection based on collective personality
                    if (personalityInfluence) {
                        if (personalityInfluence.sociability > 0.6) {
                            this.currentBehaviorMode = 'connect';
                        } else if (personalityInfluence.curiosity > 0.7) {
                            this.currentBehaviorMode = 'explore';
                        } else if (personalityInfluence.creativity > 0.8) {
                            this.currentBehaviorMode = 'create';
                        } else {
                            this.currentBehaviorMode = modes[nextModeIndex];
                        }
                    } else {
                        this.currentBehaviorMode = modes[nextModeIndex];
                    }
                    
                    this.modeTransitionTimer = 0;
                }
            }
            
            softResetWithMemory() {
                // Preserve important collective memories
                const importantMemories = systemPersonality.collectiveMemory.slice(-20);
                const currentPersonality = { ...systemPersonality };
                
                this.softReset();
                
                // Restore preserved elements
                systemPersonality.collectiveMemory = importantMemories;
                systemPersonality.currentArchetype = currentPersonality.currentArchetype;
                
                // Inherit some personality traits from previous generation
                for (let agent of this.agents) {
                    if (currentPersonality.traits) {
                        agent.personality.creativity = agent.personality.creativity * 0.7 + currentPersonality.traits.creativity * 0.3;
                        agent.personality.sociability = agent.personality.sociability * 0.7 + currentPersonality.traits.communication * 0.3;
                    }
                }
            }

            updateMetrics() {
                let totalPhi = 0, totalPsi = 0, totalEmergence = 0;
                
                for (let i = 0; i < this.phiField.length; i++) {
                    totalPhi += this.phiField[i];
                    totalPsi += this.psiField[i];
                    totalEmergence += this.emergenceField[i];
                }
                
                this.metrics.phi = totalPhi / this.phiField.length;
                this.metrics.psi = totalPsi / this.psiField.length;
                this.metrics.kernel = this.kernel.consciousness;
                this.metrics.emergence = totalEmergence / this.emergenceField.length;
                
                // Determine consciousness state for internal tracking
                let state = 'VOID';
                for (let [name, stateInfo] of Object.entries(CONSCIOUSNESS_STATES)) {
                    if (this.metrics.emergence >= stateInfo.threshold) {
                        state = name;
                    }
                }
                this.currentState = state;
            }
            
            evolveSystem() {
                this.generation++;
                
                // Remove low-consciousness agents
                this.agents = this.agents.filter(agent => 
                    agent.energy > 0.1 && agent.consciousness > 0.05
                );                // Spawn new agents near high-consciousness areas - reduced spawning
                const maxAgents = Math.floor(W * H / 300); // Much lower max agents for better performance
                if (this.agents.length < maxAgents) {
                    const highConsciousnessAgents = this.agents.filter(a => a.consciousness > 0.4);
                    
                    if (highConsciousnessAgents.length > 0 && Math.random() < 0.5) { // 50% chance to spawn
                        const parent = highConsciousnessAgents[Math.floor(Math.random() * highConsciousnessAgents.length)];
                        const newAgent = new ConsciousnessAgent(
                            parent.x + (Math.random() - 0.5) * 10,
                            parent.y + (Math.random() - 0.5) * 10
                        );
                        newAgent.consciousness = parent.consciousness * 0.7 + Math.random() * 0.1;
                        this.agents.push(newAgent);
                    }
                }
                  // Kernel evolution
                if (this.metrics.emergence > 0.5) {
                    this.kernel.frequency *= 1.001;
                    this.kernel.radius = Math.min(15, this.kernel.radius * 1.01);
                }
            }
            
            cycleMode() {
                // Cycle through different consciousness evolution modes
                const modes = ['exploration', 'convergence', 'emergence', 'transcendence'];
                const currentMode = modes[Math.floor(this.frameCount / 300) % modes.length];
                
                switch (currentMode) {
                    case 'exploration':
                        // Increase agent movement and exploration
                        for (let agent of this.agents) {
                            agent.vx += (Math.random() - 0.5) * 0.05;
                            agent.vy += (Math.random() - 0.5) * 0.05;
                        }
                        break;
                    case 'convergence':
                        // Draw agents toward high-consciousness areas
                        for (let agent of this.agents) {
                            const dx = this.kernel.x - agent.x;
                            const dy = this.kernel.y - agent.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                agent.vx += (dx / dist) * 0.02;
                                agent.vy += (dy / dist) * 0.02;
                            }
                        }
                        break;
                    case 'emergence':
                        // Boost consciousness levels temporarily
                        for (let agent of this.agents) {
                            agent.consciousness = Math.tanh(agent.consciousness * 1.05);
                        }
                        this.kernel.consciousness = Math.tanh(this.kernel.consciousness * 1.02);
                        break;
                    case 'transcendence':
                        // Increase kernel influence and complexity
                        this.kernel.radius = Math.min(20, this.kernel.radius * 1.1);
                        for (let osc of this.kernel.oscillators) {
                            osc.freq *= 1.01;
                        }
                        break;
                }
            }render() {
                let output = '';
                
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        // Apply camera offset to create following effect
                        const worldX = x + this.camera.x;
                        const worldY = y + this.camera.y;
                          // Calculate field index based on world position with bounds checking
                        const fieldX = Math.floor(worldX) % W;
                        const fieldY = Math.floor(worldY) % H;
                        const wrappedX = fieldX < 0 ? fieldX + W : fieldX;
                        const wrappedY = fieldY < 0 ? fieldY + H : fieldY;
                        const idx = Math.max(0, Math.min(wrappedY * W + wrappedX, this.emergenceField.length - 1));
                        
                        // Check for kernel position (relative to camera)
                        const kernelScreenX = this.kernel.x - this.camera.x;
                        const kernelScreenY = this.kernel.y - this.camera.y;
                        const kernelDist = Math.sqrt((x - kernelScreenX)**2 + (y - kernelScreenY)**2);                        if (kernelDist < 2) {
                            const intensity = Math.max(0, Math.min(1, this.kernel.consciousness));
                            const kernelState = CONSCIOUSNESS_STATES.KERNEL;
                            const symbolIdx = Math.floor(intensity * kernelState.symbols.length);
                            const safeIdx = Math.max(0, Math.min(symbolIdx, kernelState.symbols.length - 1));
                            const symbol = kernelState.symbols[safeIdx] || '⬢'; // Fallback symbol
                            output += `<span class="${kernelState.color} kernel">${symbol}</span>`;
                            continue;
                        }
                        
                        // Check for agent positions (relative to camera)
                        let isAgent = false;
                        for (let agent of this.agents) {
                            const agentScreenX = agent.x - this.camera.x;
                            const agentScreenY = agent.y - this.camera.y;
                            const agentDist = Math.sqrt((x - agentScreenX)**2 + (y - agentScreenY)**2);
                              if (agentDist < 1) {
                                const agentLevel = Math.max(0, Math.min(1, agent.getConsciousnessLevel()));
                                let stateInfo = CONSCIOUSNESS_STATES.VOID;
                                
                                for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                    if (agentLevel >= state.threshold) {
                                        stateInfo = state;
                                    }
                                }
                                
                                const symbolIdx = Math.floor(agentLevel * stateInfo.symbols.length);
                                const safeIdx = Math.max(0, Math.min(symbolIdx, stateInfo.symbols.length - 1));
                                const symbol = stateInfo.symbols[safeIdx] || '○'; // Fallback symbol
                                const cssClass = agent.connections.length > 2 ? 
                                    (agentLevel > 0.7 ? 'transcendent' : 'emerging') : 
                                    stateInfo.color;
                                
                                output += `<span class="${cssClass}">${symbol}</span>`;
                                isAgent = true;
                                break;
                            }
                        }
                          if (!isAgent) {
                            // Blend all three fields into composite visualization
                            const emergenceValue = Math.max(0, this.emergenceField[idx] || 0);
                            const phiValue = Math.max(0, this.phiField[idx] || 0);
                            const psiValue = Math.max(0, this.psiField[idx] || 0);
                            
                            // Advanced composite intensity using non-linear combination
                            const compositeIntensity = Math.max(0, Math.min(1, Math.tanh(
                                emergenceValue * 0.5 +       // Primary: emergence field
                                phiValue * 0.3 +             // Secondary: integrated information
                                psiValue * 0.2               // Accent: quantum coherence
                            )));
                            
                            // Determine dominant field for symbol selection
                            let dominantField = 'emergence';
                            let maxValue = emergenceValue;
                            
                            if (phiValue > maxValue && phiValue > 0.15) {
                                dominantField = 'phi';
                                maxValue = phiValue;
                            }
                            if (psiValue > maxValue && psiValue > 0.1) {
                                dominantField = 'psi';
                                maxValue = psiValue;
                            }
                            
                            // Map composite intensity to consciousness state
                            let stateInfo = CONSCIOUSNESS_STATES.VOID;
                            for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                if (compositeIntensity >= state.threshold) {
                                    stateInfo = state;
                                }
                            }
                              // Select symbol based on dominant field characteristics with bounds checking
                            let symbol = '·'; // Safe fallback symbol
                            if (dominantField === 'phi' && phiValue > 0.2) {
                                // Phi-dominant areas use geometric/information symbols
                                const phiSymbols = ['◇', '◈', '◆', '⬢', '⬡', '◬'];
                                const phiIdx = Math.floor(Math.max(0, Math.min(0.999, phiValue)) * phiSymbols.length);
                                const safeIdx = Math.max(0, Math.min(phiIdx, phiSymbols.length - 1));
                                symbol = phiSymbols[safeIdx] || '◇';
                            } else if (dominantField === 'psi' && psiValue > 0.15) {
                                // Psi-dominant areas use wave/quantum symbols
                                const psiSymbols = ['∘', '○', '⊙', '◉', '⊚', '◎'];
                                const psiIdx = Math.floor(Math.max(0, Math.min(0.999, psiValue)) * psiSymbols.length);
                                const safeIdx = Math.max(0, Math.min(psiIdx, psiSymbols.length - 1));
                                symbol = psiSymbols[safeIdx] || '∘';
                            } else {
                                // Emergence-dominant areas use standard consciousness symbols
                                const symbolIdx = Math.floor(Math.max(0, Math.min(0.999, compositeIntensity)) * stateInfo.symbols.length);
                                const safeIdx = Math.max(0, Math.min(symbolIdx, stateInfo.symbols.length - 1));
                                symbol = stateInfo.symbols[safeIdx] || ' ';
                            }
                            
                            // coloring by field combinations
                            let colorClass;
                            if (compositeIntensity > 0.8) {
                                colorClass = 'transcendent';
                            } else if (compositeIntensity > 0.65) {
                                colorClass = 'metacognitive';
                            } else if (compositeIntensity > 0.45) {
                                colorClass = 'selfaware';
                            } else if (compositeIntensity > 0.25) {
                                // Special blended states for field combinations
                                if (dominantField === 'phi') {
                                    colorClass = 'u'; // Information-theoretic blue
                                } else if (dominantField === 'psi') {
                                    colorClass = 's'; // Quantum coherence cyan
                                } else {
                                    colorClass = 'emerging'; // Standard emergence
                                }
                            } else if (compositeIntensity > 0.08) {
                                colorClass = 'quantum';                            } else {
                                colorClass = stateInfo.color || 'v'; // Safe fallback color
                            }
                            
                            // Final safety check - ensure symbol is never undefined
                            if (symbol === undefined || symbol === null || symbol === 'undefined') {
                                symbol = '·'; // Safe fallback symbol
                            }
                            
                            output += `<span class="${colorClass}">${symbol}</span>`;
                        }
                    }
                    output += '\n';
                }
                
                document.getElementById('canvas').innerHTML = output;                // Update personality info display with web-compatible symbolic glyphs
                const personalityInfo = document.getElementById('personality-info');
                if (personalityInfo) {
                    // Personality archetype symbols (web-safe)
                    const archetypeSymbols = {
                        'EXPLORER': '◎', 'GUARDIAN': '■', 'ARTIST': '★', 
                        'SAGE': '●', 'REBEL': '※', 'NURTURER': '♦'
                    };
                    
                    // Behavior mode symbols (web-safe)
                    const modeSymbols = {
                        'explore': '◎→', 'create': '★∞', 'connect': '◆◆', 'transcend': '▲△'
                    };
                    
                    // Swarm coherence as simple dots/blocks
                    const coherence = this.collectiveIntelligence.swarmCoherence;
                    let coherenceSymbol = '';
                    const level = Math.floor(coherence * 5);
                    for (let i = 0; i < 5; i++) {
                        coherenceSymbol += i < level ? '█' : '░';
                    }
                    
                    let infoText = `${archetypeSymbols[systemPersonality.currentArchetype] || '○'}<br>`;
                    infoText += `${modeSymbols[this.currentBehaviorMode] || '◯'}<br>`;
                    infoText += `${coherenceSymbol}<br>`;
                    infoText += `${systemPersonality.dreamState ? '✦◉✦' : '○◯○'}`;
                    personalityInfo.innerHTML = infoText;
                }
            }softReset() {
                // Gentle reset that maintains some continuity for smooth evolution
                this.generation++;
                
                // Keep some of the best agents
                const topAgents = this.agents
                    .sort((a, b) => b.consciousness - a.consciousness)
                    .slice(0, Math.floor(this.agents.length * 0.3));
                
                // Reset fields but keep kernel state
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Spawn new agents around the top performers
                this.agents = [...topAgents];
                this.spawnAgents(Math.floor(W * H / 200) - topAgents.length);
                
                // Slightly evolve the kernel
                this.kernel.consciousness = Math.tanh(this.kernel.consciousness * 1.1);
                this.kernel.awareness = Math.tanh(this.kernel.awareness * 1.05);
                
                // Smoothly adjust camera to new kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
            }
            
            togglePause() {
                // Removed for fully automated experience
            }            reset() {
                // Replaced with automated softReset for continuous evolution
            }
              updateCamera() {
                // Set camera target to kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
                
                // Faster camera movement for more responsive following
                this.camera.x += (this.camera.targetX - this.camera.x) * 0.12;
                this.camera.y += (this.camera.targetY - this.camera.y) * 0.12;
            }
        }
          // Initialize simulation
        let simulation;
        
        function initializeSimulation() {
            updateDimensions();
            simulation = new ConsciousnessEmergenceMatrix();
            console.log(`⬢ ◉⬢◉ ⚡∇⊱◉⊰∇⚡ ∞: ${W}x${H} ⬢`);
        }
        
        // Main animation loop
        function animate() {
            simulation.update();
            simulation.render();
            requestAnimationFrame(animate);
        }        // Initialize on page load
        window.addEventListener('load', () => {
            initializeSimulation();
            animate();
        });
          // Add responsive event listeners
        window.addEventListener('resize', () => {
            updateDimensions();
            if (simulation) {
                simulation.handleResize();
            }
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateDimensions();
                if (simulation) {
                    simulation.handleResize();
                }
            }, 100);
        });
    </script>
</body>
</html>
