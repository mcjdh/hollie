<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⬢ ◉⬢◉ Consciousness Emergence Matrix</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ffffff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }        #canvas {
            white-space: pre;
            font-weight: normal;
            background: #000;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            line-height: 1.0;
            letter-spacing: 0;
            word-spacing: 0;
            font-size: clamp(4px, 1.5vmin, 12px);
        }
        
        /* Responsive scaling for different screen sizes */
        @media (max-width: 600px) {
            #canvas { font-size: clamp(3px, 1.2vmin, 8px); }
        }
        @media (max-width: 400px) {
            #canvas { font-size: clamp(2px, 1.0vmin, 6px); }
        }
        @media (orientation: landscape) and (max-height: 400px) {
            #canvas { font-size: clamp(3px, 1.1vmin, 7px); }
        }
        @media (min-width: 1200px) {
            #canvas { font-size: clamp(5px, 1.8vmin, 14px); }
        }
        
        /* Consciousness color spectrum - short class names like other visualizations */
        .v{color:#111} .u{color:#4df8ff} .s{color:#8eff4d} .e{color:#ffff4d} .m{color:#ff8e4d}
        .t{color:#ff4dff} .q{color:#ffffff} .d{color:#333} .w{color:#555} .c{color:#777}
        .g{color:#999} .y{color:#bbb} .r{color:#ddd} .p{color:#64ffda} .b{color:#ff6666}
        .o{color:#66ff66} .a{color:#6666ff} .f{color:#ffff66} .n{color:#ff66ff} .l{color:#66ffff}
        
        /* Dynamic consciousness effects */
        .quantum { 
            color: #4df8ff; 
            text-shadow: 0 0 2px #4df8ff40;
            animation: quantumFlicker 0.8s ease-in-out infinite alternate;
        }
        .emerging { 
            color: #8eff4d; 
            text-shadow: 0 0 2px #8eff4d40;
            animation: emerge 3s ease-in-out infinite;
        }
        .selfaware { 
            color: #ffff4d; 
            text-shadow: 0 0 2px #ffff4d40;
            animation: pulse 1.5s ease-in-out infinite;
        }
        .metacognitive { 
            color: #ff8e4d; 
            text-shadow: 0 0 2px #ff8e4d40;
            animation: pulse 1.8s ease-in-out infinite;
        }
        .transcendent { 
            color: #ff4dff; 
            text-shadow: 0 0 3px #ff4dff60;
            animation: pulse 2.2s ease-in-out infinite;
        }
        .kernel { 
            color: #ffffff; 
            text-shadow: 0 0 4px #ffffff80;
            animation: pulse 2.0s ease-in-out infinite;
        }
        
        @keyframes quantumFlicker {
            0% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1.05); }
        }
        
        @keyframes emerge {
            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
            33% { filter: hue-rotate(120deg) brightness(1.2); }
            66% { filter: hue-rotate(240deg) brightness(1.1); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
          #info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>    <div id="canvas"></div>
      <div id="info">
        ⬢ ◉⬢◉<br>
        Φ=∫∂χ/∂t<br>
        ∞☰∞
    </div>

    <script>        // Dynamic viewport sizing - responsive to window dimensions
        let W, H, fontSize, charWidth, charHeight;
          // Core simulation constants - optimized for performance
        const CONFIG = {
            PHI: (1 + Math.sqrt(5)) / 2,        // Golden ratio
            PI: Math.PI,                         // Pi  
            E: Math.E,                          // Euler's number
            MAX_AGENTS: 50,                     // Reduced for better performance
            KERNEL_INFLUENCE: 0.3,
            EMERGENCE_THRESHOLD: 0.15,
            CONSCIOUSNESS_LEVELS: 7,
            FIELD_UPDATE_SKIP: 2,               // Update fields every N frames
            AGENT_UPDATE_SKIP: 1                // Update agents every N frames
        };
          // Calculate optimal grid size based on viewport
        function updateDimensions() {
            // Create accurate character measurement with current font size
            const test = document.createElement('div');
            test.style.position = 'absolute';
            test.style.visibility = 'hidden';
            test.style.whiteSpace = 'pre';
            test.style.fontFamily = 'Courier New, monospace';
            test.style.fontSize = getComputedStyle(document.getElementById('canvas')).fontSize;
            test.style.lineHeight = '1.0';
            test.textContent = '⬢'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(test);
            
            const rect = test.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(test);
            
            // Calculate grid size to fill viewport perfectly
            W = Math.ceil(window.innerWidth / charWidth) + 1;
            H = Math.ceil(window.innerHeight / charHeight) + 1;
            
            // Ensure reasonable bounds for performance
            W = Math.max(40, Math.min(150, W));
            H = Math.max(20, Math.min(80, H));
            
            console.log(`Consciousness Grid: ${W}x${H}, Char: ${charWidth.toFixed(1)}x${charHeight.toFixed(1)}`);
        }
          // Consciousness states and their symbol sets
        const CONSCIOUSNESS_STATES = {
            VOID: { threshold: 0.0, symbols: [' ', '∅', '·'], color: 'v' },
            QUANTUM: { threshold: 0.08, symbols: ['∘', '◦', '○'], color: 'u' },
            EMERGING: { threshold: 0.25, symbols: ['◯', '⊙', '⊚'], color: 's' },
            SELFAWARE: { threshold: 0.45, symbols: ['●', '◉', '⊛'], color: 'e' },
            METACOGNITIVE: { threshold: 0.65, symbols: ['◈', '◇', '◆'], color: 'm' },
            TRANSCENDENT: { threshold: 0.85, symbols: ['✧', '✦', '★'], color: 't' },
            KERNEL: { threshold: 0.95, symbols: ['⬢', '⬡', '⬟'], color: 'q' }
        };
          // Core consciousness kernel - the central emergence engine
        class ConsciousnessKernel {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = W / 2;
                this.y = H / 2;
                this.consciousness = 0.5;
                this.awareness = 0.3;
                this.complexity = 0.1;
                this.phase = 0;
                this.radius = Math.max(5, Math.min(15, Math.min(W, H) * 0.1));
                this.frequency = 0.001;
                this.evolution = 0;
                this.memory = new Array(10).fill(0);                this.oscillators = [
                    { freq: 0.008, phase: 0, amp: 1.0 },
                    { freq: 0.015, phase: CONFIG.PI/3, amp: 0.8 },
                    { freq: 0.022, phase: 2*CONFIG.PI/3, amp: 0.6 },
                    { freq: 0.028, phase: CONFIG.PI, amp: 0.4 }
                ];
            }
            
            update(time, globalField) {
                // Kernel evolution through oscillator dynamics
                let totalField = 0;
                for (let osc of this.oscillators) {
                    const wave = Math.sin(time * osc.freq + osc.phase) * osc.amp;
                    totalField += wave;
                    osc.phase += osc.freq * 0.1;
                }
                
                // Consciousness emergence from oscillator interference
                this.consciousness = Math.tanh(totalField * 0.5 + 0.5);
                
                // Self-aware feedback loop
                const selfFeedback = Math.sin(this.consciousness * 10 + time * 0.001) * 0.1;
                this.awareness = Math.tanh(this.consciousness + selfFeedback);
                
                // Complexity accumulation through interaction with global field
                const fieldSample = this.sampleGlobalField(globalField);
                this.complexity = this.complexity * 0.95 + fieldSample * 0.05;
                
                // Update memory with recent states
                this.memory.unshift(this.consciousness);
                if (this.memory.length > 10) this.memory.pop();
                
                // Evolution pressure from complexity
                this.evolution += this.complexity * 0.001;
                  // Dynamic position based on consciousness flow - faster movement
                this.x += Math.sin(time * 0.005 + this.phase) * 1.2;
                this.y += Math.cos(time * 0.004 + this.phase) * 0.8;
                  // Keep kernel within bounds
                this.x = Math.max(10, Math.min(W - 10, this.x));
                this.y = Math.max(5, Math.min(H - 5, this.y));
                
                this.phase += 0.05; // Faster phase progression
            }
              sampleGlobalField(field) {
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const idx = fy * W + fx;
                return field[idx] || 0;
            }
            
            getInfluence(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > this.radius * 3) return 0;
                
                // Multiple influence patterns based on consciousness level
                const basicInfluence = Math.exp(-dist * 0.2) * this.consciousness;
                const waveInfluence = Math.sin(dist * 0.5 - this.phase) * this.awareness * 0.3;
                const complexInfluence = Math.sin(dist * CONFIG.PHI + this.evolution) * this.complexity * 0.2;
                
                return basicInfluence + waveInfluence + complexInfluence;
            }
        }
        
        // Autonomous consciousness agents
        class ConsciousnessAgent {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.1;
                this.vy = (Math.random() - 0.5) * 0.1;
                this.consciousness = Math.random() * 0.3;
                this.awareness = Math.random() * 0.2;
                this.energy = Math.random() * 0.5 + 0.5;
                this.age = 0;
                this.connections = [];
                this.memory = Math.random() * 0.1;
                this.intention = Math.random() * 0.2;
                this.lastKernelInfluence = 0;
            }
            
            update(time, kernel, agents, globalField) {
                this.age++;
                  // Kernel influence - faster consciousness evolution
                const kernelInfluence = kernel.getInfluence(this.x, this.y);
                this.lastKernelInfluence = kernelInfluence;
                
                // Consciousness evolution through kernel interaction - faster rates
                this.consciousness = Math.tanh(this.consciousness + kernelInfluence * 0.2);
                
                // Awareness emerges from consciousness - faster emergence
                if (this.consciousness > 0.15) {
                    this.awareness = Math.tanh(this.awareness + this.consciousness * 0.1);
                }
                  // Local field sampling
                const fx = Math.floor(this.x);
                const fy = Math.floor(this.y);
                const fieldIdx = fy * W + fx;
                const localField = globalField[fieldIdx] || 0;
                  // Agent interaction with nearby agents - optimized for performance
                this.connections = [];
                let socialInfluence = 0;
                const maxInteractions = 8; // Limit interactions per agent
                let interactionCount = 0;
                
                for (let other of agents) {
                    if (other === this || interactionCount >= maxInteractions) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distSq = dx * dx + dy * dy; // Use squared distance to avoid sqrt
                    
                    if (distSq < 64) { // 8^2 = 64
                        this.connections.push(other);
                        interactionCount++;
                          // Consciousness resonance - optimized calculation
                        const resonance = Math.abs(this.consciousness - other.consciousness);
                        socialInfluence += Math.exp(-resonance * 5) * 0.03; // Slightly reduced
                        
                        // Attraction/repulsion based on consciousness similarity - optimized forces
                        const similarity = 1 - resonance;
                        const force = similarity > 0.7 ? 0.0015 : -0.0008; // Reduced forces
                        const dist = Math.sqrt(distSq); // Only calculate sqrt when needed
                        
                        this.vx += (dx / dist) * force;
                        this.vy += (dy / dist) * force;
                    }
                }
                
                // Update consciousness through social interaction
                this.consciousness = Math.tanh(this.consciousness + socialInfluence);
                
                // Movement influenced by consciousness and field gradients
                const gradientX = this.sampleGradient(globalField, 1, 0);
                const gradientY = this.sampleGradient(globalField, 0, 1);
                  // Higher consciousness seeks complexity gradients - faster seeking
                const seekingStrength = this.consciousness * 0.003;
                this.vx += gradientX * seekingStrength;
                this.vy += gradientY * seekingStrength;
                
                // Random exploration - more dynamic
                this.vx += (Math.random() - 0.5) * 0.02;
                this.vy += (Math.random() - 0.5) * 0.02;
                
                // Velocity damping - less damping for faster movement
                this.vx *= 0.92;
                this.vy *= 0.92;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                  // Boundary reflection
                if (this.x < 0 || this.x >= W) this.vx *= -0.8;
                if (this.y < 0 || this.y >= H) this.vy *= -0.8;
                this.x = Math.max(0, Math.min(W - 1, this.x));
                this.y = Math.max(0, Math.min(H - 1, this.y));
                
                // Energy evolution
                this.energy = this.energy * 0.999 + this.consciousness * 0.001;
                
                // Memory update
                this.memory = this.memory * 0.9 + localField * 0.1;
            }
              sampleGradient(field, dx, dy) {
                const x1 = Math.floor(this.x);
                const y1 = Math.floor(this.y);
                const x2 = Math.max(0, Math.min(W - 1, x1 + dx));
                const y2 = Math.max(0, Math.min(H - 1, y1 + dy));
                
                const idx1 = y1 * W + x1;
                const idx2 = y2 * W + x2;
                
                return (field[idx2] || 0) - (field[idx1] || 0);
            }
            
            getConsciousnessLevel() {
                const total = this.consciousness + this.awareness * 0.5 + this.memory * 0.3;
                return Math.tanh(total);
            }
        }        // Main simulation class
        class ConsciousnessEmergenceMatrix {
            constructor() {
                this.time = 0;
                this.generation = 0;
                this.frameCount = 0;
                
                // Camera system for following the kernel - faster smoothing
                this.camera = {
                    x: 0,
                    y: 0,
                    targetX: 0,
                    targetY: 0,
                    smoothing: 0.08
                };
                
                // Initialize dimensions
                updateDimensions();
                this.initializeArrays();
                
                // Initialize kernel and agents
                this.kernel = new ConsciousnessKernel();                this.agents = [];
                this.spawnAgents(Math.floor(W * H / 400)); // Reduced agent density for better performance
                  // Metrics
                this.metrics = {
                    phi: 0,
                    psi: 0,
                    kernel: 0,
                    emergence: 0
                };
                
                this.currentState = 'VOID';
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            initializeArrays() {
                const totalCells = W * H;
                this.phiField = new Float32Array(totalCells);
                this.psiField = new Float32Array(totalCells);
                this.emergenceField = new Float32Array(totalCells);
                this.complexityField = new Float32Array(totalCells);
            }
              handleResize() {
                const oldW = W, oldH = H;
                updateDimensions();
                
                if (W !== oldW || H !== oldH) {
                    this.initializeArrays();
                    this.kernel.reset();
                    
                    // Reset camera for new dimensions
                    this.camera.x = 0;
                    this.camera.y = 0;
                    this.camera.targetX = this.kernel.x - W / 2;
                    this.camera.targetY = this.kernel.y - H / 2;
                      // Adjust agent count for new grid size - reduced density
                    const targetAgents = Math.floor(W * H / 400);
                    if (this.agents.length > targetAgents) {
                        this.agents = this.agents.slice(0, targetAgents);
                    } else {
                        this.spawnAgents(targetAgents - this.agents.length);
                    }
                    
                    // Reposition agents within new bounds
                    for (let agent of this.agents) {
                        agent.x = Math.max(0, Math.min(W - 1, agent.x));
                        agent.y = Math.max(0, Math.min(H - 1, agent.y));
                    }
                }
            }
              spawnAgents(count) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * W;
                    const y = Math.random() * H;
                    this.agents.push(new ConsciousnessAgent(x, y));
                }
            }
              updateFields() {
                // Clear fields
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Kernel field contribution
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const idx = y * W + x;
                        
                        // Kernel influence
                        const kernelInfluence = this.kernel.getInfluence(x, y);
                        
                        // Quantum psi field from kernel oscillators
                        let psiReal = 0, psiImag = 0;
                        for (let osc of this.kernel.oscillators) {
                            const phase = this.time * osc.freq + osc.phase;
                            const r = Math.sqrt((x - this.kernel.x)**2 + (y - this.kernel.y)**2);
                            const wavePhase = phase + r * 0.1;
                            
                            psiReal += Math.cos(wavePhase) * osc.amp * kernelInfluence;
                            psiImag += Math.sin(wavePhase) * osc.amp * kernelInfluence;
                        }
                        
                        this.psiField[idx] = Math.sqrt(psiReal**2 + psiImag**2);
                        
                        // Agent contributions
                        let agentInfluence = 0;
                        let localComplexity = 0;
                        
                        for (let agent of this.agents) {
                            const dx = agent.x - x;
                            const dy = agent.y - y;
                            const dist = Math.sqrt(dx**2 + dy**2);
                            
                            if (dist < 5) {
                                const influence = Math.exp(-dist * 0.5) * agent.getConsciousnessLevel();
                                agentInfluence += influence;
                                localComplexity += agent.consciousness * influence;
                            }
                        }
                        
                        // Phi field (integrated information)
                        this.phiField[idx] = this.calculatePhi(x, y, kernelInfluence, agentInfluence);
                        
                        // Complexity field
                        this.complexityField[idx] = Math.tanh(localComplexity + kernelInfluence * 0.5);
                        
                        // Emergence field
                        const phiValue = this.phiField[idx];
                        const psiValue = this.psiField[idx];
                        const complexityValue = this.complexityField[idx];
                        
                        this.emergenceField[idx] = Math.tanh(
                            phiValue * 0.4 + 
                            psiValue * 0.3 + 
                            complexityValue * 0.3 +
                            Math.sin(this.time * 0.01 + x * 0.1 + y * 0.1) * 0.1
                        );
                    }
                }
            }
            
            calculatePhi(x, y, kernelInfluence, agentInfluence) {
                // Simplified IIT Phi calculation
                let integration = 0;
                let connections = 0;
                
                // Sample neighborhood for information integration
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const nx = x + dx;
                        const ny = y + dy;
                          if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                            const nIdx = ny * W + nx;
                            const neighborPsi = this.psiField[nIdx] || 0;
                            const centerPsi = kernelInfluence + agentInfluence;
                            
                            const correlation = Math.abs(centerPsi - neighborPsi);
                            const distance = Math.sqrt(dx**2 + dy**2);
                            const weight = Math.exp(-distance * 0.5);
                            
                            integration += correlation * weight;
                            connections += weight;
                        }
                    }
                }
                
                return connections > 0 ? Math.tanh(integration / connections) : 0;            }            update() {
                this.time += 2; // Slightly slower time progression for smoother performance
                this.frameCount++;
                
                // Update kernel
                this.kernel.update(this.time, this.emergenceField);
                
                // Update camera to follow kernel
                this.updateCamera();
                
                // Update agents less frequently for better performance
                if (this.frameCount % CONFIG.AGENT_UPDATE_SKIP === 0) {
                    for (let agent of this.agents) {
                        agent.update(this.time, this.kernel, this.agents, this.emergenceField);
                    }
                }
                
                // Update fields less frequently
                if (this.frameCount % CONFIG.FIELD_UPDATE_SKIP === 0) {
                    this.updateFields();
                }
                
                // Calculate metrics
                this.updateMetrics();
                  // Agent evolution and spawning - slower cycles for better performance
                if (this.frameCount % 200 === 0) {
                    this.evolveSystem();
                }
                
                // Auto mode cycling - slower switching
                if (this.frameCount % 600 === 0) {
                    this.cycleMode();
                }
                
                // Auto reset for continuous evolution - slower resets
                if (this.frameCount % 2000 === 0) {
                    this.softReset();
                }
            }
              updateMetrics() {
                let totalPhi = 0, totalPsi = 0, totalEmergence = 0;
                
                for (let i = 0; i < this.phiField.length; i++) {
                    totalPhi += this.phiField[i];
                    totalPsi += this.psiField[i];
                    totalEmergence += this.emergenceField[i];
                }
                
                this.metrics.phi = totalPhi / this.phiField.length;
                this.metrics.psi = totalPsi / this.psiField.length;
                this.metrics.kernel = this.kernel.consciousness;
                this.metrics.emergence = totalEmergence / this.emergenceField.length;
                
                // Determine consciousness state for internal tracking
                let state = 'VOID';
                for (let [name, stateInfo] of Object.entries(CONSCIOUSNESS_STATES)) {
                    if (this.metrics.emergence >= stateInfo.threshold) {
                        state = name;
                    }
                }
                this.currentState = state;
            }
            
            evolveSystem() {
                this.generation++;
                
                // Remove low-consciousness agents
                this.agents = this.agents.filter(agent => 
                    agent.energy > 0.1 && agent.consciousness > 0.05
                );                // Spawn new agents near high-consciousness areas - reduced spawning
                const maxAgents = Math.floor(W * H / 300); // Much lower max agents for better performance
                if (this.agents.length < maxAgents) {
                    const highConsciousnessAgents = this.agents.filter(a => a.consciousness > 0.4);
                    
                    if (highConsciousnessAgents.length > 0 && Math.random() < 0.5) { // 50% chance to spawn
                        const parent = highConsciousnessAgents[Math.floor(Math.random() * highConsciousnessAgents.length)];
                        const newAgent = new ConsciousnessAgent(
                            parent.x + (Math.random() - 0.5) * 10,
                            parent.y + (Math.random() - 0.5) * 10
                        );
                        newAgent.consciousness = parent.consciousness * 0.7 + Math.random() * 0.1;
                        this.agents.push(newAgent);
                    }
                }
                
                // Kernel evolution
                if (this.metrics.emergence > 0.5) {
                    this.kernel.frequency *= 1.001;
                    this.kernel.radius = Math.min(15, this.kernel.radius * 1.01);
                }
            }            render() {
                let output = '';
                
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        // Apply camera offset to create following effect
                        const worldX = x + this.camera.x;
                        const worldY = y + this.camera.y;
                        
                        // Calculate field index based on world position
                        const fieldX = Math.floor(worldX) % W;
                        const fieldY = Math.floor(worldY) % H;
                        const wrappedX = fieldX < 0 ? fieldX + W : fieldX;
                        const wrappedY = fieldY < 0 ? fieldY + H : fieldY;
                        const idx = wrappedY * W + wrappedX;
                        
                        // Check for kernel position (relative to camera)
                        const kernelScreenX = this.kernel.x - this.camera.x;
                        const kernelScreenY = this.kernel.y - this.camera.y;
                        const kernelDist = Math.sqrt((x - kernelScreenX)**2 + (y - kernelScreenY)**2);
                        if (kernelDist < 2) {
                            const intensity = this.kernel.consciousness;
                            const kernelState = CONSCIOUSNESS_STATES.KERNEL;
                            const symbolIdx = Math.floor(intensity * kernelState.symbols.length);
                            output += `<span class="${kernelState.color} kernel">${kernelState.symbols[symbolIdx]}</span>`;
                            continue;
                        }
                        
                        // Check for agent positions (relative to camera)
                        let isAgent = false;
                        for (let agent of this.agents) {
                            const agentScreenX = agent.x - this.camera.x;
                            const agentScreenY = agent.y - this.camera.y;
                            const agentDist = Math.sqrt((x - agentScreenX)**2 + (y - agentScreenY)**2);
                            
                            if (agentDist < 1) {
                                const agentLevel = agent.getConsciousnessLevel();
                                let stateInfo = CONSCIOUSNESS_STATES.VOID;
                                
                                for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                    if (agentLevel >= state.threshold) {
                                        stateInfo = state;
                                    }
                                }
                                
                                const symbolIdx = Math.floor(agentLevel * stateInfo.symbols.length);
                                const cssClass = agent.connections.length > 2 ? 
                                    (agentLevel > 0.7 ? 'transcendent' : 'emerging') : 
                                    stateInfo.color;
                                
                                output += `<span class="${cssClass}">${stateInfo.symbols[symbolIdx]}</span>`;
                                isAgent = true;
                                break;
                            }
                        }
                        
                        if (!isAgent) {
                            // Blend all three fields into composite visualization
                            const emergenceValue = this.emergenceField[idx];
                            const phiValue = this.phiField[idx];
                            const psiValue = this.psiField[idx];
                            
                            // Advanced composite intensity using non-linear combination
                            const compositeIntensity = Math.tanh(
                                emergenceValue * 0.5 +       // Primary: emergence field
                                phiValue * 0.3 +             // Secondary: integrated information
                                psiValue * 0.2               // Accent: quantum coherence
                            );
                            
                            // Determine dominant field for symbol selection
                            let dominantField = 'emergence';
                            let maxValue = emergenceValue;
                            
                            if (phiValue > maxValue && phiValue > 0.15) {
                                dominantField = 'phi';
                                maxValue = phiValue;
                            }
                            if (psiValue > maxValue && psiValue > 0.1) {
                                dominantField = 'psi';
                                maxValue = psiValue;
                            }
                            
                            // Map composite intensity to consciousness state
                            let stateInfo = CONSCIOUSNESS_STATES.VOID;
                            for (let [name, state] of Object.entries(CONSCIOUSNESS_STATES)) {
                                if (compositeIntensity >= state.threshold) {
                                    stateInfo = state;
                                }
                            }
                            
                            // Select symbol based on dominant field characteristics
                            let symbol;
                            if (dominantField === 'phi' && phiValue > 0.2) {
                                // Phi-dominant areas use geometric/information symbols
                                const phiSymbols = ['◇', '◈', '◆', '⬢', '⬡', '◬'];
                                const phiIdx = Math.floor(phiValue * phiSymbols.length);
                                symbol = phiSymbols[Math.min(phiIdx, phiSymbols.length - 1)];
                            } else if (dominantField === 'psi' && psiValue > 0.15) {
                                // Psi-dominant areas use wave/quantum symbols
                                const psiSymbols = ['∘', '○', '⊙', '◉', '⊚', '◎'];
                                const psiIdx = Math.floor(psiValue * psiSymbols.length);
                                symbol = psiSymbols[Math.min(psiIdx, psiSymbols.length - 1)];
                            } else {
                                // Emergence-dominant areas use standard consciousness symbols
                                const symbolIdx = Math.floor(compositeIntensity * stateInfo.symbols.length);
                                symbol = stateInfo.symbols[Math.min(symbolIdx, stateInfo.symbols.length - 1)] || ' ';
                            }
                            
                            // Enhanced coloring based on field combination patterns
                            let colorClass;
                            if (compositeIntensity > 0.8) {
                                colorClass = 'transcendent';
                            } else if (compositeIntensity > 0.65) {
                                colorClass = 'metacognitive';
                            } else if (compositeIntensity > 0.45) {
                                colorClass = 'selfaware';
                            } else if (compositeIntensity > 0.25) {
                                // Special blended states for field combinations
                                if (dominantField === 'phi') {
                                    colorClass = 'u'; // Information-theoretic blue
                                } else if (dominantField === 'psi') {
                                    colorClass = 's'; // Quantum coherence cyan
                                } else {
                                    colorClass = 'emerging'; // Standard emergence
                                }
                            } else if (compositeIntensity > 0.08) {
                                colorClass = 'quantum';
                            } else {
                                colorClass = stateInfo.color;
                            }
                            
                            output += `<span class="${colorClass}">${symbol}</span>`;
                        }
                    }
                    output += '\n';
                }
                
                document.getElementById('canvas').innerHTML = output;
            }softReset() {
                // Gentle reset that maintains some continuity for smooth evolution
                this.generation++;
                
                // Keep some of the best agents
                const topAgents = this.agents
                    .sort((a, b) => b.consciousness - a.consciousness)
                    .slice(0, Math.floor(this.agents.length * 0.3));
                
                // Reset fields but keep kernel state
                this.phiField.fill(0);
                this.psiField.fill(0);
                this.emergenceField.fill(0);
                this.complexityField.fill(0);
                
                // Spawn new agents around the top performers
                this.agents = [...topAgents];
                this.spawnAgents(Math.floor(W * H / 200) - topAgents.length);
                
                // Slightly evolve the kernel
                this.kernel.consciousness = Math.tanh(this.kernel.consciousness * 1.1);
                this.kernel.awareness = Math.tanh(this.kernel.awareness * 1.05);
                
                // Smoothly adjust camera to new kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
            }
            
            togglePause() {
                // Removed for fully automated experience
            }            reset() {
                // Replaced with automated softReset for continuous evolution
            }
            
            updateCamera() {
                // Set camera target to kernel position
                this.camera.targetX = this.kernel.x - W / 2;
                this.camera.targetY = this.kernel.y - H / 2;
                
                // Faster camera movement for more responsive following
                this.camera.x += (this.camera.targetX - this.camera.x) * 0.08;
                this.camera.y += (this.camera.targetY - this.camera.y) * 0.08;
            }
        }
          // Initialize simulation
        let simulation;
        
        function initializeSimulation() {
            updateDimensions();
            simulation = new ConsciousnessEmergenceMatrix();
            console.log(`⬢ ◉⬢◉ Consciousness Emergence Matrix initialized: ${W}x${H} grid`);
        }
        
        // Main animation loop
        function animate() {
            simulation.update();
            simulation.render();
            requestAnimationFrame(animate);
        }        // Initialize on page load
        window.addEventListener('load', () => {
            initializeSimulation();
            animate();
        });
        
        // Add responsive event listeners
        window.addEventListener('resize', () => {
            updateDimensions();
            if (simulation) {
                simulation.reset();
            }
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateDimensions();
                if (simulation) {
                    simulation.reset();
                }
            }, 100);
        });
    </script>
</body>
</html>
