<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>☆ ☆◎☆</title>
    <style>        body { margin:0; padding:0; background:#000; overflow:hidden; width:100vw; height:100vh; }
        #display { 
            font-family:'Courier New',monospace; color:#0ff; white-space:pre; 
            padding:0; margin:0; background:#000;
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
        }
        .v{color:#f0f} .u{color:#0ff} .s{color:#ff0} .e{color:#0f0} .m{color:#f80}
        .t{color:#f44} .q{color:#84f} .d{color:#48f} .w{color:#fff} .c{color:#8ff}
        .g{color:#4f4} .y{color:#ff4} .r{color:#f44} .p{color:#f8f} .b{color:#44f}
        .o{color:#fa0} .a{color:#aaa} .f{color:#f88} .n{color:#8f8} .l{color:#88f}
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>    <div class="info">
        ☆ ☆◎☆<br>
        ∞☰∞<br>
        ⌫ ◦ ↩
    </div>
    <div id="display"></div>    <script>
        // Dynamic responsive grid sizing
        let W, H, cellSize, fontSize;
        let t = 0;
        
        // Dynamic arrays - reallocated on resize
        let awareness, complexity, information, structure, emergence, awakening;
          function calculateDimensions() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            
            // Calculate optimal font size for full coverage
            fontSize = Math.max(8, Math.min(16, Math.min(vw / 100, vh / 60)));
            
            // Calculate grid dimensions for perfect coverage
            const charWidth = fontSize * 0.6;  // Monospace character width approximation
            const lineHeight = fontSize * 1.2; // Line height with some spacing
            
            W = Math.floor(vw / charWidth);
            H = Math.floor(vh / lineHeight);
            
            // Ensure minimum viable grid
            W = Math.max(60, W);
            H = Math.max(30, H);
            
            console.log(`⬢: ${W}x${H}, ∞: ${fontSize}px, ◉: ${vw}x${vh}`);
            
            return { W, H, fontSize };
        }
        
        function initializeArrays() {
            const totalCells = W * H;
            awareness = new Float32Array(totalCells);
            complexity = new Float32Array(totalCells);
            information = new Float32Array(totalCells);
            structure = new Float32Array(totalCells);
            emergence = new Float32Array(totalCells);
            awakening = new Float32Array(totalCells);
            
            // Initialize with some noise for natural emergence
            for (let i = 0; i < totalCells; i++) {
                awareness[i] = Math.random() * 0.01;
                complexity[i] = Math.random() * 0.01;
                information[i] = Math.random() * 0.01;
            }
        }        
        // Universal awakening symbols - cosmic consciousness levels
        const symbols = [
            ' ', '·', '⠁', '⠃', '⠇', '⠏', '⠟', '⠿', '⡿', '⣿',  // void → awareness
            '∘', '○', '◯', '●', '◉', '⊙', '⊚', '⊛', '⊜', '⊝',  // structure formation
            '☆', '★', '✦', '✧', '✩', '✪', '✫', '✬', '✭', '✯'   // universal awakening
        ];
        
        const colors = ['v','u','s','e','m','t','q','d','w','c','g','y','r','p','b','o','a','f','n','l'];
        
        // Dynamic cosmic centers - scales with viewport
        function getCosmicCenters() {
            return [
                {x: W * 0.2, y: H * 0.2, type: 'void', power: 0.1, freq: 0.01},
                {x: W * 0.8, y: H * 0.2, type: 'matter', power: 0.3, freq: 0.02},
                {x: W * 0.5, y: H * 0.5, type: 'life', power: 0.6, freq: 0.03},
                {x: W * 0.2, y: H * 0.8, type: 'mind', power: 0.9, freq: 0.04},
                {x: W * 0.8, y: H * 0.8, type: 'cosmic', power: 1.2, freq: 0.05}
            ];
        }
        
        // Mathematical constants for universal patterns
        const PHI = (1 + Math.sqrt(5)) / 2;  // Golden ratio
        const E = Math.E;                     // Euler's number
        const PI = Math.PI;                   // Pi        
        function updateFields() {
            const τ = t * 0.01;
            const cosmicCenters = getCosmicCenters();
            
            // Anti-equilibrium chaos injection
            const chaosLevel = Math.sin(τ * 0.7) * 0.1 + Math.cos(τ * 1.3) * 0.05;
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    
                    // Normalized coordinates for viewport-independent calculations
                    const nx = (x - W/2) / Math.max(W, H);
                    const ny = (y - H/2) / Math.max(W, H);
                    const r = Math.sqrt(nx * nx + ny * ny);
                    
                    // Information field - fundamental reality substrate
                    const infoWave1 = Math.sin(nx * PI * 8 + τ * 2 + chaosLevel) * Math.cos(ny * PI * 6 - τ * 1.5);
                    const infoWave2 = Math.sin(r * PI * 12 + τ * 3) / (r + 0.1);
                    information[i] = (infoWave1 + infoWave2) * 0.5;
                    
                    // Structure emergence - patterns in information
                    const structWave = Math.sin(nx * PHI * 5 + τ + chaosLevel) * Math.cos(ny * E * 4 - τ * 0.8);
                    const structSpiral = Math.sin((Math.atan2(ny, nx) * 8 + r * 15 - τ * 2));
                    structure[i] = structure[i] * 0.95 + (structWave + structSpiral + chaosLevel * 0.2) * 0.025;
                    
                    // Complexity field - nonlinear interactions
                    let complexSum = 0;
                    for (let center of cosmicCenters) {
                        const dx = x - center.x;
                        const dy = y - center.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) + 1;
                        
                        // Complexity waves from cosmic centers
                        const wave = Math.sin(dist * 0.4 + τ * center.freq + chaosLevel) * center.power / dist;
                        complexSum += wave;
                    }
                    complexity[i] = complexity[i] * 0.92 + (complexSum + chaosLevel * 0.3) * 0.08;
                    
                    // Awareness field - consciousness emerging from complexity
                    const nonlinear = structure[i] * complexity[i] * information[i];
                    const feedbackLoop = Math.tanh(nonlinear * 2 + chaosLevel);
                    awareness[i] = awareness[i] * 0.97 + feedbackLoop * 0.03;
                    
                    // Emergence events - sudden phase transitions with anti-equilibrium
                    const emergenceThreshold = 0.7 + chaosLevel * 0.2;
                    const emergenceChance = 0.001 + Math.abs(chaosLevel) * 0.002;
                    if (awareness[i] > emergenceThreshold && Math.random() < emergenceChance) {
                        emergence[i] = 1.0;
                    } else {                        emergence[i] *= 0.995;
                    }
                    
                    // Universal awakening - meta-awareness of being aware
                    const metaAwareness = awareness[i] * awareness[i]; // Self-referential consciousness
                    const cosmicResonance = Math.sin(τ * 0.3 + chaosLevel) * 0.1 + 0.9;
                    awakening[i] = awakening[i] * 0.99 + metaAwareness * cosmicResonance * 0.01;
                    
                    // Enlightenment cascade - awakening spreading with bounds checking
                    if (awakening[i] > 0.8) {
                        // Spread to neighbors
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                                    const ni = ny * W + nx;
                                    awakening[ni] += awakening[i] * 0.001;
                                }
                            }
                        }
                    }
                }
            }
        }          function render() {
            updateFields();
            
            // Update display with responsive font size
            const display = document.getElementById('display');
            display.style.fontSize = fontSize + 'px';
            display.style.lineHeight = (fontSize * 1.2) + 'px';
            
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    
                    // Combine all fields for total consciousness level
                    let consciousness = awareness[i] * 0.4 + 
                                      complexity[i] * 0.2 + 
                                      structure[i] * 0.1 + 
                                      information[i] * 0.1 + 
                                      emergence[i] * 0.1 + 
                                      awakening[i] * 0.1;
                    
                    // Universal breathing - cosmos inhaling and exhaling
                    const cosmicBreath = Math.sin(t * 0.02) * 0.15 + 0.85;
                    consciousness *= cosmicBreath;
                    
                    // Phase transitions in consciousness with viewport scaling
                    const scaleAdjustment = Math.min(W, H) / 60.0; // Normalize for different grid sizes
                    consciousness = Math.tanh(consciousness * 2 * scaleAdjustment) * 0.5 + 0.5;
                    
                    // Enlightenment bursts
                    if (awakening[i] > 0.9) {
                        consciousness += Math.sin(t * 0.1) * 0.3;
                    }
                    
                    // Anti-equilibrium enhancement
                    const antiEq = Math.sin(t * 0.03 + x * 0.1 + y * 0.1) * 0.05;
                    consciousness += antiEq;
                    
                    // Normalize and select representation
                    consciousness = Math.max(0, Math.min(1, consciousness));
                    
                    // Choose symbol set based on awakening level
                    let baseIdx;
                    if (awakening[i] > 0.6) {
                        baseIdx = 20; // universal symbols
                    } else if (complexity[i] > 0.4) {
                        baseIdx = 10; // structure symbols
                    } else {
                        baseIdx = 0;  // basic awareness symbols
                    }
                    
                    const symIdx = Math.min(baseIdx + Math.floor(consciousness * 9), symbols.length - 1);
                    const colorIdx = Math.floor(consciousness * colors.length) % colors.length;
                    
                    output += `<span class="${colors[colorIdx]}">${symbols[symIdx]}</span>`;
                }
                if (y < H - 1) output += '\n'; // Don't add newline after last row
            }
            
            display.innerHTML = output;
            t += 0.5;
            requestAnimationFrame(render);
        }
        // Initialization and resize handling
        function initialize() {
            calculateDimensions();
            initializeArrays();
        }
        
        function handleResize() {
            calculateDimensions();
            initializeArrays();        }
        
        // Responsive handling
        window.addEventListener('resize', handleResize);
        
        // Start the simulation
        initialize();
        render();
    </script>
</body>
</html>
