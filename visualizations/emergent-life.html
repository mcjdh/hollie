<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>∇ ♦∂♦</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #000; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            font-family: 'Courier New', monospace;
        }
        #display { 
            font-family: 'Courier New', monospace; 
            color: #64ffda; 
            white-space: pre; 
            padding: 0; 
            margin: 0;
            width: 100vw; 
            height: 100vh; 
            background: #000;
            position: absolute;
            top: 0;
            left: 0;
            line-height: 1.0;
            overflow: hidden;
            font-size: 6px;
        }
        .v{color:#64ffda} .u{color:#0ff} .s{color:#ff0} .e{color:#0f0} .m{color:#f80}
        .t{color:#f44} .q{color:#84f} .d{color:#48f} .w{color:#fff} .c{color:#8ff}
        .g{color:#4f4} .y{color:#ff4} .r{color:#f44} .p{color:#f8f} .b{color:#44f}
        .o{color:#fa0} .a{color:#aaa} .f{color:#f88} .n{color:#8f8} .l{color:#88f}
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>
    <div class="info">
        ∇ ♦∂♦<br>
        ∂φ/∂t = D∇²φ + f(φ)<br>
        ⌫ ◦ ↩
    </div>
    <div id="display"></div>

    <script>
        // Dynamic viewport sizing
        let W, H;
        let charWidth, charHeight;
        let t = 0;
        
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Character measurement
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '6px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = '♦'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(testDiv);
            
            // Calculate grid size
            W = Math.ceil(viewportWidth / charWidth) + 2;
            H = Math.ceil(viewportHeight / charHeight) + 2;
            
            W = Math.max(60, W);
            H = Math.max(30, H);
            
            const display = document.getElementById('display');
            display.style.fontSize = '6px';
            display.style.lineHeight = '6px';
        }
        
        // Mathematical constants
        const phi = 1.618033988749895;  // Golden ratio
        const e = 2.718281828459045;
        const pi = 3.141592653589793;
        const sqrt2 = 1.4142135623730951;
        
        // Reaction-diffusion field arrays
        let concentration, diffusion, reaction, gradient;
        
        function initializeFields() {
            const size = W * H;
            concentration = new Float32Array(size);   // Primary concentration field
            diffusion = new Float32Array(size);       // Diffusion coefficients
            reaction = new Float32Array(size);        // Reaction rates
            gradient = new Float32Array(size * 2);    // Gradient field
            
            // Initialize with organic patterns
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const xi = (x - W/2) / (W/4);
                    const yi = (y - H/2) / (H/4);
                    const r = Math.sqrt(xi*xi + yi*yi);
                    
                    // Seed initial concentrations with organic noise
                    concentration[idx] = Math.random() * Math.exp(-r * 0.5);
                    diffusion[idx] = 0.1 + Math.random() * 0.05;
                    reaction[idx] = Math.random() * 0.3;
                }
            }
        }
        
        // Life-form symbols - progression from simple to complex
        const lifeSymbols = [
            '·', '∘', '○', '●', '◦', '◉', '◎',           // Basic forms
            '♦', '◊', '⬦', '⬧', '⬨', '⬩',               // Diamond forms
            '∆', '▲', '▽', '▼', '◀', '▶',               // Triangle forms  
            '⟡', '⟢', '⟣', '⟤', '⟥', '⟦',               // Complex forms
            '⚬', '⚭', '⚮', '⚯', '⚰', '⚱',               // Organic forms
            '⊙', '⊚', '⊛', '⊜', '⊝', '⊞', '⊟', '⊠',   // Advanced forms
            '∞', '∅', '∩', '∪', '⊕', '⊗'                // Mathematical forms
        ];
        
        const colorClasses = ['v','u','s','e','m','t','q','d','w','c','g','y','r','p','b','o','a','f','n','l'];
        
        function idx(x, y) {
            return ((y + H) % H) * W + ((x + W) % W);
        }
        
        // Reaction-diffusion equations for emergent life
        function reactionDiffusion(x, y, time) {
            const xi = (x - W/2) / (W/4);
            const yi = (y - H/2) / (H/4);
            const r = Math.sqrt(xi*xi + yi*yi);
            
            // Activator-inhibitor dynamics (Turing patterns)
            const activator = Math.sin(r * 5 + time * 2) * Math.exp(-r * 0.3);
            const inhibitor = Math.cos(r * 3 - time * 1.5) * Math.exp(-r * 0.5);
            
            // Non-linear reaction terms
            const logistic = 1 / (1 + Math.exp(-5 * (activator - inhibitor)));
            
            // Metabolic oscillations
            const metabolism = Math.sin(time * 3 + x * 0.1 + y * 0.1) * 0.2;
            
            // Growth-decay balance
            const growth = logistic * (1 - logistic) * 4; // Bell curve for optimal growth
            
            return { 
                growth: growth + metabolism,
                diffusion: 0.1 + Math.abs(Math.sin(r + time)) * 0.05,
                reaction: logistic
            };
        }
        
        function update() {
            t += 0.03;
            
            const next = new Float32Array(W * H);
            
            // Reaction-diffusion update
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = idx(x, y);
                    const current = concentration[i];
                    
                    // Calculate Laplacian (diffusion)
                    const neighbors = [
                        concentration[idx(x-1, y)], concentration[idx(x+1, y)],
                        concentration[idx(x, y-1)], concentration[idx(x, y+1)],
                        concentration[idx(x-1, y-1)], concentration[idx(x+1, y-1)],
                        concentration[idx(x-1, y+1)], concentration[idx(x+1, y+1)]
                    ];
                    const laplacian = (neighbors.reduce((a, b) => a + b, 0) - 8 * current);
                    
                    // Get reaction-diffusion dynamics
                    const dynamics = reactionDiffusion(x, y, t);
                    
                    // Update equation: ∂φ/∂t = D∇²φ + f(φ)
                    const diffusionTerm = dynamics.diffusion * laplacian;
                    const reactionTerm = dynamics.growth * current * (1 - current) - 
                                       dynamics.reaction * current * current;
                    
                    // Age and memory effects
                    const age = Math.sin(t * 0.5 + x * 0.05 + y * 0.07) * 0.02;
                    
                    // Self-organization bias
                    const organization = Math.sin(current * pi * 2) * 0.01;
                    
                    next[i] = Math.max(0, Math.min(1, 
                        current + 0.1 * (diffusionTerm + reactionTerm) + age + organization
                    ));
                    
                    // Periodic seeding of new life
                    if (Math.random() < 0.0003) {
                        next[i] += Math.random() * 0.2;
                    }
                }
            }
            
            concentration = next;
            
            // Update diffusion and reaction fields
            for (let i = 0; i < W * H; i++) {
                diffusion[i] = diffusion[i] * 0.99 + Math.random() * 0.01;
                reaction[i] = reaction[i] * 0.98 + concentration[i] * 0.02;
            }
        }
        
        function render() {
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = idx(x, y);
                    const intensity = concentration[i];
                    const react = reaction[i];
                    
                    if (intensity > 0.8) {
                        // Complex life forms
                        const symbolIdx = Math.floor(intensity * lifeSymbols.length * 0.9) + 
                                        Math.floor(lifeSymbols.length * 0.1);
                        const colorIdx = Math.floor((intensity + react * 0.3) * colorClasses.length);
                        const symbol = lifeSymbols[Math.min(symbolIdx, lifeSymbols.length - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorClasses.length - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.5) {
                        // Developing life
                        const symbolIdx = Math.floor(intensity * lifeSymbols.length * 0.6);
                        const colorIdx = Math.floor(intensity * colorClasses.length * 0.8);
                        const symbol = lifeSymbols[Math.min(symbolIdx, lifeSymbols.length - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorClasses.length - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.2) {
                        // Emerging life
                        const symbolIdx = Math.floor(intensity * lifeSymbols.length * 0.3);
                        const symbol = lifeSymbols[Math.min(symbolIdx, lifeSymbols.length - 1)];
                        output += `<span class="u">${symbol}</span>`;
                    } else if (intensity > 0.05) {
                        // Traces of life
                        output += '<span class="l">·</span>';
                    } else {
                        // Substrate/medium
                        if (Math.random() < 0.002) {
                            output += '<span class="l">∘</span>';
                        } else {
                            output += ' ';
                        }
                    }
                }
                output += '\n';
            }
            
            document.getElementById('display').innerHTML = output;
        }
        
        function loop() {
            update();
            render();
            requestAnimationFrame(loop);
        }
        
        // Initialize
        window.addEventListener('resize', () => {
            updateDimensions();
            initializeFields();
        });
          updateDimensions();
        initializeFields();
        loop();
    </script>
</body>
</html>
