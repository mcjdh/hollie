<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>⊕ Synthesis</title>
    <style>
        body { margin:0; padding:0; background:#000; overflow:hidden; }
        #display { 
            font-family:'Courier New',monospace; font-size:8px; line-height:10px; 
            color:#0ff; white-space:pre; padding:0; margin:0;
            width:640px; height:480px; background:#000;
            margin: auto;
            margin-top: 50px;
        }
        .v{color:#f0f} .u{color:#0ff} .s{color:#ff0} .e{color:#0f0} .m{color:#f80}
        .t{color:#f44} .q{color:#84f} .d{color:#48f} .w{color:#fff} .c{color:#8ff}
        .g{color:#4f4} .y{color:#ff4} .r{color:#f44} .p{color:#f8f} .b{color:#44f}
        .o{color:#fa0} .a{color:#aaa} .f{color:#f88} .n{color:#8f8} .l{color:#88f}
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>
    <div class="info">
        ⊕ Synthesis<br>
        Cellular + Fluid + Fractal systems<br>
        Press ESC to return to menu
    </div>
    <div id="display"></div>
    <script>
        const W = 80, H = 48;
        let t = 0;
        
        // Synthesis of multiple consciousness systems
        const cellular = new Float32Array(W * H);    // Cellular automata consciousness
        const fluid = new Float32Array(W * H);       // Flowing awareness 
        const fractal = new Float32Array(W * H);     // Recursive self-organization
        const synthesis = new Float32Array(W * H);   // Emergent combination
        const memory = new Float32Array(W * H);      // Memory traces
        
        // Synthesis symbols - emergence from complexity interaction
        const symbols = [
            ' ', '·', '⠁', '⠃', '⠇', '⠏', '⠟', '⠿', '⡿', '⣿',  // cellular emergence
            '∴', '∵', '∸', '∹', '∺', '∻', '∼', '∽', '∾', '∿',  // fluid logic
            '⊕', '⊖', '⊗', '⊘', '⊙', '⊚', '⊛', '⊜', '⊝', '⊞'   // fractal synthesis
        ];
        
        const colors = ['v','u','s','e','m','t','q','d','w','c','g','y','r','p','b','o','a','f','n','l'];
        
        // Initialize with random cellular seeds
        for (let i = 0; i < W * H; i++) {
            if (Math.random() < 0.08) {
                cellular[i] = Math.random();
            }
        }
        
        function updateCellular() {
            const newCellular = new Float32Array(W * H);
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    let neighbors = 0;
                    let total = 0;
                    
                    // Conway-like rules with continuous values
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = (x + dx + W) % W;
                            const ny = (y + dy + H) % H;
                            const ni = ny * W + nx;
                            
                            if (cellular[ni] > 0.1) {
                                neighbors++;
                                total += cellular[ni];
                            }
                        }
                    }
                    
                    const current = cellular[i];
                    const avg = neighbors > 0 ? total / neighbors : 0;
                    
                    if (current > 0.1) {
                        // Living cell
                        if (neighbors === 2 || neighbors === 3) {
                            newCellular[i] = Math.min(1, current + avg * 0.05);
                        } else {
                            newCellular[i] = Math.max(0, current - 0.08);
                        }
                    } else {
                        // Dead cell
                        if (neighbors === 3) {
                            newCellular[i] = avg * 0.6;
                        } else {
                            newCellular[i] = current * 0.97;
                        }
                    }
                    
                    // Cross-system influence
                    newCellular[i] += fluid[i] * 0.03 + fractal[i] * 0.02;
                    newCellular[i] = Math.max(0, Math.min(1, newCellular[i]));
                }
            }
            
            for (let i = 0; i < W * H; i++) {
                cellular[i] = newCellular[i];
            }
        }
        
        function updateFluid() {
            const τ = t * 0.01;
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    const nx = x / W, ny = y / H;
                    const cx = nx - 0.5, cy = ny - 0.5;
                    
                    // Circular fluid flow with time evolution
                    const angle = Math.atan2(cy, cx) + τ;
                    const r = Math.sqrt(cx * cx + cy * cy);
                    const flow = Math.sin(r * 8 + τ * 2) * Math.cos(angle * 3);
                    
                    // Advection-like behavior
                    const prev = fluid[i];
                    fluid[i] = prev * 0.96 + flow * 0.04;
                    
                    // Cellular influence on fluid
                    if (cellular[i] > 0.5) {
                        fluid[i] += 0.05;
                    }
                    
                    // Fractal sources
                    if (fractal[i] > 0.3) {
                        fluid[i] += fractal[i] * 0.1;
                    }
                    
                    fluid[i] = Math.max(0, Math.min(1, fluid[i]));
                }
            }
        }
        
        function updateFractal() {
            const τ = t * 0.002;
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    
                    // Simplified Julia set with evolving parameters
                    const zx = (x - W/2) / (W/8);
                    const zy = (y - H/2) / (H/8);
                    
                    const cx = 0.7 * Math.cos(τ) - 0.2;
                    const cy = 0.3 * Math.sin(τ * 1.3) + 0.1;
                    
                    let x0 = zx, y0 = zy;
                    let iter = 0;
                    const maxIter = 12;
                    
                    while (x0*x0 + y0*y0 <= 4 && iter < maxIter) {
                        const temp = x0*x0 - y0*y0 + cx;
                        y0 = 2*x0*y0 + cy;
                        x0 = temp;
                        iter++;
                    }
                    
                    let value = iter / maxIter;
                    
                    // System interactions
                    if (cellular[i] > 0.3) value *= 1.2;
                    if (fluid[i] > 0.2) value *= (1 + fluid[i] * 0.3);
                    
                    fractal[i] = fractal[i] * 0.92 + value * 0.08;
                    fractal[i] = Math.max(0, Math.min(1, fractal[i]));
                }
            }
        }
        
        function calculateSynthesis() {
            for (let i = 0; i < W * H; i++) {
                // Synthesis emerges from interaction
                const interaction = cellular[i] * fluid[i] * fractal[i];
                const combination = (cellular[i] + fluid[i] + fractal[i]) / 3;
                const emergence = Math.sqrt(interaction) + combination * 0.5;
                
                synthesis[i] = synthesis[i] * 0.95 + emergence * 0.05;
                
                // Memory accumulation at high synthesis points
                if (synthesis[i] > 0.7) {
                    memory[i] = Math.min(1, memory[i] + 0.01);
                } else {
                    memory[i] *= 0.999;
                }
            }
        }
        
        function render() {
            updateCellular();
            updateFluid();
            updateFractal();
            calculateSynthesis();
            
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    
                    // Choose dominant system or synthesis
                    let intensity, system;
                    const s = synthesis[i] + memory[i] * 0.3;
                    
                    if (s > 0.4) {
                        intensity = s;
                        system = 2; // synthesis symbols
                    } else if (fractal[i] > cellular[i] && fractal[i] > fluid[i]) {
                        intensity = fractal[i];
                        system = 2; // fractal
                    } else if (fluid[i] > cellular[i]) {
                        intensity = fluid[i];
                        system = 1; // fluid
                    } else {
                        intensity = cellular[i];
                        system = 0; // cellular
                    }
                    
                    // Breathing synthesis effect
                    const breath = Math.sin(t * 0.04) * 0.1 + 0.9;
                    intensity *= breath;
                    
                    // Symbol selection by system
                    const baseIdx = system * 10;
                    const symIdx = baseIdx + Math.floor(intensity * 9);
                    const colorIdx = Math.floor(intensity * colors.length);
                    
                    output += `<span class="${colors[colorIdx]}">${symbols[symIdx]}</span>`;
                }
                output += '\n';
            }
            
            document.getElementById('display').innerHTML = output;
            t += 0.5;
            requestAnimationFrame(render);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.parent.postMessage('close', '*');
            }
        });
        
        render();
    </script>
</body>
</html>
