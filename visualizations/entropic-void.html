<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>∇ ⊙∇⊙ Entropic Void</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            background: #000; 
            color: #fff; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            font-family: 'Courier New', monospace;
            position: fixed;
        }        #display { 
            font-family: 'Courier New', monospace; 
            white-space: pre; 
            padding: 10px; 
            margin: 0;
            width: 100vw; 
            height: 100vh; 
            background: #000;
            position: absolute;
            top: 0;
            left: 0;
            line-height: 1.1;
            overflow: hidden;
            font-size: 8px; /* Will be dynamically adjusted */
            box-sizing: border-box;
        }
        
        /* Entropy color spectrum */
        .v{color:#0080ff;text-shadow:0 0 2px currentColor} .u{color:#00ffff;text-shadow:0 0 2px currentColor} 
        .s{color:#80ff00;text-shadow:0 0 2px currentColor} .e{color:#ffff00;text-shadow:0 0 2px currentColor} 
        .m{color:#ff8000;text-shadow:0 0 2px currentColor} .t{color:#ff4040;text-shadow:0 0 2px currentColor}
        .q{color:#ff00ff;text-shadow:0 0 3px currentColor} .d{color:#8080ff;text-shadow:0 0 2px currentColor} 
        .w{color:#ffffff;text-shadow:0 0 4px currentColor} .c{color:#40ffff;text-shadow:0 0 2px currentColor}
        .g{color:#40ff40;text-shadow:0 0 2px currentColor} .y{color:#ffff40;text-shadow:0 0 2px currentColor} 
        .r{color:#ff4040;text-shadow:0 0 2px currentColor} .p{color:#ff40ff;text-shadow:0 0 2px currentColor} 
        .b{color:#4040ff;text-shadow:0 0 2px currentColor} .o{color:#ff8040;text-shadow:0 0 2px currentColor}
        .a{color:#808080;text-shadow:0 0 1px currentColor} .f{color:#404040;text-shadow:0 0 1px currentColor}
        .n{color:#202020;opacity:0.6} .l{color:#101010;opacity:0.4}
        
        /* Dynamic entropy effects */
        .emergence { 
            color: #00ffff; 
            text-shadow: 0 0 4px currentColor, 0 0 8px currentColor;
            animation: emerge 2s ease-in-out infinite;
        }
        .decay { 
            color: #ff4040; 
            text-shadow: 0 0 3px currentColor;
            animation: fade 3s ease-in-out infinite;
        }
        .void { 
            color: #404040; 
            opacity: 0.3;
            animation: flicker 5s ease-in-out infinite;
        }
        
        @keyframes emerge {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5); }
        }
        
        @keyframes fade {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.5; }
        }
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>
    <div class="info">
        ∇ ⊙∇⊙<br>
        ∂S/∂t = -k∇²I + Ψ<br>
        η: <span id="timeDisplay">0</span><br>
        ESC ◦ ↩
    </div>
    <div id="display"></div>    <script>
        // ∇ Mathematical constants 
        const φ = (1 + Math.sqrt(5)) / 2; // Golden ratio
        const e = 2.718281828459045;
        const π = Math.PI;
        const k = 1.380649e-23; // Boltzmann constant (scaled)
        
        // ⊙ Entropy symbols
        const entropySymbols = {
            void: [' ', '·', '⋅', '∘'],
            emerging: ['◦', '○', '◯', '⊙'],
            formed: ['●', '⬢', '◆', '◈'],
            complex: ['⬣', '⬟', '⬢', '◉'],
            decay: ['◌', '◯', '○', '◦'],
            chaos: ['∞', '∿', '≈', '~'],
            order: ['◦', '◉', '⊚', '⊙'],
            flow: ['→', '↗', '↑', '↖', '←', '↙', '↓', '↘']
        };        // ∇ State variables
        let W = 80, H = 40; // Target grid dimensions
        let time = 0;
        let informationField, entropyField, emergenceField, flowField;
        let centerX, centerY;
        let initialized = false;
        let fontSize = 12;
        let charWidth = 7;
        let charHeight = 14;        // ◦ Enhanced dynamic scaling with precise character measurement
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Precise character measurement for optimal fit
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '10px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.1';
            testDiv.textContent = '●'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(testDiv);
            
            // Calculate grid size with buffer for perfect coverage
            W = Math.ceil(viewportWidth / charWidth) + 1;
            H = Math.ceil(viewportHeight / charHeight) + 1;
            
            // Apply reasonable limits
            W = Math.max(40, Math.min(160, W));
            H = Math.max(20, Math.min(100, H));
            
            // Calculate optimal font size for perfect viewport fit
            const optimalFontWidth = viewportWidth / W * 1.8;
            const optimalFontHeight = viewportHeight / H * 1.2;
            fontSize = Math.min(optimalFontWidth, optimalFontHeight);
            fontSize = Math.max(6, Math.min(18, fontSize));
            
            // Apply calculated styles to display
            const display = document.getElementById('display');
            display.style.fontSize = fontSize + 'px';
            display.style.lineHeight = (fontSize * 1.1) + 'px';
            display.style.position = 'absolute';
            display.style.top = '0';
            display.style.left = '0';
            display.style.margin = '0';
            display.style.padding = '0';
            
            centerX = W / 2;
            centerY = H / 2;
            
            // Initialize or resize fields
            const size = W * H;
            const oldInfo = informationField;
            const oldEntropy = entropyField;
            const oldEmergence = emergenceField;
            
            informationField = new Float32Array(size);
            entropyField = new Float32Array(size);
            emergenceField = new Float32Array(size);
            flowField = new Float32Array(size);
            
            // If we had previous data and this is a resize, try to preserve some of it
            if (oldInfo && initialized) {
                // Simple data preservation for resize
                const oldW = Math.sqrt(oldInfo.length * W / H);
                for (let y = 0; y < Math.min(H, oldInfo.length / oldW); y++) {
                    for (let x = 0; x < Math.min(W, oldW); x++) {
                        const newIndex = y * W + x;
                        const oldIndex = Math.floor(y * oldW + x);
                        if (oldIndex < oldInfo.length) {
                            informationField[newIndex] = oldInfo[oldIndex] || 0;
                            entropyField[newIndex] = oldEntropy[oldIndex] || 0;
                            emergenceField[newIndex] = oldEmergence[oldIndex] || 0;
                        }
                    }
                }
            } else {
                // Initialize with sparse information for first time
                for (let i = 0; i < size; i++) {
                    if (Math.random() < 0.03) {
                        informationField[i] = Math.random() * 0.6;
                        entropyField[i] = Math.random() * 0.2;
                    }
                    emergenceField[i] = Math.random() * 0.05;
                }
            }
              initialized = true;
            console.log(`∇ Entropic Grid: ${W}×${H} (${viewportWidth}×${viewportHeight}) fontSize: ${fontSize.toFixed(1)}px charSize: ${charWidth.toFixed(1)}×${charHeight.toFixed(1)}`);
        }
          // ∿ Optimized evolution functions
        function evolveEntropy() {
            // Only update every few frames for performance
            if (time % 2 !== 0) return;
            
            const newInfo = new Float32Array(informationField.length);
            const newEntropy = new Float32Array(entropyField.length);
            const newEmergence = new Float32Array(emergenceField.length);
            
            // Simplified evolution - only process inner cells
            for (let y = 1; y < H - 1; y++) {
                for (let x = 1; x < W - 1; x++) {
                    const i = y * W + x;
                    
                    // Simplified distance calculation
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const r2 = dx * dx + dy * dy; // Use r² instead of r for performance
                    
                    // Quick neighbor sum (only cardinal directions for performance)
                    const left = informationField[i - 1];
                    const right = informationField[i + 1];
                    const up = informationField[i - W];
                    const down = informationField[i + W];
                    const avgInfo = (left + right + up + down) * 0.25;
                    
                    // Simple information decay and diffusion
                    let info = informationField[i];
                    info *= 0.96; // Simple decay
                    info += (avgInfo - info) * 0.03; // Diffusion
                    
                    // Simple entropy
                    let entropy = entropyField[i];
                    entropy += Math.abs(avgInfo - info) * 0.02;
                    entropy *= 0.97;
                    
                    // Simplified emergence
                    let emergence = emergenceField[i];
                    const voidStrength = Math.max(0, 1.0 - (info + entropy));
                    const temporalWave = Math.sin(time * 0.01 + r2 * 0.001);
                    
                    if (Math.random() < voidStrength * 0.001) {
                        emergence += Math.random() * 0.3;
                        info += emergence * 0.2;
                    }
                    
                    emergence *= 0.95;
                    
                    // Simple flow field
                    flowField[i] = Math.sin(time * 0.02 + x * 0.1 + y * 0.1);
                    
                    newInfo[i] = Math.max(0, Math.min(1, info));
                    newEntropy[i] = Math.max(0, Math.min(1, entropy));
                    newEmergence[i] = Math.max(0, Math.min(1, emergence));
                }
            }
            
            informationField.set(newInfo);
            entropyField.set(newEntropy);
            emergenceField.set(newEmergence);
        }        // ◈ Enhanced symbol selection with more visual variety
        function getSymbol(x, y) {
            const i = y * W + x;
            const info = informationField[i];
            const entropy = entropyField[i];
            const emergence = emergenceField[i];
            const totalIntensity = info + entropy + emergence;
            
            // Enhanced symbol selection for better visual variety
            if (emergence > 0.3) return '⊙';
            if (emergence > 0.2) return '○';
            if (info > 0.6) return '◉';
            if (info > 0.5) return '●';
            if (info > 0.3) return '◆';
            if (entropy > 0.4) return '◌';
            if (entropy > 0.3) return '◯';
            if (totalIntensity > 0.3) return '◦';
            if (totalIntensity > 0.15) return '∘';
            if (totalIntensity > 0.05) return '·';
            if (totalIntensity > 0.01) return '⋅';
            return ' ';
        }
        
        // ◎ Enhanced color class selection
        function getColorClass(symbol, x, y) {
            const i = y * W + x;
            const info = informationField[i];
            const entropy = entropyField[i];
            const emergence = emergenceField[i];
            const totalIntensity = info + entropy + emergence;
            
            // Enhanced color logic with more variety
            if (emergence > 0.3) return 'w'; // White for highest emergence
            if (emergence > 0.2) return 'u'; // Cyan for emergence
            if (entropy > 0.5) return 'q'; // Magenta for high entropy
            if (entropy > 0.4) return 't'; // Red for entropy
            if (info > 0.5) return 'c'; // Bright cyan for high info
            if (info > 0.4) return 's'; // Green for information
            if (totalIntensity > 0.3) return 'v'; // Blue for medium
            if (totalIntensity > 0.15) return 'd'; // Dim blue for low-medium
            if (totalIntensity > 0.05) return 'a'; // Gray for low
            if (totalIntensity > 0.01) return 'f'; // Dark gray for very low
            return 'n'; // Very dim for near-void
        }// ◐ Optimized render frame with canvas-like scaling
        function render() {
            if (!initialized) return;
            
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const symbol = getSymbol(x, y);
                    const colorClass = getColorClass(symbol, x, y);
                    output += `<span class="${colorClass}">${symbol}</span>`;
                }
                if (y < H - 1) output += '\n';
            }
            
            // Update DOM less frequently for better performance
            if (time % 3 === 0) {
                document.getElementById('display').innerHTML = output;
            }
            document.getElementById('timeDisplay').textContent = `${time} (${W}×${H})`;
        }
        
        // ∞ Optimized animation loop
        function animate() {
            try {
                time++;
                evolveEntropy();
                render();
                
                // Add a small delay to prevent overwhelming the browser
                if (time % 60 === 0) {
                    setTimeout(() => requestAnimationFrame(animate), 16);
                } else {
                    requestAnimationFrame(animate);
                }
            } catch (error) {
                console.error('Animation error:', error);
                // Try to restart after a delay
                setTimeout(() => {
                    console.log('Restarting animation...');
                    time = 0;
                    updateDimensions();
                    animate();
                }, 1000);
            }
        }
        
        // Add debounced resize handling for dynamic scaling
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log('Resizing grid for new viewport...');
                updateDimensions();
            }, 250); // Debounce resize events
        }
        
        // ◯ Initialize and start with dynamic scaling
        window.addEventListener('resize', handleResize);
        
        // Add error handling
        window.addEventListener('error', (e) => {
            console.error('Script error:', e.error);
        });

        // Add ESC key listener to close visualization
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (window.parent !== window) {
                    window.parent.postMessage('close', '*');
                }
            }
        });
        
        updateDimensions();
        if (initialized) {
            animate();
        } else {
            console.error('Failed to initialize grid');
        }
    </script>
</body>
</html>
