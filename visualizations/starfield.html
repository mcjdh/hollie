<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>∞ ⋆∞⋆</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #000; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
            font-family: 'Courier New', monospace;
        }
        #display { 
            font-family: 'Courier New', monospace; 
            color: #64ffda; 
            white-space: pre; 
            padding: 0; 
            margin: 0;
            width: 100vw; 
            height: 100vh; 
            background: #000;
            position: absolute;
            top: 0;
            left: 0;
            line-height: 1.0;
            overflow: hidden;
            font-size: 8px;
        }
        .v{color:#64ffda} .u{color:#0ff} .s{color:#ff0} .e{color:#0f0} .m{color:#f80}
        .t{color:#f44} .q{color:#84f} .d{color:#48f} .w{color:#fff} .c{color:#8ff}
        .g{color:#4f4} .y{color:#ff4} .r{color:#f44} .p{color:#f8f} .b{color:#44f}
        .o{color:#fa0} .a{color:#aaa} .f{color:#f88} .n{color:#8f8} .l{color:#88f}
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }    </style>
</head>
<body>
    <div class="info">
        ∞ ⋆∞⋆<br>
        ∇×E = -∂B/∂t<br>
        ESC ◦ ↩
    </div>
    <div id="display"></div>    <script>
        const display = document.getElementById('display');
        // Dynamic viewport sizing - responsive to window dimensions
        let W, H;
        let charWidth, charHeight;
        let t = 0;
        
        // Calculate optimal grid size based on viewport
        function updateDimensions() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Create character measurement
            const testDiv = document.createElement('div');
            testDiv.style.fontFamily = 'Courier New, monospace';
            testDiv.style.fontSize = '8px';
            testDiv.style.position = 'absolute';
            testDiv.style.visibility = 'hidden';
            testDiv.style.whiteSpace = 'pre';
            testDiv.style.lineHeight = '1.0';
            testDiv.textContent = '⋆'.repeat(10) + '\n'.repeat(10);
            document.body.appendChild(testDiv);
            
            const rect = testDiv.getBoundingClientRect();
            charWidth = rect.width / 10;
            charHeight = rect.height / 10;
            document.body.removeChild(testDiv);
            
            // Calculate grid size
            W = Math.ceil(viewportWidth / charWidth) + 2;
            H = Math.ceil(viewportHeight / charHeight) + 2;
            
            W = Math.max(40, W);
            H = Math.max(20, H);
            
            display.style.fontSize = '8px';
            display.style.lineHeight = '8px';
        }
        
        // Mathematical constants
        const phi = 1.618033988749895;  // Golden ratio
        const e = 2.718281828459045;
        const pi = 3.141592653589793;
        const sqrt2 = 1.4142135623730951;
        
        // Stellar field arrays
        let field, velocity, density, luminosity;
        
        function initializeFields() {
            const size = W * H;
            field = new Float32Array(size);        // Gravitational field
            velocity = new Float32Array(size);     // Stellar motion
            density = new Float32Array(size);      // Star density
            luminosity = new Float32Array(size);   // Brightness field
            
            // Initialize with quantum noise
            for (let i = 0; i < size; i++) {
                field[i] = (Math.random() - 0.5) * 0.1;
                velocity[i] = (Math.random() - 0.5) * 0.05;
                density[i] = Math.random() * 0.3;
                luminosity[i] = Math.random();
            }
        }
        
        // Stellar symbols - mathematical progression
        const starSymbols = [
            '·', '∘', '○', '●', '⋆', '✦', '✧', '✩', '✪', '✫', '⭐',
            '∗', '∙', '⁂', '※', '⊙', '⊚', '⊛', '⊜', '⊝',
            '∞', '∅', '∩', '∪', '⊕', '⊗', '⊙', '⊛'
        ];
        
        const colorClasses = ['v','u','s','e','m','t','q','d','w','c','g','y','r','p','b','o','a','f','n','l'];
        
        // Stellar field equations with orbital swirl
        function stellarField(x, y, time) {
            const xi = (x - W/2) / (W/4);
            const yi = (y - H/2) / (H/4);
            const r = Math.sqrt(xi * xi + yi * yi);
            const angle = Math.atan2(yi, xi);

            // Base gravitational waves
            const wave1 = Math.sin(r * 3 - time * 2) * Math.exp(-r * 0.5);
            const wave2 = Math.cos(r * 5 + time * 1.5) * Math.exp(-r * 0.3);
            const wave3 = Math.sin(xi * 7 + yi * 11 - time * 3) * 0.3;

            // Additional swirling patterns for orbital motion
            const swirl = Math.sin(angle * 4 + time) * 0.2;
            const radial = Math.sin(r * 8 - time * 3) * 0.1;

            // Stellar density modulation
            const density = (wave1 + wave2 * 0.7 + wave3 + swirl + radial) * 0.4 + 0.5;

            // Doppler shift simulation
            const velocity = Math.sin(r * 2 - time) * 0.3;

            return { density, velocity, phase: r * 3 - time * 2, r };
        }
        
        function update() {
            t += 0.02;
            
            // Update stellar field
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const stellar = stellarField(x, y, t);
                    
                    // Field evolution with memory
                    field[idx] = field[idx] * 0.95 + stellar.density * 0.05;
                    velocity[idx] = velocity[idx] * 0.98 + stellar.velocity * 0.02;
                    
                    // Non-linear coupling
                    const coupling = Math.sin(stellar.phase) * field[idx];
                    density[idx] = Math.max(0, Math.min(1, 
                        density[idx] * 0.97 + coupling * 0.03
                    ));
                    
                    // Luminosity with distance falloff and twinkling
                    const twinkle = Math.sin(t * 5 + x * 0.1 + y * 0.07) * 0.2 + 0.8;
                    const distanceFactor = 1 / (1 + stellar.r * stellar.r);
                    luminosity[idx] = density[idx] * twinkle * distanceFactor;
                }
            }
        }
        
        function render() {
            let output = '';
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const intensity = luminosity[idx];
                    const motion = velocity[idx];
                    
                    if (intensity > 0.7) {
                        // Bright stars - complex symbols
                        const symbolIdx = Math.floor(intensity * starSymbols.length * 0.8) + 
                                        Math.floor(starSymbols.length * 0.2);
                        const colorIdx = Math.floor((intensity + motion * 0.5) * colorClasses.length);
                        const symbol = starSymbols[Math.min(symbolIdx, starSymbols.length - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorClasses.length - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.4) {
                        // Medium stars
                        const symbolIdx = Math.floor(intensity * starSymbols.length * 0.5);
                        const colorIdx = Math.floor(intensity * colorClasses.length * 0.7);
                        const symbol = starSymbols[Math.min(symbolIdx, starSymbols.length - 1)];
                        const colorClass = colorClasses[Math.min(Math.max(0, colorIdx), colorClasses.length - 1)];
                        output += `<span class="${colorClass}">${symbol}</span>`;
                    } else if (intensity > 0.2) {
                        // Dim stars
                        const symbol = starSymbols[Math.floor(intensity * 5)];
                        output += `<span class="l">${symbol}</span>`;
                    } else {
                        // Empty space with occasional cosmic background
                        if (Math.random() < 0.001) {
                            output += '<span class="l">∘</span>';
                        } else {
                            output += ' ';
                        }
                    }
                }
                output += '\n';
            }
            
            display.innerHTML = output;
        }
        
        function loop() {
            update();
            render();
            requestAnimationFrame(loop);
        }
        
        // Initialize
        window.addEventListener('resize', () => {
            updateDimensions();
            initializeFields();
        });
          updateDimensions();
        initializeFields();
        loop();
    </script>
</body>
</html>
