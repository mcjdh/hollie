<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>∞ Mathematical Singularity</title>
    <style>
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1.0;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #canvas {
            white-space: pre;
            font-feature-settings: 'kern' 0;
            filter: blur(0.02px);
        }
        .v { color: #ffffff; } .u { color: #ffcccc; } .s { color: #ccffcc; }
        .e { color: #ccccff; } .m { color: #ffffcc; } .t { color: #ffccff; }
        .q { color: #ccffff; } .d { color: #ff9999; } .w { color: #99ff99; }
        .c { color: #9999ff; } .g { color: #ff6666; } .y { color: #66ff66; }
        .r { color: #6666ff; } .p { color: #ff3333; } .b { color: #33ff33; }
        .o { color: #3333ff; } .a { color: #ff0000; } .f { color: #00ff00; }
        .n { color: #0000ff; } .l { color: #888888; }
        
        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            font-size: 12px;
            color: #64ffda;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>
    <div class="info">
        ∞ Mathematical Singularity<br>
        Pure mathematical field visualization<br>
        Press ESC to return to menu
    </div>
    <div id="canvas"></div>
    <script>
        const W = 80, H = 48;
        let t = 0;
          // Mathematical constants - core DNA
        const phi = 1.618033988749895;  // Golden ratio
        const e = 2.718281828459045;
        const pi = 3.141592653589793;
        const sqrt2 = 1.4142135623730951;
        const sqrt3 = 1.7320508075688772;
        
        // Field arrays
        const psi = new Float32Array(W * H);           // Wave function  
        const chi = new Float32Array(W * H);           // Complexity field
        const mu = new Float32Array(W * H);           // Memory persistence
        const grad = new Float32Array(W * H * 2);       // Gradient field
        
        // Self-evolving parameters
        const omega = [0.01, 0.007, 0.013, 0.019, 0.023];  // Frequencies
        const alpha = [2.0, e, pi, sqrt3, phi*phi];                // Non-linear params
        const kappa = [1.0, phi, 1/phi, sqrt2, sqrt3];               // Coupling strengths
        let phaseX = [0, pi/3, 2*pi/3, pi, 4*pi/3];            // Phase relationships
        
        // Symbol progression from pure mathematics
        const symbols = [
            '·','.','∘','○','●',                     // Points/circles
            '|','‖','∫','∮','∬',                     // Lines/integrals  
            '∆','∇','∂','δ','∊',                     // Operators
            '∞','∅','∩','∪','⊕',                     // Set theory
            'α','β','γ','δ','ε','ζ','η','θ','λ','μ', // Greek letters
            '∃','∀','⊂','⊃','≡','≈','≠','≤','≥',    // Logic/relations
            '∑','∏','∫','√','∛','∜',                 // Advanced operations
            '⊗','⊙','⊛','⊜','⊝','⊞','⊟','⊠',       // Tensors
            '∰','∱','∲','∳','⨀','⨁','⨂','⨃','⨄'    // Higher mathematics
        ];
          // Pure mathematical field
        function Psi(x, y) {
            const xi = (x - W/2) / (W/4);
            const eta = (y - H/2) / (H/4);
            const r = Math.sqrt(xi*xi + eta*eta);
            const theta = Math.atan2(eta, xi);
            
            let field = 0;
            let complexity = 0;
            
            // Multi-dimensional interference
            for (let i = 0; i < 5; i++) {
                // Radial component
                const R = Math.sin(r * alpha[i] + t * omega[i] + phaseX[i]);
                
                // Angular component
                const Theta = Math.cos(theta * (i + 1) + t * omega[i] * 1.3);
                
                // Non-linear coupling
                const coupling = Math.tanh(R * Theta * kappa[i]);
                
                // Temporal modulation
                const temporal = Math.sin(t * omega[i] * 0.7 + Math.sin(t * omega[i] * 2.3) * 0.5);
                
                field += coupling * temporal;
                complexity += Math.abs(coupling) * Math.log(1 + Math.abs(temporal));
            }
            
            // Self-modulation feedback
            field += Math.sin(field * pi + t * 0.003) * 0.3;
            
            return { field, complexity };
        }
        
        // Parameter evolution
        function evolveParameters() {
            const tau = t * 0.001;
            
            for (let i = 0; i < 5; i++) {
                // Frequency drift
                omega[i] += Math.sin(tau * phi + i * 2*pi/5) * 0.00001;
                omega[i] = Math.max(0.001, Math.min(0.1, omega[i]));
                
                // Phase evolution
                phaseX[i] += omega[i] * tau + Math.sin(omega[i] * tau * 10) * 0.01;
                
                // Coupling self-optimization
                kappa[i] += Math.sin(tau * omega[i] * phi) * 0.001;
                kappa[i] = Math.max(0.1, Math.min(3.0, kappa[i]));
            }
        }
        
        // Field updates
        function updateFields() {
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    const { field, complexity } = Psi(x, y);
                    
                    // Wave evolution with memory
                    psi[idx] = psi[idx] * 0.85 + field * 0.15;
                    
                    // Complexity accumulation  
                    chi[idx] = chi[idx] * 0.9 + complexity * 0.1;
                    
                    // Memory persistence
                    mu[idx] = mu[idx] * 0.95 + Math.abs(field) * 0.05;
                    
                    // Gradient calculation
                    if (x > 0 && x < W-1) {
                        grad[idx*2] = (psi[y*W + x+1] - psi[y*W + x-1]) / 2;
                    }
                    if (y > 0 && y < H-1) {
                        grad[idx*2+1] = (psi[(y+1)*W + x] - psi[(y-1)*W + x]) / 2;
                    }
                }
            }
        }
        
        // Symbol selection from mathematical state
        function getSymbol(intensity, complexity, gradMag, persistence) {
            const magnitude = Math.abs(intensity);
            const phi_ratio = complexity / phi;
            
            // Calculate index from mathematical properties
            let index = 0;
            index += Math.floor(magnitude * 15);
            index += Math.floor(phi_ratio * 10);
            index += Math.floor(gradMag * 8);
            index += Math.floor(persistence * 5);
            
            index = Math.max(0, Math.min(symbols.length - 1, index));
            return symbols[index];
        }
        
        // Color class from field state
        function getColorClass(intensity, complexity, phase) {
            const classes = ['l','n','f','o','b','p','r','y','g','c','w','d','q','t','m','e','s','u','v'];
            
            const combined = Math.abs(intensity) + complexity * 0.5 + Math.sin(phase) * 0.3;
            const index = Math.floor(combined * classes.length) % classes.length;
            
            return classes[index];
        }
        
        // Main render loop
        function render() {
            evolveParameters();
            updateFields();
            
            let output = '';
              // Global breathing
            const breath = (
                Math.sin(t * omega[0]) +
                Math.sin(t * omega[1] * phi) + 
                Math.sin(t * omega[2] / phi)
            ) / 3 * 0.2 + 0.8;
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const idx = y * W + x;
                    
                    const intensity = psi[idx] * breath;
                    const complexity = chi[idx];
                    const persistence = mu[idx];
                    const gradMag = Math.sqrt(grad[idx*2]**2 + grad[idx*2+1]**2);
                    const phase = t * omega[0] + x * 0.1 + y * 0.1;
                    
                    const symbol = getSymbol(intensity, complexity, gradMag, persistence);
                    const colorClass = getColorClass(intensity, complexity, phase);
                    
                    output += `<span class="${colorClass}">${symbol}</span>`;
                }
                output += '\n';
            }
            
            document.getElementById('canvas').innerHTML = output;
            t++;
        }
        
        function evolve() {
            render();
            requestAnimationFrame(evolve);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.parent.postMessage('close', '*');
            }
        });
        
        evolve();
    </script>
</body>
</html>
